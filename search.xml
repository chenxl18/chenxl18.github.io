<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx的详细配置]]></title>
    <url>%2F2019%2F09%2F02%2Flinux%2Fnginx%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[笔试题rpm只能查文件（只能查rpm安装的软件），不能查路径 内核模块：kennel内核： 管理cpu调度 对进程进行管理 对内存进行分配 对文件系统管理 其他硬件（网络） 屏蔽hup信号的命令 trap 1trap 'echo i am busy' 2 1 nohup 1nohup bash while.sh &amp; 查看所有信号kill -l 1234515) SIGTERM --默认1) SIGHUP 父进程死了给所有的子进程发hup,内核会杀死所有的接受到的hup信号的进程2) SIGINT ctrl+c9) SIGKILL 不能被屏蔽的信号，内核强制杀死进程19) SIGSTOP ctrl+z cmd1 &amp;&amp; cmd2 前面的cmd1执行成功就执行cmd2 cmd1 || cmd2 前面的cmd1执行不成功就执行cmd2 cmd1 &amp;&amp; cmd2 || cmd3 前面的cmd1执行成功就执行cmd2，不成功就执行cmd3 cmd1 ; cmd2 前面的cmd1执行不管是否成功都会执行cmd2 ; 命令连接符号 nginx service network restart 和 service network reload的区别 restart 业务会中断，正在运行的业务，（旧业务）会终止，新的业务受影响，不能在stop的时候进入 start的时候，nginx进程会去读取 keepalived和NFC没有使用 后端的real-server如何知道前端的客户机的ip地址？ kill和killall的区别killall可以接进程名，批量杀死进程 高可用keepalived]]></content>
      <categories>
        <category>linux高级</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本的基础命令]]></title>
    <url>%2F2019%2F08%2F29%2Flinux%2Fshell%E8%84%9A%E6%9C%AC%E7%9A%84%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[CUT从文本文件或者文本流中提取文本列 cut -选项 提取范围 文本文件 常见选项 -c:从指定提取范围中提取字符（character） -f:从指定提取范围中提取字段（field） -d:指定分隔符(delimiter)，默认分隔符是tab键 提取范围 n:第n项 n-:第n项到行尾 -m:行首到第m项 n,m:第n项和第m项 n-m:第n项到第m项 注：tr -s &quot; &quot;压缩空格（去重）、tr -d &quot;%&quot;:删除% 得出根分区的使用率的数字和得出/boot分区的使用率的数字 tr 字符装换工具 只能对stdin操作，不能直接对文件操作 使用tr装换字符tr SET1 SET2 用SET2中的字符替换掉SET1中同一位置的字符 12[root@cxl lianxi]# echo 123456|tr 456 abc123abc 删除功能（-d） 压缩功能 管道“|”连接左右两个命令，将左侧的命令的标准输出(正确的输出)，作为右侧命令的标准输入，前面，命令的错误输出不会送到管道符号给后面命令作为输入，除非2&gt;&amp;1。 2&gt;&amp;1:错误的跟着正确的也传过去 格式cmd1 | cmd2 [...|cmdn] 用grep过滤输出 ls -l /etc/|grep pass 管道和标准错误 find /etc -name &quot;p*&quot;|grep passwd 查找出/etc目录所有的.conf结尾的文件，然后将文件的路径重定向到/lianxi/all_conf.txt 1find /etc |grep ".conf$" &gt;/lianxi/all_conf.txt xargs将前面命令的输出送给后面的命令作为参数使用 用途：将参数列表转换成小块分段传递给其他命令 读入stdin的数据装换为参数添加到命令行中 让一些不支持管道的命令可以使用管道 basename根据文件的路径截取文件名。 ； 命令连接符号 先执行cmd1，然后在执行cmd2，再执行cmd3，不管前面的命令执行是否成功都会执行后面的命令 cmd1 ; cmd2 ; cmd3 &lt;导入符号 将后面文件的内容导入到前面命令 catcat能够合并两个文件的内容，能查看文件里的内容 标准输出 seq用途打印出一串有序的数字 123456789101112131415161718192021222324252627282930[root@cxl lianxi]# seq 1012345678910[root@cxl lianxi]# seq 5 105678910[root@cxl lianxi]# seq 1 +2 10 #递增2得到单数 +2步长13579[root@cxl lianxi]# seq 10 -2 1 #递减2，得到双数108642 格式seq [选项] 数字范围 -s:指定分隔符(separator) 1234[root@cxl lianxi]# seq -s " " 2 +2 102 4 6 8 10[root@cxl lianxi]# seq -s "+" 2 +2 102+4+6+8+10 -w:指定同等宽带输出(equal-width) 1234567891011[root@cxl lianxi]# seq -w 1001020304050607080910 bclinux下的计算器 123[root@cxl lianxi]# seq -s "+" 100|bc5050yum install bc 1234567891011121314151617181920[root@cxl lianxi]# bash for.sh1,hello2,hello3,hello4,hello5,hello6,hello7,hello8,hello9,hello10,hello[root@cxl lianxi]# cat for.sh #!/bin/bashfor i in `seq 10`do echo "$i,hello"done[root@cxl lianxi]# 1234567891011121314151617181920[root@cxl lianxi]# bash for.shnum1:2num2:102,hello3,hello4,hello5,hello6,hello7,hello8,hello9,hello10,hello[root@cxl lianxi]# cat for.sh #!/bin/bashread -p "num1:" num1read -p "num2:" num2for i in `seq $num1 $num2`do echo "$i,hello"done tee将内容重定向到一个文件，并且在屏幕上输出 1234[root@cxl lianxi]# echo 123456|tee 123.txt123456[root@cxl lianxi]# cat 123.txt 123456 $() 和``$( )作用就是让命令在里面执行，得到这个命令执行的结果 $( )和``作用是一样 sort默认按每行的第一个字符排序 -n:按整数进行排序 -r:递减排序 指定排序键指定按哪一列数据进行排序 -k:指定哪一列为排序键 指定字段分割符-t：指定字段分割符（默认是空白）]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>cut</tag>
        <tag>awk</tag>
        <tag>;命令连接符</tag>
        <tag>管道</tag>
        <tag>xargs</tag>
        <tag>basename</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx的负载均衡]]></title>
    <url>%2F2019%2F08%2F28%2Flinux%2Fnginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[nginx也可以做负载均衡（load balancer） 集群：很多台电脑完成相同的工作，至少是2台以上的电脑 负载均衡器：分配访问任务的一个机器（软件） 应用场景：很多用户的情况下，很多机器提供相同服务，需要均匀的分配任务到不同的机器上，不让某台机器压力过大，导致用户访问不了 负载均衡算法upstrean支持4种负载均衡调度算法 轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器; ip_hash：每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。 url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。后台服务器为缓存的时候效率。 fail：这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持 fair的，如果需要使用这种调度算法，必须下载Nginx的 upstream_fair模块。 准备规划好ip地址和服务器的角色 4台 ： 1台 LB1 :192.168.1.126 real-server-1 ：192.168.1.178 real-server-2 ：192.168.1.163 NFS-SERVER ：192.168.1.139 让real-server的web服务正常运行 安装nginx 启动服务器 挂载NFS共享的网站内容 yum install nginx -y 访问网站 搭建好NFS服务 2台web服务器挂载nfs共享的目录，达到网页内容一致 搭建好负载均衡服务器 轮询算法12345678910111213141516[root@LB1 conf]# cd /usr/local/nginx/conf/[root@LB1 conf]# upstream sanchuang &#123; server 192.168.1.163:80 weight=1; #server-1 server 192.168.1.178:80 weight=1;&#125;server &#123; listen 80 default_server reuseport; server_name www.sanchuang.com; location / &#123; proxy_pass http://sanchuang; &#125; &#125; 基于ip-hash12345678910111213141516#设定负载均衡服务器列表upstream roundrobin &#123; #后端服务器访问规则 ip_hash; #添加参数支持哈希 server 192.168.1.115:8080 weight=1; #server1 server 192.168.1.131:8080 weight=1; #server1 server 192.168.1.94:8090 weight=1; #server3 &#125;server &#123; listen 80; server_name 192.168.1.131; location / &#123; proxy_pass http://roundrobin; &#125;&#125;]]></content>
      <categories>
        <category>linux高阶</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统性能监控]]></title>
    <url>%2F2019%2F08%2F28%2Flinux%2F%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[笔试题 （1）硬链接和软链接 （2）p、s b block 块 c char 字符 l link 链接 d 文件夹 s sock socket p pipe 管道 （3） （1）CLOSE-WAIT （2）25 （3）计划任务,iptables策略 ​ 0 8-18 * * 1-5 base/root/iptables.sh （4）STP:生成树协议 （1）错误日志、二进制日志、慢日志、 (1)ip地址、域名、时间、状态码、时间、状态码、url、 (2)cat access.log |awk ‘ $9&gt;200 {print $1}’ |sort|uniq -c |sort -rn|head 将本地一个name.txt 导入脚本中，创建name.txt中的新用户并生成随机密码，将对用的随机密码和用户名导入新文本newname.txt中 cat create_user.sh 123456789#!/bin/bash&gt;user_passwd.txtfor i in $(cat /root/name.txt)do useradd $i u_passwd=$(echo $i |md5sum |cut -c 1-15) echo $u_passwd |passwd $i --stdin echo -e "$i\t$u_passwd" &gt;&gt;user_passwd.txtdone 系统性能监控进程查看命令静态查看进程的信息，某一个时刻进程的信息 https://www.cnblogs.com/wxgblogs/p/6591980.html 12345[root@LNMP ~]# ps -lF S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD4 S 0 16843 16833 0 80 0 - 28860 do_wai pts/1 00:00:00 bash0 R 0 32093 16843 0 80 0 - 38309 - pts/1 00:00:00 ps[root@LNMP ~]# 由于 ps 能够支持的系统类型相当的多，所以他的参数多的离谱，而且有没有加上 - 差很多！ 将目前属于您自己这次登入的 PID 与相关信息列示出来 各相关信息的意义为： F 代表这个程序的旗标 (flag)， 4 代表使用者为superuser； S 代表这个程序的状态 (STAT)； UID 代表执行者身份 PID 进程的ID号！ PPID 父进程的ID C CPU使用的资源百分比 PRI指进程的执行优先权(Priority的简写)，其值越小越早被执行； NI 这个进程的nice值，其表示进程可被执行的优先级的修正数值。 ADDR 这个是内核函数，指出该程序在内存的那个部分。如果是个执行 的程序，一般就是『 - 』 SZ 使用掉的内存大小； WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作； TTY 登入者的终端机位置； TIME 使用掉的 CPU 时间。 CMD 所下达的指令名称 PRI=PRI + NICE 进程的执行优先权(Priority的简写)，其值越小越早被执行； nice 好，对别人友好，其实就是对自己残忍 nice值的范围从-20 ~ 19 A 20 + 10 = 30B 20 - 10 = 10 1[root@LNMP ~]# nice -n -10 python 123456[root@LNMP ~]# ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.5 0.3 128144 6676 ? Ss 16:07 0:03 /usr/lib/systemd/systemd --switched-root --systroot 2 0.0 0.0 0 0 ? S 16:07 0:00 [kthreadd]root 3 1.3 0.0 0 0 ? S 16:07 0:09 [ksoftirqd/0]root 4 0.3 0.0 0 0 ? S 16:07 0:02 [kworker/0:0] USER：该进程属于那个使用者账号。 PID ：该进程的进程ID号。 %CPU：该进程使用掉的 CPU 资源百分比； %MEM：该进程所占用的物理内存百分比； VSZ ：该进程使用掉的虚拟内存量 (Kbytes) 虚拟内存=真实内存 + swap分区 RSS ：该进程占用的固定的内存量 (Kbytes) 真实内存=物理内存 16G TTY ：该进程是在那个终端机上面运作，若与终端机无关，则显示 ?。另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。 ctrl+alt+F1~F6 —&gt;tty1到tty6 STAT：该程序目前的状态，主要的状态有： R ：该程序目前正在运作，或者是可被运作； running S ：该程序目前正在睡眠当中，但可被某些讯号(signal) 唤醒。 sleeping T ：该程序目前正在侦测或者是停止了； Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态 &lt; high-priority (not nice to other users) N low-priority (nice to other users) L has pages locked into memory (for real-time and custom IO) s is a session leader 下面有子进程 l is multi-threaded (using CLONE_THREAD, like NPTL pthreads do) is in the foreground process group 前端进程组 START：该进程被触发启动的时间； TIME ：该进程实际使用 CPU 运作的时间。 COMMAND：该程序的实际指令。 12345[root@LNMP ~]# ps aux|grep mysqldroot 85620 0.0 0.0 112728 1000 pts/3 R+ 16:49 0:00 grep --color=auto mysqld[root@LNMP ~]# ps aux|grep nginxroot 85634 0.0 0.0 112728 1000 pts/3 S+ 16:49 0:00 grep --color=auto nginx[root@LNMP ~]# ps aux|grep bash 查看内存的大小https://www.cnblogs.com/ultranms/p/9254160.html 123456789[root@LNMP ~]# free -m total used free shared buff/cache availableMem: 1819 209 352 8 1257 1315Swap: 2047 1 2046[root@LNMP ~]# free total used free shared buff/cache availableMem: 1863252 192808 380336 9096 1290108 1369768Swap: 2097148 1024 2096124[root@LNMP ~]# 有时我们需要持续的观察内存的状况，此时可以使用 -s 选项并指定间隔的秒数： -h 以人类能读懂的格式显示 hunan readable -s 间隔时间 123456789101112free -h -s 3 total used free shared buff/cache availableMem: 1.8G 316M 161M 9.3M 1.3G 1.3GSwap: 2.0G 264K 2.0G total used free shared buff/cache availableMem: 1.8G 316M 161M 9.3M 1.3G 1.3GSwap: 2.0G 264K 2.0G total used free shared buff/cache availableMem: 1.8G 316M 161M 9.3M 1.3G 1.3GSwap: 2.0G 264K 2.0G memory 内存 ：物理内存 –》速度快，性能好 swap 交换分区 ：从磁盘里拿出的空间 –》速度慢 当真实内存不足的时候，才会去使用swap分区 输出简介下面先解释一下输出的内容： Mem 行(第二行)是内存的使用情况。 Swap 行(第三行)是交换空间的使用情况。 total 列显示系统总的可用物理内存和交换空间大小。 used 列显示已经被使用的物理内存和交换空间。 free 列显示还有多少物理内存和交换空间可用使用。 shared 列显示被共享使用的物理内存大小。 buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。 available 列显示还可以被应用程序使用的物理内存大小。 我想只有在理解了一些基本概念之后，上面的输出才能帮助我们了解系统的内存状况。 buff/cache的区别 buffer 在操作系统中指 buffer cache， 中文一般翻译为 “缓冲区”。要理解缓冲区，必须明确另外两个概念：”扇区” 和 “块”。扇区是设备的最小寻址单元，也叫 “硬扇区” 或 “设备块”。块是操作系统中文件系统的最小寻址单元，也叫 “文件块” 或 “I/O 块”。每个块包含一个或多个扇区，但大小不能超过一个页面，所以一个页可以容纳一个或多个内存中的块。当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示，注意，buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件。 cache 在操作系统中指 page cache，中文一般翻译为 “页高速缓存”。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写。 页高速缓存对普通文件的缓存我们可以这样理解：当内核要读一个文件(比如 /etc/hosts)时，它会先检查这个文件的数据是不是已经在页高速缓存中了。如果在，就放弃访问磁盘，直接从内存中读取。这个行为称为缓存命中。如果数据不在缓存中，就是未命中缓存，此时内核就要调度块 I/O 操作从磁盘去读取数据。然后内核将读来的数据放入页高速缓存中。这种缓存的目标是文件系统可以识别的文件(比如 /etc/hosts)。 页高速缓存对块设备文件的缓存就是我们在前面介绍的 buffer/cahce。因为独立的磁盘块通过缓冲区也被存入了页高速缓存(缓冲区最终是由页高速缓存来承载的)。到这里我们应该搞清楚了：无论是缓冲区还是页高速缓存，它们的实现方式都是一样的。缓冲区只不过是一种概念上比较特殊的页高速缓存罢了。 那么为什么 free 命令不直接称为 cache 而非要写成 buff/cache？ 这是因为缓冲区和页高速缓存的实现并非天生就是统一的。在 linux 内核 2.4 中才将它们统一。更早的内核中有两个独立的磁盘缓存：页高速缓存和缓冲区高速缓存。前者缓存页面，后者缓存缓冲区。当你知道了这些故事之后，输出中列的名称可能已经不再重要了。 free 与 available在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以对于内核来说，buffer 和 cache 都属于已经被使用的内存。当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，available = free + buffer + cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。 交换空间(swap space)swap space 是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是 swap 分区也可以是 swap 文件。当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。 现在的机器一般都不太缺内存，如果系统默认还是使用了 swap 是不是会拖累系统的性能？理论上是的，但实际上可能性并不是很大。并且内核提供了一个叫做 swappiness 的参数，用于配置需要将内存中不常用的数据移到 swap 中去的紧迫程度。这个参数的取值范围是 0～100，0 告诉内核尽可能的不要将内存数据移到 swap 中，也即只有在迫不得已的情况下才这么做，而 100 告诉内核只要有可能，尽量的将内存中不常访问的数据移到 swap 中。在 ubuntu 系统中，swappiness 的默认值是 60。如果我们觉着内存充足，可以在 /etc/sysctl.conf 文件中设置 swappiness： vm.swappiness=10如果系统的内存不足，则需要根据物理内存的大小来设置交换空间的大小。具体的策略网上有很丰富的资料，这里笔者不再赘述。 /proc/meminfo 文件其实 free 命令中的信息都来自于 /proc/meminfo 文件。/proc/meminfo 文件包含了更多更原始的信息，只是看起来不太直观： 12345$ cat /proc/meminfo[root@LNMP ~]# cat /proc/sys/vm/swappiness 30[root@LNMP ~]# 总结free 命令是一个既简单又复杂的命令。简单是因为这个命令的参数少，输出结果清晰。说它复杂则是因为它背后是比较晦涩的操作系统中的概念，如果不清楚这些概念，即便看了 free 命令的输出也 get 不到多少有价值的信息。 12[root@LNMP ~]# cat /proc/sys/vm/swappiness 30 当物理内存剩余30%的时候，就开始使用swap分区 123[root@LNMP ~]# echo 0 &gt;/proc/sys/vm/swappiness #临时修改内核的参数[root@LNMP ~]# cat /proc/sys/vm/swappiness 0 如果我们觉着内存充足，可以在 /etc/sysctl.conf 文件中设置 swappiness： vm.swappiness=10 sysctl.conf —》往内核里传递参数的文件 12345678910111213[root@LNMP ~]# cat /etc/sysctl.conf 永久修改内核的参数# sysctl settings are defined through files in# /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/.## Vendors settings live in /usr/lib/sysctl.d/.# To override a whole file, create a new file with the same in# /etc/sysctl.d/ and put new settings there. To override# only specific settings, add a file with a lexically later# name in /etc/sysctl.d/ and put new settings there.## For more information, see sysctl.conf(5) and sysctl.d(5).fs.file-max=65535 --》内核允许一个进程可以打开的文件数量vm.swappiness=0 --》什么时候开始使用swap分区，当物理内存使用完的时候，开始使用 123[root@LNMP ~]# sysctl -p # 刷新内核里的参数fs.file-max = 65535vm.swappiness = 0 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@LNMP ~]# cat /proc/meminfo #查询内核里的内存的信息MemTotal: 1863252 kBMemFree: 71184 kBMemAvailable: 20724 kBBuffers: 0 kBCached: 22272 kBSwapCached: 274532 kBActive: 1197068 kBInactive: 447492 kBActive(anon): 1187036 kBInactive(anon): 435344 kBActive(file): 10032 kBInactive(file): 12148 kBUnevictable: 0 kBMlocked: 0 kBSwapTotal: 2097148 kBSwapFree: 715772 kBDirty: 16 kBWriteback: 0 kBAnonPages: 1433672 kBMapped: 5048 kBShmem: 8 kBSlab: 72324 kBSReclaimable: 26452 kBSUnreclaim: 45872 kBKernelStack: 4416 kBPageTables: 12580 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 3028772 kBCommitted_AS: 3017064 kBVmallocTotal: 34359738367 kBVmallocUsed: 182368 kBVmallocChunk: 34359310332 kBHardwareCorrupted: 0 kBAnonHugePages: 2048 kBCmaTotal: 0 kBCmaFree: 0 kBHugePages_Total: 0HugePages_Free: 0HugePages_Rsvd: 0HugePages_Surp: 0Hugepagesize: 2048 kBDirectMap4k: 89984 kBDirectMap2M: 2007040 kB 动态显示系统资源（cpu、内存、进程）https://www.cnblogs.com/sunshuhai/p/6250514.html 简介top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。 top显示系统当前的进程和其他状况,是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止. 比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定. #### 参数含义123456789101112top - 01:06:48 up 1:22, 1 user, load average: 0.06, 0.60, 0.48Tasks: 29 total, 1 running, 28 sleeping, 0 stopped, 0 zombieCpu(s): 0.3% us, 1.0% sy, 0.0% ni, 98.7% id, 0.0% wa, 0.0% hi, 0.0% siMem: 191272k total, 173656k used, 17616k free, 22052k buffersSwap: 192772k total, 0k used, 192772k free, 123988k cachedPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND1379 root 16 0 7976 2456 1980 S 0.7 1.3 0:11.03 sshd14704 root 16 0 2128 980 796 R 0.7 0.5 0:02.72 top1 root 16 0 1992 632 544 S 0.0 0.3 0:00.90 init2 root 34 19 0 0 0 S 0.0 0.0 0:00.00 ksoftirqd/03 root RT 0 0 0 0 S 0.0 0.0 0:00.00 watchdog/0 统计信息区前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下： 01:06:48 当前时间 up 1:22 系统运行时间，格式为时:分 1 user 当前登录用户数 load average: 0.06, 0.60, 0.48:系统（就绪队列）负载，即任务队列的平均长度，其实就是排队的进程数量。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。1s=10**9ns cpu里的运行速度 纳秒 –&gt;频率 0.5纳秒内存里的速度 接近纳秒 –&gt;频率 1纳秒 上下文切换 –》10ms –》差一亿倍 当平均值为1的时候，说明cpu已经饱和了当到达5的时候，说明cpu非常忙碌了 1个核心的参考标准 1 饱和了 5 很忙了4个核心 4208个核心 840 第二、三行为进程和CPU的信息。当有多个CPU时，这些内容可能会超过两行。内容如下： Tasks: total 进程总数 running 正在运行的进程数 sleeping 睡眠的进程数 stopped 停止的进程数 zombie 僵尸进程数 Cpu(s): 0.3% us 用户空间占用CPU百分比user 1.0% sy 内核空间占用CPU百分比system 0.0% ni 用户进程空间内改变过优先级的进程占用CPU百分比 nice 98.7% id 空闲CPU百分比 idle 0.0% wa 等待输入输出的CPU时间百分比 0.0%hi：硬件CPU中断占用百分比 0.0%si：软中断占用百分比 0.0%st：虚拟机占用百分比 按数字1 可以查看某个cpu核心的使用情况 最后两行为内存信息。内容如下： Mem: 191272k total 物理内存总量 173656k used 使用的物理内存总量 17616k free 空闲内存总量 22052k buffers 用作内核缓存的内存量 Swap: 192772k total 交换区总量 0k used 使用的交换区总量 192772k free 空闲交换区总量 123988k cached 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。 怎么看内存有多少空闲呢？totalfree = free17616 + buffers22052 + cached123988 进程信息区统计信息区域的下方显示了各个进程的详细信息。首先来认识一下各列的含义。序号 列名 含义a PID 进程idb PPID 父进程idc RUSER Real user named UID 进程所有者的用户ide USER 进程所有者的用户名f GROUP 进程所有者的组名g TTY 启动进程的终端名。不是从终端启动的进程则显示为 ?h PR 优先级i NI nice值。负值表示高优先级，正值表示低优先级j P 最后使用的CPU仅在多CPU环境下有意义k %CPU 上次更新到现在的CPU时间占用百分比l TIME 进程使用的CPU时间总计，单位秒m TIME+ 进程使用的CPU时间总计，单位1/100秒n %MEM 进程使用的物理内存百分比o VIRT 进程使用的虚拟内存总量单位kb。VIRT=SWAP+RESp SWAP 进程使用的虚拟内存中，被换出的大小，单位kb。q RES 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATAr CODE 可执行代码占用的物理内存大小，单位kbs DATA 可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kbt SHR 共享内存大小，单位kbu nFLT 页面错误次数v nDRT 最后一次写入到现在，被修改过的页面数。w S 进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)x COMMAND 命令名/命令行y WCHAN 若该进程在睡眠，则显示睡眠中的系统函数名z Flags 任务标志，参考 sched.h 默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。可以通过下面的快捷键来更改显示内容。 更改显示内容通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。 命令使用ps aux的使用 lsof的使用lsof -i:80监控80端口的应用程序 lsof -p 29298监控29298(PID)的状况 top使用格式top [-] [d] [p] [q] [c] [C] [S] [s] [n] 参数说明 d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 p 通过指定监控进程ID来仅仅监控某个进程的状态。 q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 S 指定累计模式 s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 i 使top不显示任何闲置或者僵死进程。 c 显示整个命令行而不只是显示命令名 其他实用命令下面介绍在top命令执行过程中可以使用的一些交互命令。从使用角度来看，熟练的掌握这些命令比掌握选项还重要一些。这些命令都是单字母的，如果在命令行选项中使用了s选项，则可能其中一些命令会被屏蔽掉。 Ctrl+L 擦除并且重写屏幕。 h或者? 显示帮助画面，给出一些简短的命令总结说明。 k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。 i 忽略闲置和僵死进程。这是一个开关式命令。 q 退出程序。 r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。 S 切换到累计模式。 s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。 f或者F 从当前显示中添加或者删除项目。 o或者O 改变显示项目的顺序。 l 切换显示平均负载和启动时间信息。 m 切换显示内存信息。 t 切换显示进程和CPU状态信息。 c 切换显示命令名称和完整命令行。 M 根据驻留内存大小进行排序。 –&gt;推荐使用 P 根据CPU使用百分比大小进行排序。 —》默认 T 根据时间/累计时间进行排序。 W 将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。 h 可以查看top里可以输入哪些字符 &lt; 和 &gt; 移动排序的列 往左 往右 附常用操作: top //每隔5秒显式所有进程的资源占用情况 top -d 2//每隔2秒显式所有进程的资源占用情况 top -c //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名) top -p 12345 -p 6789 //每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况 top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数 123456789101112131415161718192021222324[root@sanchuang ~]# top -n 1 让top命令刷新1次就退出top - 10:49:42 up 46 min, 3 users, load average: 0.00, 0.01, 0.05Tasks: 123 total, 1 running, 122 sleeping, 0 stopped, 0 zombie%Cpu(s): 0.0 us, 3.1 sy, 0.0 ni, 96.9 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 stKiB Mem : 1863252 total, 1158592 free, 445940 used, 258720 buff/cacheKiB Swap: 2097148 total, 2097148 free, 0 used. 1236384 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 6299 root 20 0 301040 6484 5112 S 6.2 0.3 0:05.66 vmtoolsd 17147 root 20 0 162020 2188 1576 R 6.2 0.1 0:00.01 top 1 root 20 0 125336 3784 2560 S 0.0 0.2 0:02.10 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.02 kthreadd 3 root 20 0 0 0 0 S 0.0 0.0 0:00.53 ksoftirqd/0 5 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 kworker/0:0H 6 root 20 0 0 0 0 S 0.0 0.0 0:00.05 kworker/u256:0 7 root rt 0 0 0 0 S 0.0 0.0 0:00.07 migration/0 8 root 20 0 0 0 0 S 0.0 0.0 0:00.00 rcu_bh 9 root 20 0 0 0 0 S 0.0 0.0 0:05.84 rcu_sched 10 root 0 -20 0 0 0 S 0.0 0.0 0:00.00 lru-add-drain 11 root rt 0 0 0 0 S 0.0 0.0 0:00.15 watchdog/0 12 root rt 0 0 0 0 S 0.0 0.0 0:00.25 watchdog/1 13 root rt 0 0 0 0 S 0.0 0.0 0:00.06 migration/1 [root@sanchuang ~]# 查看CPU的信息 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@sanchuang ~]# cat /proc/cpuinfo processor : 0vendor_id : GenuineIntelcpu family : 6model : 42model name : Intel(R) Core(TM) i3-2100 CPU @ 3.10GHzstepping : 7microcode : 0x25cpu MHz : 3093.039cache size : 3072 KBphysical id : 0siblings : 2core id : 0cpu cores : 2apicid : 0initial apicid : 0fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc eagerfpu pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer xsave avx hypervisor lahf_lm tsc_adjust aratbogomips : 6186.07clflush size : 64cache_alignment : 64address sizes : 43 bits physical, 48 bits virtualpower management:processor : 1vendor_id : GenuineIntelcpu family : 6model : 42model name : Intel(R) Core(TM) i3-2100 CPU @ 3.10GHzstepping : 7microcode : 0x25cpu MHz : 3093.039cache size : 3072 KBphysical id : 0siblings : 2core id : 1cpu cores : 2apicid : 1initial apicid : 1fpu : yesfpu_exception : yescpuid level : 13wp : yesflags : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx rdtscp lm constant_tsc arch_perfmon nopl xtopology tsc_reliable nonstop_tsc eagerfpu pni pclmulqdq ssse3 cx16 pcid sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer xsave avx hypervisor lahf_lm tsc_adjust aratbogomips : 6186.07clflush size : 64cache_alignment : 64address sizes : 43 bits physical, 48 bits virtualpower management: dstat的基本使用：1[root@sanchuang yum.repos.d]# yum install dstat -y dstat的默认选项与许多命令一样，dstat命令有默认选项，执行dstat命令不加任何参数，它默认会收集-cpu-、-disk-、-net-、－paging-、-system-的数据，一秒钟收集一次。 默认输入 dstat 等于输入了dstat -cdngy 1或dstat -a 1。 dstat的常用选项：dstat的用法如下： dstat [-afv] [options..] [delay [count]] 使用 dstat -h查看全部选项，这里不逐一列举，下面简单介绍下常用选项 常用选项如下： 直接跟数字，表示#秒收集一次数据，默认为一秒；dstat 5表示5秒更新一次 -c,–cpu 统计CPU状态，包括 user, system, idle（空闲等待时间百分比）, wait（等待磁盘IO）, hardware interrupt（硬件中断）, software interrupt（软件中断）等； -d, –disk 统计磁盘读写状态 -D total,sda 统计指定磁盘或汇总信息 -l, –load 统计系统负载情况，包括1分钟、5分钟、15分钟平均值 -m, –mem 统计系统物理内存使用情况，包括used, buffers, cache, free -s, –swap 统计swap已使用和剩余量 -n, –net 统计网络使用情况，包括接收和发送数据 -N eth1,total 统计eth1接口汇总流量 -r, –io 统计I/O请求，包括读写请求 -p, –proc 统计进程信息，包括runnable、uninterruptible、new -y, –sys 统计系统信息，包括中断、上下文切换 -t 显示统计时时间，对分析历史数据非常有用 –fs 统计文件打开数和inodes数 以上这些就是最常用的选项，而一般都组合使用，个人比较常用的是： 找出占用资源最高的进程和用户123dstat -cmsdnl -D sda9 -N lo,etho 100 5[root@sanchuang yum.repos.d]# dstat -ma[root@sanchuang yum.repos.d]# dstat -N ens33,lo，ens37 #查看多块网卡的流量 找出占用资源最高的进程和用户–top-(io|bio|cpu|cputime|cputime-avg|mem) 通过这几个选项，可以看到具体是那个用户那个进程占用了相关系统资源，对系统调优非常有效。如查看当前占用I/O、cpu、内存等最高的进程信息可以使用dstat –top-mem –top-io –top-cpu： 1234567891011[root@sanchuang yum.repos.d]# dstat --top-cpu-most-expensive- cpu process mysqld 0.2mysqld 0.5top 0.5ksoftirqd/1 0.5mysqld 0.5[root@sanchuang yum.repos.d]# dstat --top-mem [root@sanchuang yum.repos.d]# dstat --top-io netstat的使用1yum install net-tools -y 查看所有端口的应用程序1234567891011121314151617181920212223242526272829303132[root@sanchuang yum.repos.d]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 7294/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6650/sshd tcp 0 0 192.168.1.126:22 192.168.1.180:50502 ESTABLISHED 17068/sshd: root@pt tcp 0 0 192.168.1.126:33672 103.130.59.22:80 TIME_WAIT - tcp 0 0 192.168.1.126:53544 150.65.7.130:80 TIME_WAIT - tcp 0 0 192.168.1.126:48634 101.6.8.193:80 TIME_WAIT - tcp 0 0 192.168.1.126:60076 202.90.159.172:443 TIME_WAIT - tcp 0 36 192.168.1.126:22 192.168.1.180:49523 ESTABLISHED 13663/sshd: root@pt tcp 0 0 192.168.1.126:45740 103.212.36.188:80 TIME_WAIT - tcp 0 0 192.168.1.126:51692 134.160.38.1:80 TIME_WAIT - tcp 0 0 192.168.1.126:51648 195.210.46.141:443 TIME_WAIT - tcp 0 0 192.168.1.126:53704 118.174.8.44:80 TIME_WAIT - tcp 0 0 192.168.1.126:58318 103.48.119.119:80 TIME_WAIT - tcp 0 0 192.168.1.126:43960 212.8.231.33:80 TIME_WAIT - tcp 0 0 192.168.1.126:42572 194.146.42.42:443 TIME_WAIT - tcp 0 0 192.168.1.126:59628 133.24.248.19:443 TIME_WAIT - tcp 0 0 192.168.1.126:45132 210.71.189.53:80 TIME_WAIT - tcp 0 0 192.168.1.126:53746 103.63.213.228:80 TIME_WAIT - tcp 0 0 192.168.1.126:44186 158.108.8.148:80 TIME_WAIT - tcp 0 0 192.168.1.126:44582 103.77.111.8:80 TIME_WAIT - tcp 0 0 192.168.1.126:48516 109.205.113.85:80 TIME_WAIT - tcp 0 0 192.168.1.126:43982 212.8.231.33:80 TIME_WAIT - tcp 0 0 192.168.1.126:60184 140.113.17.5:80 TIME_WAIT - tcp6 0 0 :::3306 :::* LISTEN 7328/mysqld tcp6 0 0 :::22 :::* LISTEN 6650/sshd udp 0 0 0.0.0.0:68 0.0.0.0:* 6404/dhclient udp 0 0 127.0.0.1:323 0.0.0.0:* 6316/chronyd udp6 0 0 ::1:323 :::* 6316/chronyd [root@sanchuang yum.repos.d]# netstat -anplut[–tcp|-t] tcp方式 [–udp|-u] udp方式 [–listening|-l] 监听的状态 [–all|-a] 所有的 [–numeric|-n] 以数字显示 [–program|-p] 程序名字 ESTABLISHED 表示已经建立连接，对方已经进入你的机器 LISTEN 表示某个端口处于打开–》监听–》等着别人来访问 iptraf的使用12[root@sanchuang yum.repos.d]# yum install iptraf[root@sanchuang yum.repos.d]# iptraf-ng iptraf可以实时地监视网卡流量，可以生成各种网络统计数据，包括TCP信息、UDP统计、ICMP和OSPF信息、以太网负载信息、节点统计、IP校验和错误和其它一些信息。 sysstat的使用磁盘IO：就是对磁盘进行读写 input output 1[root@sanchuang ~]# yum install sysstat -y iostat用于输出CPU和磁盘I/O相关的统计信息 iostat语法用法：iostat [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ]] 常用选项说明： -c：只显示系统CPU统计信息，即单独输出avg-cpu结果，不包括device结果 -d：单独输出Device结果，不包括cpu结果 -k/-m：输出结果以kB/mB为单位，而不是以扇区数为单位 -x:输出更详细的io设备统计信息 interval/count：每次输出间隔时间，count表示输出次数，不带count表示循环输出 说明：更多选项使用使用man iostat查看 常用实例iostat:结果为从系统开机到当前执行时刻的统计信息 输出含义： avg-cpu: 总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值。重点关注iowait值，表示CPU用于等待io请求的完成时间。 Device: 各磁盘设备的IO统计信息。各列含义如下： Device: 以sdX形式显示的设备名称 tps: 每秒进程下发的IO读、写请求数量 —-》每秒读写的次数 transfer per second KB_read/s: 每秒从驱动器读入的数据量，单位为K。 KB_wrtn/s: 每秒从驱动器写入的数据量，单位为K。 KB_read: 读入数据总量，单位为K。 KB_wrtn: 写入数据总量，单位为K。 IOPS（Input/Output Operations Per Second）是一个用于计算机存储设备（如硬盘（HDD）、固态硬盘（SSD）或存储区域网络（SAN））性能测试的量测方式，可以视为是每秒的读写次数。 iostat -x -k -d 1 2: 每隔1S输出磁盘IO的详细详细，总共采样2次。 以上各列的含义如下：rrqm/s: 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并wrqm/s: 每秒对该设备的写请求被合并次数r/s: 每秒完成的读次数w/s: 每秒完成的写次数rkB/s: 每秒读数据量(kB为单位)wkB/s: 每秒写数据量(kB为单位)avgrq-sz:平均每次IO操作的数据量(扇区数为单位)avgqu-sz: 平均等待处理的IO请求队列长度 queueawait: 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)svctm: 平均每次IO请求的处理时间(毫秒为单位) service time%util: 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率 重点关注参数1、iowait% 表示CPU等待IO时间占整个CPU周期的百分比，如果iowait值超过50%，或者明显大于%system、%user以及%idle，表示IO可能存在问题。 2、avgqu-sz 表示磁盘IO队列长度，即IO等待个数。 3、await 表示每次IO请求等待时间，包括等待时间和处理时间 4、svctm 表示每次IO请求处理的时间 5、%util 表示磁盘忙碌情况，一般该值超过80%表示该磁盘可能处于繁忙状态。 繁忙度—》最重要参数 dm-0/1/2是什么？怎么来的？dm-0、dm-1、dm-2的主设备号是253（是linux内核留给本地使用的设备号），次设备号分别是0、1、2，这类设备在/dev/mapper中 看到dm-0、dm-1、dm-2的详细设备名后，知道这三个设备是属于centos逻辑卷组的lvm设备。 htop的使用1[root@sanchuang ~]# yum install htop -y htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)，需要ncurses。 与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。 与top相比，htop有以下优点： 可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。 在启动上，比top 更快。 杀进程时不需要输入进程号。 htop 支持鼠标操作。 top 已经很老了。 htop 官网 下面左上角显示CPU、内存、交换区的使用情况，右边显示任务、负载、开机时间，下面就是进程实时状况。 下面是 F1~F10 的功能和对应的字母快捷键。 Shortcut Key Function Key Description 中文说明 h, ? F1 Invoke htop Help 查看htop使用说明 S F2 Htop Setup Menu htop 设定 / F3 Search for a Process 搜索进程 \ F4 Incremental process filtering 增量进程过滤器 t F5 Tree View 显示树形结构 &lt;, &gt; F6 Sort by a column 选择排序方式 [ F7 Nice - (change priority) 可减少nice值，这样就可以提高对应进程的优先级 ] F8 Nice + (change priority) 可增加nice值，这样就可以降低对应进程的优先级 k F9 Kill a Process 可对进程传递信号 q F10 Quit htop 结束htop 命令行选项（COMMAND-LINE OPTIONS）-C –no-color 使用一个单色的配色方案 -d –delay=DELAY 设置延迟更新时间，单位秒 -h –help 显示htop 命令帮助信息 -u –user=USERNAME 只显示一个给定的用户的过程 -p –pid=PID,PID… 只显示给定的PIDs -s –sort-key COLUMN 依此列来排序 -v –version 显示版本信息 详解]]></content>
      <categories>
        <category>linux高级</category>
      </categories>
      <tags>
        <tag>笔试题</tag>
        <tag>top</tag>
        <tag>dstat</tag>
        <tag>netstat</tag>
        <tag>sysstat</tag>
        <tag>htop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2019%2F08%2F26%2Fmysql%2F%E5%AD%A6%E4%B9%A0mysql%E7%9A%84%E5%AD%97%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[查看MySQL的版本方法1： 1234567root@mysql 09:55 mysql&gt;show variables like 'version' ;+---------------+--------+| Variable_name | Value |+---------------+--------+| version | 5.7.25 |+---------------+--------+1 row in set (0.01 sec) 方法2： 12345678910111213[root@mysql-2 ~]# mysql -uroot -p'Sanchuang1234#' -S /data/mysql/mysql.sockmysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 9Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. 方法3： 1234567root@(none) 09:57 mysql&gt;select version();+-----------+| version() |+-----------+| 5.7.25 |+-----------+1 row in set (0.00 sec)** 查看当前你在哪个库里1234567root@lizengzhi 09:58 mysql&gt;select database();+------------+| database() |+------------+| lizengzhi |+------------+1 row in set (0.00 sec) 查询表里的数据SELECT * FROM USER select 是查询的命令 —-命令不区分大小写，都可以* 表示显示所有的字段 —- 字段名也不区分大小写，都可以from user 表示要查询user表 —-表的名字区分大小写 12345678910111213root@mysql 10:16 mysql&gt;use mysql #切换到mysql库中Database changedroot@mysql 10:14 mysql&gt;select host,user from user; #查询表里的数据+-----------+---------------+| host | user |+-----------+---------------+| % | cali || % | root || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+---------------+5 rows in set (0.00 sec) 下面的语句与上面的语句是一样的效果 12345678910111213root@mysql 10:17 mysql&gt;SELECT HOST,USER from user;+-----------+---------------+| HOST | USER |+-----------+---------------+| % | cali || % | root || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+---------------+5 rows in set (0.00 sec)root@mysql 10:18 mysql&gt; 在SQLyog创建库，然后创建表，然后再插入数据字符集： 字符(Character)是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，就需要进行字符编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英语单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。 常见字符集名称： ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等 ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言常见的简体中文编码：GB2312字符集 GB18030字符集繁体中文：BIG5字符集Unicode字符集：万国码 utf8 utf16 排序规则：排序的时候谁在前，谁在后的问题。谁大谁小。 字符集： 数据库的字符集—》表的字符集—》字段里的字符集 使用字符的时候，会继承数据的字符集Utf8类型的字符集就包括了全球所有国家的字符—-》万国码Utf8字符集—-》主要是用来表示字符，解决乱码问题 12345678910111213141516171819202122root@mysql 10:18 mysql&gt;use zengqileiReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedroot@zengqilei 11:02 mysql&gt;show tables; 查看有哪些表+---------------------+| Tables_in_zengqilei |+---------------------+| student |+---------------------+1 row in set (0.00 sec)root@zengqilei 11:02 mysql&gt;select * from student;+--------+-----------+--------+| 编号 | 姓名 | 性别 |+--------+-----------+--------+| 1 | 裴家润 | 男 || 2 | 李增志 | 男 || 3 | 李冰冰 | 女 || 4 | 彭龙 | 男 |+--------+-----------+--------+4 rows in set (0.00 sec) 数据库和前端网页有什么关系？ 数据库里的表的信息也是记录到文件里的专门存放数据的目录下 /data/mysql目录下，而且数据库的名字和文件夹同名,表的名字和文件名同名 123456[root@mysql-2 zengqilei]# pwd/data/mysql/zengqilei[root@mysql-2 zengqilei]#[root@mysql-2 zengqilei]# lsdb.opt student.frm student.ibd[root@mysql-2 zengqilei]# pymysql 是python里专门连接mysql的工具（模块） 数据库的重要性： 用户《—》web《—》db 做网站–》pythonweb服务器 –》linux数据库–》mysql 建表里的数据类型： data types MySQL支持多种类型的SQL四大数据类型：数值类型，日期和时间类型，字符串（字符和字节）类型，空间类型和 JSON数据类型。 官方的文档（比较全面+比较详细）+菜鸟教程（内容不新，比较适合初学者） 数值类型： 整型、 因为在设计表的时候，需要考虑你存放什么数据？不同的数据适合有不同的数据类型 text比char和varchar存储的字符串要多 一个汉字占多少长度与编码有关： UTF-8:一个汉字=3个字节 GRK:一个汉字=2个字节 varchar(n)表示n个字符，无论汉字和英文，MySQL都能存入 数值类型： bit ：只能存放二进制数值 该BIT数据类型被用于存储比特值。一种 能够存储位值的类型。 范围从1到64 tinyint 1 0-255 -128~127 smallint 2 MEDIUMINT 3 int 4 bigint 8 、float int整型 ：100 30977 float浮点型：有小数点的数字 456.78 123.1 4个字节 DOUBLE 8个字节 数值：大的数字和小的数字 DECIMAL 定点型 布尔类型： ‘true’, ‘false BOOL， BOOLEAN CHAR 0-255字节 定长字符串 VARCHAR 0-65535 字节 变长字符串 variable character varchar更加节约存储空间，根据实际上有的字符来存放。而char是按照固定的长度来存放的，不管你是否使用，都按照固定的长度来存放。 定点型：DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL] 打包的“ 精确 ”定点数。 M是总位数（精度），D是小数点后的位数（刻度） 123456789101112131415161718192021222324root@TENNIS 16:48 mysql&gt;use penglongDatabase changedroot@penglong 16:48 mysql&gt;show tables;Empty set (0.00 sec)root@penglong 16:48 mysql&gt;create table T1(id int ,salary dec(6,2),name varchar(10));Query OK, 0 rows affected (0.04 sec)root@penglong 16:56 mysql&gt;insert into T1(id,salary,name) values (6,123.4,"penglong2");Query OK, 1 row affected (0.00 sec)root@penglong 16:57 mysql&gt;select * from T1;+------+---------+-----------+| id | salary | name |+------+---------+-----------+| 1 | 1234.26 | penglong || 1 | 123.40 | penglong2 || 2 | 123.45 | penglong3 || 3 | 123.46 | penglong3 || 6 | 123.40 | penglong2 |+------+---------+-----------+5 rows in set (0.00 sec)root@penglong 16:57 mysql&gt; dec(9,3) –&gt;总长度为9位，小数占3位。19789.23 DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]FLOAT[(M,D)] [UNSIGNED] [ZEROFILL] M是总位数（精度），D是小数点后的位数（刻度） 电脑里存放内容有大小一个英文字母一般占用1个字节一个汉字占用2-3个字节。 一个表里的字段到底选用什么样的数据类型，需要考虑实际的应用，尽量不要浪费，考虑服务器的负载（cpu和内存使用），考虑未来业务的扩展。 长度：其实就是字符的个数]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>字段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMP]]></title>
    <url>%2F2019%2F08%2F17%2Flinux%2FLNMP%2F</url>
    <content type="text"><![CDATA[LNMP/LAMP实验LNMP:linux+nginx+MySQL+php/python/perl LAMP:linux+apache(httpd)+MySQL(mariadb)+php/python/perl SQLite数据库，是一个轻量级数据库，只是在本机使用。不能多机联合读写数据 MySQL(mariadb):小型数据库 zabbix的搭建：部署的环境：LAMP LAMP:linux free -m监控 yum 安装LAMPgrant ALL on . to “sc”@”%” identifiled by “Sctl@1234” lnmp.org一键安装包（别人的） 错误总结校招nginx的配置参数]]></content>
      <categories>
        <category>linux高阶</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django项目部署到linux服务器上的注意事项]]></title>
    <url>%2F2019%2F08%2F16%2Fweb%E5%BC%80%E5%8F%91%2Fdjango%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Django项目部署1. 常见的部署方式 nginx+uwsgi：配置要求严格，效率高 nginx+gunicorn：部署极其方便,gunicorn可以同时起多个pythondjango进程，提高多进程服务，提高并发处理能力。gunicorn将django包装成一个服务启动，进行管理。(supervisor监控gunicorn,一旦gunicorn进程停止服务，马上重新启动进程) WSGI 处理动态请求（uwsgi, gunicorn） Nginx 处理静态资源 ==&gt; （/static/, /uploads/） 2.Django分布式架构 Nginx ： 提供服务，并处理静态请求 Server1..N： 处理动态请求 DB： 处理数据库相关 静态文件： 存储挂载/加Rewrite（用于放静态文件的位置） 3. 代码准备 区分环境配置： 弄好requirement.txt pip freeze &gt; requirement.txt dev:开发环境，test:测试环境，prod：生产环境 安装包 数据库 是否开启Debug 区分环境 env.ini 12 # 写文件env.inienv.ini不放到版本库中 系统环境变量 123 # 在Linux命令行执行或者在setting.py文件声明一下 # export ENV="prod" 根据环境写配置 直接在settings.py中修改 12345678910111213141516import osenv = os.environ.get('ENV', None)if env == 'prod': DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db_prod.sqlite3'), &#125; &#125;else: DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125; &#125; ​ 2. 写settings_prod.py 、settings_test.py 1from .settings_prod import * 收集静态文件： Admin后台 =&gt; 静态文件/static/ =&gt; 出错 settings.py配置STATIC_ROOT 1STATIC_ROOT = os.path.join(BASE_DIR, "allstatic") 收集变化： 1python manage.py collectstatics 上传代码到git - 创建git项目：gitee.com - 在仓库中进行版本的管理 - git clone -&gt; 把代码copy到仓库 -&gt; git add .-&gt; git commit -&gt; git push -&gt; gitee.com 上传代码到git 创建git项目：gitee.com 在仓库中进行版本的管理 git clone -&gt; 把代码copy到仓库 -&gt; git add .-&gt; git commit -&gt; git push -&gt; gitee.com 4. 部署流程 所有和python相关的命令使用普通用户 useradd webadmin新建普通用户 a. Server 环境部署 代码克隆 123456yum install git -y# 第一次git clone xxx(你的仓库地址)# 更新cd 仓库git pull 安装系统依赖包及项目依赖包 123456789101112131415161718# python36安装yum install epel-release -yyum install python36 -ypython36 -m ensurepip# 创建虚拟环境pip3 install pipenv# 切换到项目目录（在有pipfile的目录下，执行）pipenv install # 会根据pipfile创建一个虚拟环境，并安装好所有的依赖# 注意pipfile.lock的问题 =&gt; 可删除掉lock文件# pipenv安装包时，lock的时间可能会比较长# 如果使用了mysql需要安装mysql相关yum install python-devel, mysql-python,等# 如果pipenv install 失败，可直接进虚拟环境，用requirements.txt安装pipenv shellpip install -r requirements.txt 另一种创建虚拟环境的方法 python36 -m venv venv(虚拟环境名字) 安装Gunicorn gunicorn项目：https://github.com/benoitc/gunicorn 12pipenv install gunicorn#pip install gunicorn -i https://pypi.douban.com/simple/#临时配置国内源 在虚拟环境中安装依赖 12pip install -r requirements.txt -i https://pypi.douban.com/simple/#安装依赖 gunicorn运行 12345gunicorn projname.wsgi:application -b 127.0.0.1:8080gunicorn projname.wsgi -w 4 -b 127.0.0.1:8080 -D --access-logfile=./log/gunicorn_access.log -u webadmin -g webadmin# w =&gt; worker =&gt; 进程# b =&gt; bind =&gt; 监听（确保nginx服务器能连接上就行）# 权限 =&gt; 最小化原则, iptables 开启你需要的，默认规则Drop 只能处理动态的请求（样式丢失的） 编写脚本run.sh 服务部署脚本：安装python,安装环境 停启服务脚本： service nginx stop =&gt; 写脚本 12345#!/bin/bashsource ~/mycode_env/bin/activateexport BLOG_ENV="prod"cd ~/mycodegunicorn projname.wsgi -w 4 -b 127.0.0.1:8080 -D --access-logfile=./log/gunicorn_access.log b. Nginx配置 Nginx的操作用Root用户 下载安装Nginx 1yum install nginx -y 配置文件及日期文件 配置文件：/etc/nginx/nginx.conf和/etc/nginx/conf.d/default.conf 日志文件：/var/log/nginx/error.log 和 /var/log/nginx/access.log 配置Nginx：/etc/nginx/nginx.conf 12345678910111213141516171819202122232425262728293031server &#123; listen 80; server_name sc.com; root /home/webadmin/question_repo; location ~/static &#123; root /home/webadmin/question_repo; expires 1d; &#125; location ~/allstatic/media &#123; root /home/webadmin/question_repo; expires 1d; &#125; location / &#123; # 设置头信息（以便gunicorn能看到真实的访问服务的客户端地址） proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header X-Forwarded-Host $server_name; proxy_set_header X-Real-IP $remote_addr; proxy_pass http://127.0.0.1:8080; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 检查配置文件是否正确： 1nginx -t 启动服务 1service nginx start 检查服务是否启动 123456789ps aux | grep nginxlsof -i:80netstat -tulnp# 安装工具包yum whatprovides *killall/usr/bin/kill =&gt; 包名yum install 包名killall gunicorn 5. 常见问题 安装速度慢 修改pip源 环境依赖 123456Python：pip install -r requirement/comm.txtDjango==1.11.6django-markdownx==2.0.21markdown2==2.3.4mysqlclient==1.3.12Sys: yum install Mysql-devel, MySQL-python, python-devel DB授权 监听地址 Settings Py2编码问题 Admin样式问题 权限问题 解决办法：没有权限，chmod 777 webadmin 注意登录页面的验证码会加载不出来，是由于Linux上没有字体的原因导致解决办法：下载字体文件，拷贝到allstatic/fonts/和 static/fonts目录下 6.解决问题的思路解决问题的思路： gunicorn服务不能正常启动 先用python manage.py runserver启动，看是否有错误，根据错误提示对应处理 nginx不能正常启动 检查配置 出错了的话，检查日志 /var/log/nginx/error]]></content>
      <categories>
        <category>django</category>
        <category>error</category>
      </categories>
      <tags>
        <tag>部署服务器</tag>
        <tag>error总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防火墙]]></title>
    <url>%2F2019%2F08%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E9%98%B2%E7%81%AB%E5%A2%99%2F</url>
    <content type="text"><![CDATA[防火墙 centos 7里默认的防火墙软件:firewall centos 6里默认的防火墙软件:iptables 可以通过cat /etc/redhat-release 12cat /etc/redhat-releaseCentOS Linux release 7.5.1804 (Core) firewall和iptables的关系？firewall有区域（zone） DMZ:隔离区 面试题 iptables有几个表几个链？ 如何阻止192.168.0.23这个ip访问我的80端口？ 如何阻止192.168.0.23这个ip访问我的3306端口？ 如何禁止所有电脑ping我的ip? 如何使在命令行执行iptables规则永久生效？ 停止firewall服务1service firewalld stop iptables iptables是一个防火墙软件 防火墙(firewall)：防止别人攻击你的电脑，对进去的网络接口的数据进行管控 杀毒软件：查找你电脑上的异常的程序，这些程序会破坏你的电脑的使用，窃取你的机密信息 查看iptables的信息iptables -L 清除iptables的信息iptables -F 五条链 PREROUTING:路由之前 是根据ip包里的目的ip地址 POSTROUTING:路由之后 INPUT:进来 OUTPUT:出去 FORWARD:转发 限制条件： 源ip:-s:--source address 目的ip:]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>iptables</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAT]]></title>
    <url>%2F2019%2F08%2F09%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FNAT%2F</url>
    <content type="text"><![CDATA[NAT、SNAT、DNAT NAT：Network Address Translation（网络地址转换） 数据转发过程中mac地址和ip地址的变化过程 SNAT：Source Network Address Translation（源地址转换） 修改数据包的源IP地址 DNAT：Destinatvion Network Address Translation（目标地址转换） 修改数据包的目标IP地址 SNAT SNAT策略的典型应用环境： ​ 局域网主机共享单个公网IP地址接入Internet SNAT策略的应用： 前提条件 局域网各主机正确设置IP地址/子网掩码 局域网各主机正确设置默认网关地址 推荐实现步骤 开启网关主机的路由转发功能 添加使用SNAT策略的防火墙规则 规则示例： 123456iptables-t nat-A POSTROUTING -o eth0 -s 192.168.1.0/24 -j SNAT--to-source 218.29.30.31iptables -t nat -A POSTROUTING 在nat表的POSTROUTING链上添加规则-o eth0 指定数据出去的接口 output-s 192.168.1.0/24 指定来自特定网段（192.168.1.0/24）的数据包 source-j SNAT 采取的nat措施是SNAT --to-source 218.29.30.31 指定转发源IP改为218.29.30.31 DNAT DNAT策略的典型应用环境： 在Internet中发布位于企业局域网内的服务器 DNAT策略的应用： 前提条件 局域网的Web服务器正确设置了IP地址/子网掩码局域网的Web服务器正确设置了默认网关地址 推荐实现步骤 确认已开启网关的路由转发功能 添加使用DNAT策略的防火墙规则 规则示例： iptables -t nat -A PREROUTING -i eth0 -d 218.29.30.31 -p tcp –dport 80 -j DNAT –to-destination 192.168.1.6iptables -t nat -A PREROUTING 在nat表的PREROUTING链上添加规则 i eth0 指定数据进来的接口 input d 218.29.30.31 指定访问的目的地址是外网的ip为218.29.30.31 destination p tcp –dport 80 指定访问的端口是80端口，在传输层使用的协议是tcp协议 port j DNAT 采取的nat措施是DNAT -to-destination 192.168.200.80:80 指定转发到内网的目的ip是192.168.200.80 并且端口也是80。提醒：转发后的端口号是可以修改的。并不一定要是80，可以是别的端口 ##########################################################映射：map访问一个A 然后转到D去，如： A —&gt;D B —&gt;C E —&gt;F有个一一对应的关系，有2边的阵容，访问一般的A，会给你转到另外一边的D。 web服务 开启80端口ssh服务 开启22端口 service network restart == 先 ifdown ens33 再 ifup ens33 重新配置ip地址(service network restart)的问题？ 1.ifup ens33 –》就是去读取网卡配置文件里的ip地址，配置到电脑上 2.ifdown ens33 –》关闭网卡 3.service network restart –》先关闭网卡，再去读取网卡配置文件里的ip地址，配置到电脑上 ifcfg-ens33 是一个配置文件linux下一切皆文件，文件是放在磁盘里的，能被保存下来；内存里的东西不会被保存 临时开启路由功能： echo 1 &gt;/proc/sys/net/ipv4/ip_forward永久开启路由功能： 1. 修改文件 vim /etc/sysctl.conf net.ipv4.ip_forward=1 2.让内核重新读取文件，配置开启路由功能 sysctl -p 防火墙规则清除 iptables -t nat -F 清除nat表里的规则 iptables -F 清除filter表里的规则 防火墙规则查看 iptables -t nat -L 查看nat表里的规则 iptables -L 查看filter表里的规则 添加DNAT策略 转发web的DNAT策略： iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.78 -p tcp –dport 80 -j DNAT –to-destination 192.168.200.80:80 iptables -t nat -A PREROUTING 在nat表的PREROUTING链上添加规则 -i ens37 指定数据进来的接口 input -d 192.168.0.78 指定访问的目的地址是外网的ip为192.168.0.78 destination -p tcp --dport 80 指定访问的端口是80端口，在传输层使用的tcp协议 port -j DNAT 采取的nat措施是DNAT --to-destination 192.168.200.80:80 指定转发到内网的目的ip是192.168.200.80 并且端口也是80。提醒：转发后的端口号是可以修改的。并不一定要是80，可以是别的端口 转发ssh的DNAT策略： iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.78 -p tcp --dport 22 -j DNAT --to-destination 192.168.200.80:22添加SNAT策略 iptables -t nat -A POSTROUTING -o ens37 -s 192.168.200.0/24 -j SNAT –to-source 192.168.0.78 iptables -t nat -A POSTROUTING-s 在nat表的POSTROUTING链上添加规则 -o eth0 指定数据出去的接口 output -s 192.168.1.0/24 指定来自特定网段（192.168.1.0/24）的数据包 source -j SNAT 采取的nat措施是SNAT --to-source 218.29.30.31 指定转发源IP改为218.29.30.31web服务器一定要开启，80端口，一定要安装web服务，建议安装nginxyum install nginxservice nginx restartiptables -F 在防火墙的服务器编写配置nat的脚本[root@routerB ~]# vim nat.sh[root@routerB ~]# cat nat.sh #!/bin/bash #清除nat和filter表里的防火墙规则iptables -t nat -Fiptables -F #添加web 服务器的DNAT规则iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.78 -p tcp –dport 80 -j DNAT –to-destination 192.168.200.80:80 #添加ssh 服务器的DNAT规则iptables -t nat -A PREROUTING -i ens37 -d 192.168.0.78 -p tcp –dport 22 -j DNAT –to-destination 192.168.200.122:22 #临时开启路由功能echo 1 &gt;/proc/sys/net/ipv4/ip_forward #添加SNAT功能的防火墙规则iptables -t nat -A POSTROUTING -o ens37 -s 192.168.200.0/24 -j SNAT –to-source 192.168.0.78 [root@routerB ~]# [root@routerB ~]# iptables -t nat -L -vn 查看防火墙规则 [root@routerB ~]# service firewalld stop 关闭firewalld防火墙服务Redirecting to /bin/systemctl stop firewalld.service[root@routerB ~]# bash nat.sh 重新执行nat.sh脚本[root@routerB ~]# iptables -t nat -L -vnChain PREROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination 0 0 DNAT tcp – ens37 * 0.0.0.0/0 192.168.0.78 tcp dpt:80 to:192.168.200.80:80 0 0 DNAT tcp – ens37 * 0.0.0.0/0 192.168.0.78 tcp dpt:22 to:192.168.200.122:22 Chain INPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination ​ 0 0 SNAT all – * ens37 192.168.200.0/24 0.0.0.0/0 to:192.168.0.78[root@routerB ~]# 在web server服务器上安装nginx服务web服务器一定要开启 80端口，一定要安装web服务，建议安装nginx 1.yum install epel-release 安装epel源 2.yum install nginx 安装nginx软件包 3.service nginx restart 刷新nginx这个服务 [root@Sanchuang-Linux ~]# yum install lsof -y 安装lsof软件包[root@Sanchuang-Linux ~]# lsof -i:80 查看80端口被哪个进程占用COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 14672 root 6u IPv4 295682 0t0 TCP *:http (LISTEN)nginx 14672 root 7u IPv6 295683 0t0 TCP *:http (LISTEN)nginx 14673 nginx 6u IPv4 295682 0t0 TCP *:http (LISTEN)nginx 14673 nginx 7u IPv6 295683 0t0 TCP *:http (LISTEN)4.[root@Sanchuang-Linux ~]# iptables -F 清除防火墙规则 ####################################################DNAT和SNAT的作用？它们的背后是靠哪个软件来实现的？ DNAT：发布内网的服务器，让外网的用户可以直接访问。 内网全部使用私有网络ip地址，因为没有那么多的公网ip地址。 防护的作用，外面的人不知道内网的服务器的ip，隐藏内网的作用 SNAT: 让内网的机器上网 内网全部使用私有网络ip地址，因为没有那么多的公网ip地址。 防护的作用，外面的人不知道内网的服务器的ip，隐藏内网的作用 iptables来实现防火墙的功能防火墙的好处是什么？ 隐藏ip 进行外网ip得过滤 不符合要求的数据不让过来。保护了内部网络。防火墙的危害？ 1.会影响数据传输的速度 2.消耗cpu和内存、网络带宽等资源 3.需要资金投入 路由器和防火墙有什么关系？ 防火墙是高级的路由器，有数据过滤功能。 端口号的范围： 1-65536]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>NAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-08视图]]></title>
    <url>%2F2019%2F08%2F01%2Fweb%E5%BC%80%E5%8F%91%2Fdjango-08%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Django视图什么是视图 视图，是一个简单的Python 函数/类，它接受Web请求并且返回Web响应。可响应的内容： 网页的HTML内容 重定向 404错误 XML文档 图片 是任何东西都可以 无论视图本身包含什么逻辑，都要返回响应。为了将代码放在某处，约定是将视图放置在项目或应用程序目录中的名为views.py的文件中。 一个简单视图12345678from django.shortcuts import HttpResponse# request 必填，名字可以修改，封装了用户请求的所有内容def demo01(request): html = '&lt;h1&gt;i am demo01&lt;/h1&gt;' print(html) # 此处不能直接return html, 必须返回一个HttpResponse对象 return HttpResponse(html) 代码说明： 导入HttpResponse 定义demo01函数，参数有1个名为request 返回一个HttpResponse对象 注意： 视图函数的名称并不重要，命名规则同变量 每个视图函数都负责返回一个HttpResponse对象 Request/Response处理流程的分析熟悉HttpRequest与HttpResponse工作方式 参考链接： http://blog.csdn.net/xiluoduyu/article/details/47255887 ​ Django-Request对象字段值HttpRequest是什么 HTTP 应用的信息是通过请求报文和响应报文传递的，关于更多的相关知识，可以阅读《HTTP权威指南》获得。 HttpRequest对象表示来自某客户端的一个单独的HTTP请求。HttpRequest对象是 Django自动创建的。 其中请求报文由客户端发送，其中包含和许多的信息，而 django 将这些信息封装成了 HttpRequest 对象，该对象由 HttpRequest 类创建。 每一个请求都会生成一个 HttpRequest 对象，django会将这个对象自动传递给响应的视图函数，一般视图函数约定俗成地使用 request 参数承接这个对象。当然你也可以使用其他参数来承接这个对象，并没有硬性规定一定要使用什么名称。 HttpRequest属性 django将请求报文中的请求行、首部信息、内容主体封装成 HttpRequest 类中的属性。除了特殊说明的之外，其他均为只读的。 打上断点，并以Debug模式运行Django。访问对应的URL，查看Request的属性 HttpRequest.scheme 一个字符串，代表请求的方案，一般为 ‘http’ 或 ‘https’。 HttpRequest.body 一个字符串，代表请求报文的主体。在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML等。 但是，如果要处理表单数据的时候，推荐还是使用 HttpRequest.POST 。 另外，我们还可以用 python 的类文件方法去操作它，详情参考 HttpRequest.read() 。 HttpRequest.path 一个字符串，表示请求的路径组件（不含域名）。 例如：”/music/bands/the_beatles/“ HttpRequest.path_info 一个字符串，在某些 Web 服务器配置下，主机名后的 URL 部分被分成脚本前缀部分和路径信息部分。path_info 属性将始终包含路径信息部分，不论使用的Web 服务器是什么。使用它代替 path 可以让代码在测试和开发环境中更容易地切换。 例如，如果应用的WSGIScriptAlias 设置为”/minfo”，那么当 path 是”/minfo/music/bands/the_beatles/“ 时path_info 将是”/music/bands/the_beatles/“。 HttpRequest.method 一个字符串，表示请求使用的HTTP 方法。必须使用大写。 例如：”GET”、”POST” HttpRequest.encoding 一个字符串，表示提交的数据的编码方式（如果为 None 则表示使用 DEFAULT_CHARSET 的设置，默认为 ‘utf-8’）。这个属性是可写的，你可以修改它来修改访问表单数据使用的编码。接下来对属性的任何访问（例如从 GET 或 POST 中读取数据）将使用新的 encoding 值。如果你知道表单数据的编码不是 DEFAULT_CHARSET ，则使用它。 HttpRequest.GET 一个类似于字典的对象，包含 HTTP GET 的所有参数。详情请参考 QueryDict 对象。 HttpRequest.POST 一个类似于字典的对象，如果请求中包含表单数据，则将这些数据封装成 QueryDict 对象。 POST 请求可以带有空的 POST 字典 —— 如果通过 HTTP POST 方法发送一个表单，但是表单中没有任何的数据，QueryDict 对象依然会被创建。因此，不应该使用 if request.POST 来检查使用的是否是POST 方法；应该使用 if request.method == “POST” 另外：如果使用 POST 上传文件的话，文件信息将包含在 FILES 属性中。 HttpRequest.REQUEST 一个类似于字典的对象，它首先搜索POST，然后搜索GET，主要是为了方便。灵感来自于PHP 的 $_REQUEST。 例如，如果 GET = {“name”: “john”} 而 POST = {“age”: ‘34’} ， REQUEST[“name”] 将等于”john”， REQUEST[“age”] 将等于”34”。 强烈建议使用 GET 和 POST 而不要用REQUEST，因为它们更加明确。 HttpRequest.COOKIES 一个标准的Python 字典，包含所有的cookie。键和值都为字符串。(放在Header中) HttpRequest.FILES 一个类似于字典的对象，包含所有的上传文件信息。FILES 中的每个键为&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;中的name，值则为对应的数据。 注意，FILES 只有在请求的方法为POST且提交的&lt;form&gt;带有enctype=&quot;multipart/form-data&quot;的情况下才会包含数据。否则，FILES 将为一个空的类似于字典的对象。 HttpRequest.META 一个标准的Python 字典，包含所有的HTTP 首部。具体的头部信息取决于客户端和服务器，下面是一些示例： CONTENT_LENGTH —— 请求的正文的长度（是一个字符串）。 CONTENT_TYPE —— 请求的正文的MIME 类型。 HTTP_ACCEPT —— 响应可接收的Content-Type。 HTTP_ACCEPT_ENCODING —— 响应可接收的编码。 HTTP_ACCEPT_LANGUAGE —— 响应可接收的语言。 HTTP_HOST —— 客服端发送的HTTP Host 头部。 HTTP_REFERER —— Referring 页面。 HTTP_USER_AGENT —— 客户端的user-agent 字符串。 QUERY_STRING —— 单个字符串形式的查询字符串（未解析过的形式）。 REMOTE_ADDR —— 客户端的IP 地址。 REMOTE_HOST —— 客户端的主机名。 REMOTE_USER —— 服务器认证后的用户。 REQUEST_METHOD —— 一个字符串，例如”GET” 或”POST”。 SERVER_NAME —— 服务器的主机名。 SERVER_PORT —— 服务器的端口（是一个字符串）。 从上面可以看到，除 和 ```CONTENT_TYPE``` 之外，请求中的任何 HTTP 首部转换为 META 的键时，都会将所有字母大写并将连接符替换为下划线最后加上```HTTP_```前缀。所以，一个叫做```X-Bender```的头部将转换成 META 中的```HTTP_X_BENDER```键。123456789* `HttpRequest.user` 一个 AUTH_USER_MODEL 类型的对象，表示当前登录的用户。 如果用户当前没有登录，user 将设置为```django.contrib.auth.models.AnonymousUser```的一个实例。你可以通过 is_authenticated() 区分它们。例如： if request.user.is_authenticated(): # Do something for logged-in users. else: # Do something for anonymous users.123 user 只有当Django 启用 AuthenticationMiddleware 中间件时才可用。+ 匿名用户: ```class models.AnonymousUser django.contrib.auth.models.AnonymousUser 类实现了django.contrib.auth.models.User 接口，但具有下面几个不同点： 1234567891011id 永远为None。username 永远为空字符串。get_username() 永远返回空字符串。is_staff 和 is_superuser 永远为False。is_active 永远为 False。groups 和 user_permissions 永远为空。is_anonymous() 返回True 而不是False。is_authenticated() 返回False 而不是True。set_password()、check_password()、save() 和delete() 引发 NotImplementedError。New in Django 1.8:新增 AnonymousUser.get_username() 以更好地模拟 django.contrib.auth.models.User。 HttpRequest.session 一个既可读又可写的类似于字典的对象，表示当前的会话。只有当Django 启用会话的支持时才可用。完整的细节参见会话的文档。 HttpRequest.urlconf 不是由Django 自身定义的，但是如果其它代码（例如，自定义的中间件类）设置了它，Django 就会读取它。如果存在，它将用来作为当前的请求的Root URLconf，并覆盖 ROOT_URLCONF 设置。 HttpRequest.resolver_match 一个 ResolverMatch 的实例，表示解析后的URL。这个属性只有在 URL 解析方法之后才设置，这意味着它在所有的视图中可以访问，但是在 URL 解析发生之前执行的中间件方法中不可以访问（比如process_request，但你可以使用 process_view 代替）。 HttpRequest.get_host() 根据从HTTP_X_FORWARDED_HOST（如果打开 USE_X_FORWARDED_HOST，默认为False）和 HTTP_HOST 头部信息返回请求的原始主机。如果这两个头部没有提供相应的值，则使用SERVER_NAME 和SERVER_PORT，在PEP 3333 中有详细描述。 USE_X_FORWARDED_HOST：一个布尔值，用于指定是否优先使用 X-Forwarded-Host 首部，仅在代理设置了该首部的情况下，才可以被使用。 例如：”127.0.0.1:8000” 注意：当主机位于多个代理后面时，get_host() 方法将会失败。除非使用中间件重写代理的首部。 HttpRequest.get_full_path() 返回 path，如果可以将加上查询字符串。 例如：”/music/bands/the_beatles/?print=true” HttpRequest.build_absolute_uri(location) 返回location 的绝对URI。如果location 没有提供，则使用request.get_full_path()的返回值。 如果URI 已经是一个绝对的URI，将不会修改。否则，使用请求中的服务器相关的变量构建绝对URI。 例如：”http://example.com/music/bands/the_beatles/?print=true&quot; HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt=&#39;&#39;, max_age=None) 返回签名过的Cookie 对应的值，如果签名不再合法则返回django.core.signing.BadSignature。 如果提供 default 参数，将不会引发异常并返回 default 的值。 可选参数salt 可以用来对安全密钥强力攻击提供额外的保护。max_age 参数用于检查Cookie 对应的时间戳以确保Cookie 的时间不会超过max_age 秒。 1234567891011121314151617&gt;&gt;&gt; request.get_signed_cookie('name') 'Tony' &gt;&gt;&gt; request.get_signed_cookie('name', salt='name-salt') 'Tony' # 假设在设置cookie的时候使用的是相同的salt &gt;&gt;&gt; request.get_signed_cookie('non-existing-cookie') ... KeyError: 'non-existing-cookie' # 没有相应的键时触发异常 &gt;&gt;&gt; request.get_signed_cookie('non-existing-cookie', False) False &gt;&gt;&gt; request.get_signed_cookie('cookie-that-was-tampered-with') ... BadSignature: ... &gt;&gt;&gt; request.get_signed_cookie('name', max_age=60) ... SignatureExpired: Signature age 1677.3839159 &gt; 60 seconds &gt;&gt;&gt; request.get_signed_cookie('name', False, max_age=60) False HttpRequest.is_secure() 如果请求时是安全的，则返回True；即请求通是过 HTTPS 发起的。 HttpRequest.is_ajax() 如果请求是通过XMLHttpRequest 发起的，则返回True，方法是检查 HTTP_X_REQUESTED_WITH 相应的首部是否是字符串’XMLHttpRequest’。 大部分现代的 JavaScript 库都会发送这个头部。如果你编写自己的 XMLHttpRequest 调用（在浏览器端），你必须手工设置这个值来让 is_ajax() 可以工作。 如果一个响应需要根据请求是否是通过AJAX 发起的，并且你正在使用某种形式的缓存例如Django 的 cache middleware， 你应该使用 vary_on_headers(‘HTTP_X_REQUESTED_WITH’) 装饰你的视图以让响应能够正确地缓存。 HttpRequest.read(size=None) 像文件一样读取请求报文的内容主体，同样的，还有以下方法可用。 1234# 其行为和文件操作中的一样。HttpRequest.readline()HttpRequest.readlines()HttpRequest.xreadlines() HttpRequest.__iter__() 说明可以使用 for 的方式迭代文件的每一行。 参考资料 https://www.cnblogs.com/scolia/archive/2016/07/01/5633351.html Django快捷返回方式 (HttpResponse) 官方文档：https://docs.djangoproject.com/en/1.11/topics/http/shortcuts/ Request 和 Response 对象起到了服务器与客户机之间的信息传递作用。Request对象用于接收客户端浏览器提交的数据，而Response 对象的功能则是将服务器端的数据发送到客户端浏览器。 每一个视图都需要一个返回（必须是一个Response对象）, 一个Response对象需要包含： 指定响应内容 响应格式 设置cookies HttpResponse：返回一个内容123456# request 必填，名字可以修改，封装了用户请求的所有内容def demo01(request): html = '&lt;h1&gt;i am demo01&lt;/h1&gt;' print(html) # 此处不能直接return html, 必须返回一个HttpResponse对象 return HttpResponse(html) render: 结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。1render(request, template_name[, context][, context_instance][, content_type][, status][, current_app][, dirs][, using]) 必选的参数 request: 该request用于生成response template_name: 要使用的模板的完整名称或者模板名称的一个序列。 可选的参数 context: 添加到模板上下文的一个字典。super如果字典中的某个值是可调用的，视图将在渲染模板之前调用它。 content_type: 生成的文档要使用的MIME 类型。默认为设置的值。123 * `status`: 响应的状态码。默认为200。* 使用示例： 下面的示例渲染模板myapp/index.html，MIME 类型为application/xhtml+xml：from django.shortcuts import renderdef my_view(request): View code here… return render(request, ‘myapp/index.html’, {“foo”: “bar”}, content_type=”application/xhtml+xml”, status=301) 12#### ```render_to_response 1render_to_response(template_name[, context][, context_instance][, content_type][, status][, dirs][, using]) 结合一个给定的模板和一个给定的上下文字典，并返回一个渲染后的 HttpResponse 对象。 必选的参数 要使用的模板的完整名称或者模板名称的一个序列。12* 使用示例： 下面的示例渲染模板myapp/index.html，MIME 类型为application/xhtml+xml：from django.shortcuts import render_to_responsedef my_view(request): # View code here... return render_to_response(&apos;myapp/index.html&apos;, {&quot;foo&quot;: &quot;bar&quot;}, content_type=&quot;application/xhtml+xml&quot;)12#### redirect redirect(to, [permanent=False, ]*args, `kwargs) 12345678910为传递进来的参数返回HttpResponseRedirect 给正确的URL* 参数可以是：一个模型：将调用模型的```get_absolute_url()``` 函数一个视图，可以带有参数：将使用```urlresolvers.reverse``` 来反向解析名称一个绝对的或相对的URL，将原封不动的作为重定向的位置。* 使用示例： from django.shortcuts import redirectdef my_view(request): … object = MyModel.objects.get(…) # 通过传递一个对象；将调用get_absolute_url() 方法来获取重定向的URL return redirect(object) # 通过传递一个视图的名称，可以带有位置参数和关键字参数；将使用reverse() 方法反向解析URL return redirect(&apos;some-view-name&apos;, foo=&apos;bar&apos;) # 传递要重定向的一个硬编码的URL return redirect(&apos;/some/url/&apos;) # 一个完整的URL return redirect(&apos;http://example.com/&apos;)12345678#### JsonResponse：返回一个Json格式数据&gt; 接口返回json格式数据，直接用JsonResponse #### Http404：手动引发404页面Django提供了Http404异常。如果你在视图函数中的任何地方抛出Http404异常，Django都会捕获它，并且带上HTTP404错误码返回你应用的标准错误页面。 from django.shortcuts import render, HttpResponse, redirect, Http404def index(request) # 触发一个404错误 raise Http404(&apos;not exist&apos;) return HttpResponse(&apos;I am index&apos;)12测试这个效果需要非DEBUG模式 myblogsettings.pyDEBUG = FalseALLOWED_HOSTS = [‘127.0.0.1’, ‘localhost’] 12#### get_object_or_404 get_object_or_404(klass, *args, `kwargs) 1234567在一个给定的模型管理器上调用get()，但是引发Http404 而不是模型的DoesNotExist 异常。* 必选的参数 * klass: 获取该对象的一个Model 类，Manager或QuerySet 实例。 * `kwargs`: 查询的参数，格式应该可以被get() 和filter()接受。* 示例： from django.shortcuts import get_object_or_404 def my_view(request): my_object = get_object_or_404(MyModel, pk=1) return xxx 这个示例等同于：from django.http import Http404 def my_view(request): try: my_object = MyModel.objects.get(pk=1) except MyModel.DoesNotExist: raise Http404(“No MyModel matches the given query.”) return xxx 12* 参数可为queryset queryset = Book.objects.filter(title__startswith=’M’)get_object_or_404(queryset, pk=1) 12* 参数可为自定义管理器 get_object_or_404(Book.dahl_objects, title=’Matilda’) 12* 参数可为关联的管理器 author = Author.objects.get(name=’Roald Dahl’)get_object_or_404(author.book_set, title=’Matilda’) 12#### get_list_or_404 get_list_or_404(klass, *args, `kwargs)[source] 123返回一个给定模型管理器上filter() 的结果，并将结果映射为一个列表，如果结果为空则返回Http404。* 示例： from django.shortcuts import get_list_or_404def my_view(request): my_objects = get_list_or_404(MyModel, published=True) 这个示例等同于：from django.http import Http404def my_view(request): my_objects = list(MyModel.objects.filter(published=True)) if not my_objects: raise Http404(“No MyModel matches the given query.”) 12345678### 基于类的视图&gt; 文档：https://docs.djangoproject.com/en/1.11/ref/class-based-views/在早期，我们认识到在视图开发过程中有共同的用法和模式。这时我们引入基于函数的通用视图来抽象这些模式以简化常见情形的视图开发。* 基于函数视图的用法有以下三种： def index(request): return HttpResponse(‘hello world!’) def index(request): result = {‘demo’:’demo’} return render(request, ‘blog/about.html’, result) def index(request): result = {‘demo’:’demo’} return render_to_response(‘blog/about.html’, result)``` 基于函数的视图的问题在于，虽然它们很好地覆盖了简单的情形，但是不能扩展或自定义它们，即使是一些简单的配置选项，这让它们在现实应用中受到很多限制。基于类的通用视图然后应运而生，目的与基于函数的通用视图一样，就是为了使得视图的开发更加容易。 django 基本类视图分为四类： 基础类视图： ViewTemplateViewRedirectView 展示类视图：(get) DetailViewListView 编辑类视图： FormViewCreateViewUpdateViewDeleteView 日期类视图： ArchiveIndexViewYearArchiveViewMonthArchiveViewWeekArchiveViewDayArchiveViewTodayArchiveViewDateDetailView 下面三个是最常使用的基于类的通用视图： TemplateView，View，ListView，DetailView]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django视图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-07跨站请求伪造]]></title>
    <url>%2F2019%2F07%2F31%2Fweb%E5%BC%80%E5%8F%91%2Fdjango-07%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%2F</url>
    <content type="text"><![CDATA[1. CSRF（Cross-site request forgery）是什么？CSRF中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF CSRF是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。 CSRF能够做的事情包括： 以你名义发送邮件，发消息，盗取你的账号 甚至于购买商品，虚拟货币转账…… 造成的问题包括：个人隐私泄露以及财产安全。 2. CSRF的原理下图简单阐述了CSRF攻击的思想： 从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。=&gt; host/trans/from=a&amp;to=bsite&amp;money=100 看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生： 你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。 你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……） 上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！ 3. CSRF的防御CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 Cookie Hashing 所有表单都包含同一个伪随机值。这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。 这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。一般的攻击者看到有需要算Hash值，基本都会放弃了，某些除外，所以如果需要100%的杜绝，这个不是最好的方法。 One-Time Tokens 不同的表单包含一个不同的伪随机值。 在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提 交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单 都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。 4. Django解决办法 原理 Django使用专门的中间件CsrfMiddleware来进行CSRF防护。具体的原理如下： django 第一次响应来自某个客户端的请求时，会在服务器端随机生成一个 token，把这个 token 放在 cookie 里。然后每次 POST 请求都会带上这个 token，这样就能避免被 CSRF 攻击。 在返回的 HTTP 响应的 cookie 里，django 会为你添加一个 csrftoken 字段，其值为一个自动生成的 token() 在所有的 POST 表单时，必须包含一个 csrfmiddlewaretoken 字段 （只需要在模板里加一个 tag， django 就会自动帮你生成，见下面） 在处理 POST 请求之前，django 会验证这个请求的 cookie 里的 csrftoken 字段的值和提交的表单里的 csrfmiddlewaretoken 字段的值是否一样。如果一样，则表明这是一个合法的请求，否则，这个请求可能是来自于别人的 csrf 攻击，返回 403 Forbidden. 在所有 ajax POST 请求里，添加一个X-CSRFTOKEN header，其值为 cookie 里的 csrftoken 的值 具体操作 settings配置（全局防护） 12345678910# 配置中间件,启用django.middleware.csrf.CsrfViewMiddleware# 加上后即可全局使用csrf防护（默认已经添加）；MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', ...] 注：该中间件必须在 SessionMiddleware 之后执行 它也必须在响应被压缩或解压之前对响应结果进行处理，因此CsrfMiddleware必须在GZipMiddleware之后执行。 - 局部防护方法：在视图函数上加` @csrf_protect`进行单view控制 1from django.views.decorators.csrf import csrf_protect - 局部不防护：在视图函数中不想进行csrf保护的view可以加上`@csrf_exempt` 123from django.views.decorators.csrf import csrf_exempt# 对应的函数加 @csrf_exempt 装饰器 - 启用防护时html页面的form表单 1# 在html的表单中form标签后加上&#123;% csrf_token %&#125; - ajax提交post请求 - 视图使用render返回 - 在html模板script标签中加（注：不能 .js文件中加以下代码）： 1$.ajaxSetup(&#123; data: &#123;csrfmiddlewaretoken: ‘&#123;&#123; csrf_token &#125;&#125;’ &#125;, &#125;); ​ 5. 其它模板引擎 如与Jinja2结合的解决办法： 1、settings.py配置 1在 MIDDLEWARE_CLASSES 中加上 ‘django.middleware.csrf.CsrfViewMiddleware’ 这个中间件 2、校验cookie中的csrf值 视图函数：导入模块 1from django.core.context_processors import csrf 修改上下文参数 123context = &#123;&#125; context.update(csrf(request)) return render(context, 'login.html') 在模板HTML文件中的对应的Form表单里加 1&lt;input type="hidden" id="csrfmiddlewaretoken" name="csrfmiddlewaretoken" value="&#123;&#123; csrf_token &#125;&#125;"&gt; 参考资料：http://www.h3c.com/cn/d_201208/751467_30008_0.htm]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>CSRF(跨站请求伪造)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-06form表单]]></title>
    <url>%2F2019%2F07%2F29%2Fweb%E5%BC%80%E5%8F%91%2Fdjango-06form%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[什么是form表单html上的展示的用来给用户提交信息的表单 表单展示 数据提交 数据验证 什么时候用django-Form表单 做表单提交时对数据进行验证： 用户名长度 邮箱格式 js验证（前端验证）： button.onclick(function{}) = 验证 可能会存在一些验证不到位 django-form的作用 生成表单 后端验证 From表单的优劣 好处： 提供后端验证 写起来简单，前端小白的福音 文章 可以直接基于Model来写，易维护 不足 不够灵活 Django中Forms的实现方式 众所周知，form最常做的是对用户输入的内容进行验证，为此django的forms类提供了全面的内容验证和保留用户上次输入数据的支持。django框架提供了一个form类，来处理web开发中的表单相关事项。 Django处理表单中涉及的工作的三个不同部分： 准备和重组数据以使其为渲染做好准备 为数据创建HTML表单 接收和处理客户提交的表格和数据 Form类描述一个表单并确定它是如何工作和出现的。类似于模型类的字段映射到数据库字段的方式，表单类的字段映射到HTML表单元素。 表单的字段本身就是类; 他们管理表单数据并在提交表单时执行验证。不同的字段处理的内容不一样。 Django中提供了两种常用的Form类，分别是forms.ModelForm与forms.Form 如果要将表单中的数据写入数据库或者修改某些记录的值，就要让表单类继承ModelForm。ModelForm直接使用Model中的字段创建表单。 如果提交表单后 不会对数据库就行修改，则继承Form类。Form使用自己定义的字段创建表单。 label:参数 widgets:小部件 required:true-&gt;初始化的值 error_message:错误提示 Django中的session和cookiesession与cookie介绍HTTP被设计为”无状态”，在一次请求和下一次请求之间没有任何状态保持，我们无法根据请求的任何方面(IP地址，用户代理等)来识别来自同一人的连续请求。 session： Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。 cookie： cookies 是浏览器为 Web 服务器存储的一小段信息。 每次浏览器从某个服务器请求页面时，它向服务器回送之前收到的cookies。它保存在浏览器下的某个文件夹下。 浏览器下的cookie： session和cookie如何实现状态记录？ Django的session与cookie的实现原理。 服务器会生成两份相同的cookie字符串，一份保存在本地，一份发向请求的浏览器。 浏览器将收到的cookie字符串保存下来，当下次再发请求时，会将信息与这段cookie一同发送到服务器 服务器得到这段cookie会与本地保存的那份判断是否相同，如果相同就表示用户已经登录成功，保存用户登录成功的状态。 Django的session保存在数据库中的数据相当于一个大字典，key为cookie的字符串，value仍是一个字典，字典的key和value为用户设置的相关信息。这样就可以方便的存取session里面的信息。 Django操作session 开启session 设置session：reqeust.session[key] = True 获取session： request.session[key] request.session.get(key) 删除session：del request.session[key] 参考文献：https://blog.csdn.net/zcmuczx/article/details/80093063 django.contrib.auth模块简介1from django.contrib import auth auth模块是对登录认证方法的一种封装，之前我们获取用户输入的用户名及密码后需要自己从user表里查询有没有用户名和密码符合的对象，而有了auth模块之后就可以很轻松的去验证用户的登录信息是否存在于数据库中。除此之外，auth还对session做了一些封装，方便我们校验用户是否已登录 如果我们要使用auth模块，也需要将session模块启用 django.contrib.auth里的方法django.contrib.auth中提供了许多方法，这里主要介绍其中的四个： 用户认证：authenticate(username, password) 验证用户名以及密码是否正确，一般需要username，password两个关键字参数 如果认证信息有效，会返回一个 User 对象。 如果用户名密码无效，它返回一个 None 验证流程： 用法： 1user = authenticate(username = 'someone', password='somepassword') 用户登录：login(HttpRequest, user) 该函数接受一个HttpRequest对象，以及一个认证了的User对象 在视图中登录一个用户的话，使用 login() 函数通过Django的session框架把用户的ID保存到session中。所以，你要确认你已经安装了session中间件。 注销用户：logout(request) 它接收一个 HttpRequest 参数，没有返回值。 请注意：如果用户没有登录的话， logout() 也不会抛出任何异常的。 判断用户是否已登录 user对象的 is_authenticated()， authenticate返回的user对象，判断用户是否已登录 用法： 1user.is_authenticated() 使用装饰器验证login_required 若用户没有登录，则会跳转到django默认的 登录URL /accounts/login/ 这个值可以在settings文件中通过LOGIN_URL进行修改 用法： 12345from django.contrib.auth.decorators import login_required @login_requireddef my_view(request): ... user对象 的其他： user.is_staff()：用户是否拥有网站的管理权限 user.is_active() ： 是否允许用户登录 user.check_password(password)：检查用户密码是否跟传入的密码一致 user.set_password(password)：修改密码 123user = User.objects.get(username='')user.set_password(password='')user.save create_user：创建新用户 12from django.contrib.auth.models import Useruser = User.objects.create_user（username='',password='',email=''）]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>form表单</tag>
        <tag>django的session和cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP协议]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2FTCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[查看内存排名前十的进程 ps aux|sort -k 4 -rn|head 查看服务器打开了哪些网络的端口？ 如何知道网卡的流量？ tcp的拥堵控制和流量控制？ TCP/IP协议参考模型（OSI 7层模型）（应表会传网数物） 交换机在数据链路层 路由器在网络层 应用层协议（http\ssh） 传输层协议（TCP\UDP） TCP/IP模型与OSI模型的比较 相同点 两者都是以协议栈的概念为基础 协议栈中的协议彼此相互独立 下层对上层提供服务 不同点 OSI是先有模型：TCP/IP是先有协议，后在模型 OSl适用于各种协议栈；TCP/IP只适用于TCP/IP网络 层次数量不同 传输层 传输层的作用 IP层提供点到点的连接 传输层提供端到端的连接（端到端：一个程序到另一个程序，不同程序会监听不同的端口） django默认监听8000端口 nginx也可以监听8000端口 通过不同的端口号来识别不同的程序 TCP (Transmission Control Protocol) 相当于打电话 传输控制协议 可靠的（各种计时器）、面向连接（三次握手、四次断开）的协议 传输效率低 TCP的封装格式 理论上的端口号范围：0-65536（实际上在使用的是1-65535） ACK：（acknowledge）确认序列号有效位，表明该数据包包含确认信息 SYN：为1时，请求建立连接 FIN：为1时，数据发送完毕，请求端口连接 16位窗口大小：滑动窗口的大小，指明本地可接收数据的字节数 连接与断开三次握手 SYN置为1 SYN置为1，ACK置为1 ACK置为1 5种状态 LISTEN：监听服务启动，准备好了，等待其他程序连接的状态 ESTABLISHED：建立连接 SYN_SENT SYN_RECV CLOSED 可以拿ssh服务来举例说明 ssh是保持长连接的 四次断开 可以拿ssh服务来举例说明 为什么要time_wait? 防止最后发送的ack数据包丢失，导致对方没有收到，一直处于last_ack状态，对方有个重传计时器，超时，会触发重新再发一次FIN位为1的断开数据包。这样因为time_wait计时器如果没有超时会再次接受到FIN位为1的数据包，然后会再发一次最后的ack确认包。 如果web nginx 服务器上有大量的time_wait状态，说明了什么？ 答案：服务器正在和客户机断开 流量控制 滑动窗口的作业：告诉对方我这边能接受多少字节的数据 MTU：最大传输单元1500 数据帧的范围：64—1518 抓包工具：科来、tcpdump、wireshark、sniffer 拥塞控制 原理：通过互相通知window size 来告诉对方能接收多少数据，这样发送方就发送多少数据，从而达到不丢失数据。 目的：不丢失数据 OOM:out of memory(内存溢出) 现在的正在使用的算法：通过window size 来判断前方是否拥堵。 其他的算法：BBR算法 差错控制3种方式 校验和 确认 受损伤的数据段 丢失的数据段 重复的数据段 失序的数据段 确认的丢失 超时 计时器可靠性 重传计时器：为了控制丢失的数据段 坚持计时器：为了防止零窗口死锁（window size为0时候，双方进入等待状态，防止死锁） 保活计时器：防止两个TCP之间的连接长时间的空闲（服务器用来探测客户机是否还在连接，如果不连接了，就断开连接，回收（进程、cpu、内存）） 时间等待计时器：连接终止期间使用的。四次断开的最后阶段时候，自己给对方发送的数据丢失，烤虑到对方会重新发送数据段过来，才开启的计时器。其实是为了对方考虑，不耽误对方的时间 TCP的应用 端口 协议 说明 21 FTP 文件传输协议，用于上传、下载 23 Telnet 用于远程登录，通过连接目标计算机的这一端口，得到验证后可以远程控制管理目标计算机 25 SMTP 简单邮件传输协议，用于发送邮件 53 DNS 域名服务，当用户输入网站的名称后，由DNS负责将它解析成IP地址，这个过程中用到的端口号是53 80 HTTP 超文本传输协议，通过HTTP实现网络上超文本的传输 443 HTTPS 超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 22 SSH SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。 注：在nginx里 /etc/service—–&gt;此文件会记录着世界上开源的免费的协议使用的端口号和tcp还是udp UDP (User Datagram Protocol) 相当发短信 用户数据报协议 不可靠的、无连接的服务 传输效率高 UDP的流控和差错控制 UDP没有流控机制 UDP只有校验和来提供差错控制 需要上层协议来提供差错控制：例如TFTP协议 UDP的使用 端口 协议 说明 69 TFTP 简单文件传输协议 53 DNS 域名服务 123 NTP 网络时间协议 111 RPC 远程过程调用 TCP/IP协议栈 数据链路层 PPP、Ethernet 网络层 ip、arp、icmp、rip、ospf 传输层 tcp、udp 应用层 http、ftp、smtp、ntp、https、dns、QQ 常见面试题【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？ 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 【问题3】为什么不能用两次握手进行连接？ 答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 【问题5】四次挥手释放连接时，等待2MSL的意义？1.为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。2.就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>三次握手四次断开</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lvs负载均衡]]></title>
    <url>%2F2019%2F07%2F26%2Flinux%2Flvs%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[lvs负载均衡服务器安全运维规范集群：(cluster) 很多台机器做一样事情（提供一样的功能） 集群： 1.成本 2.性能 3.稳定性:是否需要停止服务 4.高可用型(优势) 5.维护方面 6.扩展性 集群非常好的软件(都是开源的) nginx lvs LVS集群软件 简介：LVS是Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。本项目在1998年5月由章文嵩博士成立，是中国国内最早出现的自由软件项目之一。 章文嵩是技术专家，也是LVS(Linux Virtual Server，Linux虚拟服务器)开源软件创始人，曾经是TelTel公司的首席科学家，ChinaCluster的共同创办人。他对自己的看法是： 一个比较注重做实际工作的有用的人。 linux内核直接支持。 集群采用三层结构（一般来说，LVS集群采用三层结构，其主要组成部分为：） 负载调度器（load balancer），它是整个集群对外面的前端机，负责将客户的请求发送到一组服务器上执行，而客户认为服务是来自一个IP地址（我们可称之为虚拟IP地址）上的。 服务器池（server pool），是一组真正执行客户请求的服务器，执行的服务有WEB、MAIL、FTP和DNS等。 共享存储（shared storage），它为服务器池提供一个共享的存储区，这样很容易使得服务器池拥有相同的内容，提供相同的服务。 调度器是服务器集群系统的唯一入口点（Single Entry Point），它可以采用IP负载均衡技术、基于内容请求分发技术或者两者相结合。LVS官方网站 中文文档英文文档 LVS的3种模式 Virtual Server via Network Address Translation（VS/NAT） 通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。 Virtual Server via IP Tunneling（VS/TUN） 采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，当客户请求越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报 文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。由于一般网络服务应答比请求报文大许多，采用 VS/TUN技术后，集群系统的最大吞吐量可以提高10倍。 Virtual Server via Direct Routing（VS/DR） VS/DR通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返回给客户。同VS/TUN技术一样，VS/DR技术可极大地 提高集群系统的伸缩性。这种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但是要求调度器与真实服务器都有一块网卡连 在同一物理网段上。 针对不同的网络服务需求和服务器配置，IPVS调度器实现了如下八种负载调度算法： 轮叫（Round Robin） 调度器通过”轮叫”调度算法将外部请求按顺序轮流分配到集群中的真实服务器上，它均等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。 加权轮叫（Weighted Round Robin） 调度器通过”加权轮叫”调度算法根据真实服务器的不同处理能力来调度访问请求。这样可以保证处理能力强的服务器处理更多的访问流量。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 最少链接（Least Connections） 调度器通过”最少连接”调度算法动态地将网络请求调度到已建立的链接数最少的服务器上。如果集群系统的真实服务器具有相近的系统性能，采用”最小连接”调度算法可以较好地均衡负载。 加权最少链接（Weighted Least Connections） 在集群系统中的服务器性能差异较大的情况下，调度器采用”加权最少链接”调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。 基于局部性的最少链接（Locality-Based Least Connections） “基于局部性的最少链接” 调度算法是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器 是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用”最少链接”的原则选出一个可用的服务 器，将请求发送到该服务器。 带复制的基于局部性最少链接（Locality-Based Least Connections with Replication） “带复制的基于局部性最少链接”调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个 目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务 器组，按”最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按”最小连接”原则从这个集群中选出一 台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的 程度。 目标地址散列（Destination Hashing） “目标地址散列”调度算法根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。 源地址散列（Source Hashing） “源地址散列”调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。 适用性 后端服务器可运行任何支持TCP/IP的操作系统，包括Linux，各种Unix（如FreeBSD、Sun Solaris、HP Unix等），Mac/OS和Windows NT/2000等。 负载调度器能够支持绝大多数的TCP和UDP协议： 协议 内 容 TCP HTTP，FTP，PROXY，SMTP，POP3，IMAP4，DNS，LDAP，HTTPS，SSMTP等 UDP DNS，NTP，ICP，视频、音频流播放协议等 无需对客户机和服务器作任何修改，可适用大多数Internet服务。 DR模式123456临时添加ip地址[root@WEB-SERVER ~]# ip address add 192.168.0.199/24 dev ens33安装ipvsadm软件[root@LB-MASTER nginx]# yum install ipvsadmipvsadm is used to setup, maintain, and inspect the virtual servertable in the Linux kernel. DR上的脚本的内容 12345678910111213141516171819#! /bin/bash#开启路由转发功能 1表示打开 0 表示关闭echo 1 &gt; /proc/sys/net/ipv4/ip_forwardipv=/sbin/ipvsadmvip=192.168.0.172rs1=192.168.0.80rs2=192.168.0.138#给ens33上再配置一个ip地址做vip使用ifconfig ens33:0 downifconfig ens33:0 $vip broadcast $vip netmask 255.255.255.255 up#添加到vip的主机路由route add -host $vip dev ens33:0#lvs的配置$ipv -C #清楚lvs 虚拟服务器表里的内容$ipv -A -t $vip:80 -s wrr #添加一条规则，指定vip和端口，指定调度算法wrr（加权轮询）$ipv -a -t $vip:80 -r $rs1:80 -g -w 1 #指定real server 和权重值$ipv -a -t $vip:80 -r $rs2:80 -g -w 1 web服务器上的脚本 #! /bin/bash vip=192.168.0.172 #给lo接口添加一个vip地址 ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up #添加到vip地址的路由 route add -host $vip lo:0 ​ 12345#arp毒化配置（又聋又哑）echo "1" &gt;/proc/sys/net/ipv4/conf/lo/arp_ignoreecho "2" &gt;/proc/sys/net/ipv4/conf/lo/arp_announceecho "1" &gt;/proc/sys/net/ipv4/conf/all/arp_ignoreecho "2" &gt;/proc/sys/net/ipv4/conf/all/arp_announce DNS轮询算法(RR)的缺点： 主动权在dns服务器手里 DNS解析记录有缓存–》TTL时间 如果服务器出现问题，曾经访问过这个服务器的客户机任然去继续访问这个ip地址，导致网站访问不了 VPN：虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。虚拟私人网络（Virtual Private Network） lvs NAT模式的实验 ipvsadm 是一个给lvs软件传递参数和查看相关信息的工具 123456789101112131415161718192021222324252627282930313233343536373839404142434445 [root@LB ~]# yum install ipvsadm #关闭防火墙和selinux [root@LB ~]# iptables -F [root@LB ~]# service firewalld stop Redirecting to /bin/systemctl stop firewalld.service [root@LB ~]# getenforce Enforcing [root@LB ~]# setenforce 0 [root@LB ~]# getenforce Permissive [root@LB ~]# iptables -L Chain INPUT (policy ACCEPT) target prot opt source destination Chain FORWARD (policy ACCEPT) target prot opt source destination Chain OUTPUT (policy ACCEPT) target prot opt source destination [root@LB ~]# getenforce Permissive [root@LB ~]# cat lvs_nat.sh #! /bin/bash #director 服务器上开启路由转发功能 echo 1 &gt; /proc/sys/net/ipv4/ip_forward#director 设置nat防火墙 iptables -t nat -F iptables -t nat -X iptables -t nat -A POSTROUTING -s 192.168.80.0/24 -o ens33 -j SNAT --to-source 192.168.0.205 #director设置ipvsadm IPVSADM='/usr/sbin/ipvsadm' $IPVSADM -C #清空规则 $IPVSADM -A -t 192.168.0.205:80 -s rr rr为轮询 $IPVSADM -a -t 192.168.0.205:80 -r 192.168.80.2:80 -m #-a增加服务器 -m表示LVS模式为NAT $IPVSADM -a -t 192.168.0.205:80 -r 192.168.80.3:80 -m #-r指定服务器IP [root@LB ~]# [root@LB ~]# ipvsadm -l IP Virtual Server version 1.2.1 (size=4096) Prot LocalAddress:Port Scheduler Flags -&gt; RemoteAddress:Port Forward Weight ActiveConn InActConn TCP LB:http rr -&gt; 192.168.80.2:http Masq 1 12 5 -&gt; 192.168.80.3:http Masq 1 9 10 LVS的NAT模式：1. 修改的是源ip还是目的ip？ 2. 有哪些调度算法 3. 是否可以接很多很多的real server？ ​]]></content>
      <categories>
        <category>linux高级</category>
      </categories>
      <tags>
        <tag>lvs负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-05模板层]]></title>
    <url>%2F2019%2F07%2F26%2Fweb%E5%BC%80%E5%8F%91%2Fdjango-05%E6%A8%A1%E6%9D%BF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[模板继承与重用为什要模板继承和重用 减少代码冗余 维护方便 什么是模板拆分 将html进行组装，变成一个包含公共部分的模板页（’base.html’） 创建新页面时，从模板页继承即可（extends） 把每个功能拆分成单独的Html页面 后期改代码方便找 改的时候不容易出错 模板拆分的好处 减少冗余代码 页面更干净 修改更方便（文件越小越好找，越不容易出错） 如何进行模板拆分1.正确展示页面 URL：tempt]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>模板层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django-04路由系统]]></title>
    <url>%2F2019%2F07%2F25%2Fweb%E5%BC%80%E5%8F%91%2Fdjango-04%E8%B7%AF%E7%94%B1%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[路由系统1. URL整洁之道 为什么URL应该保持整洁和有意义 参见万维网发明者Berners-Lee的Cool URIs don’t change 里面有关于的卓越论证。 两种url设计方式的对比：id为1的博客 /blog/1 /blog.php?id=1 2. Django的路由系统对于高质量的Web应用来说，使用简洁、优雅的URL模式是一个非常值得重视的细节。Django让你随心所欲设计你的URL，不受框架束缚。为了给一个应用设计URL，你需要创建一个Python 模块，通常称为URLconf（URL configuration）。这个模块是纯粹的Python 代码，包含URL 模式（简单的正则表达式）到Python 函数（你的视图）的简单映射。映射可短可长，随便你。它可以引用其它的映射。因为它是纯粹的Python代码，它可以动态构造。 Django 还提供根据当前语言翻译URL 的一种方法。更多信息参见国际化文档。Django的路由默认都在urls文件里，它将浏览器输入的url映射到相应的业务处理逻辑。 3.什么是URL规划 URL命令 URL拆分 扩展：restful POST:创建资源 GET:请求资源（幂等操作） PATCH:更新资源 DELETE:删除资源 4.为什么要做URL规划 层次结构更清晰 分工更明确 5.什么时候做URL拆分 当URL量比较大 有明确的分类 6. 如何做URL规划 URL链接 7. 官方帮助https://docs.djangoproject.com/en/1.11/topics/http/urls/ 状态码 参考资料：http://www.ruanyifeng.com/blog/2014/05/restful_api.html]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>路由系统</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django初探-03返回动态页面]]></title>
    <url>%2F2019%2F07%2F24%2Fweb%E5%BC%80%E5%8F%91%2Fdjango%E5%88%9D%E6%8E%A2-03%E8%BF%94%E5%9B%9E%E5%8A%A8%E6%80%81%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[Django-返回动态页面 目标：数据库交互，返回用户提交的数据 Django中可以通过自带的ORM框架操作数据库，并且自带轻量级的sqlite3数据库。 1. 配置数据库信息: 默认使用的是sqlite（它还支持很多） 12345678910111213141516171819202122232425# djangostart/settings.py# Database# https://docs.djangoproject.com/en/1.11/ref/settings/#databases# Sqlie配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 存放路径 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# MySQL配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'myblog02', 'USER': 'root', 'PASSWORD': '12345', 'HOST': '192.168.137.200', 'PORT': '3306', 'OPTIONS': &#123; 'init_command': "SET sql_mode='STRICT_TRANS_TABLES'", &#125;,&#125; 注意，遇到报MySQLdb错误，请用以下解决办法： 方法1：安装mysqlclient 方法2：安装pymysql，在项目mysite/init.py文件添加： 12import pymysqlpymysql.install_as_MySQLdb() 这里我们创建了2个字段，分别保存用户的邮箱和密码。 2. 建立数据库模型123456# 编辑app01/models.py(MTV中的M)from django.db import models# 继承models.Model类class UserInfo(models.Model): username = models.CharField(max_length=64) password = models.CharField(max_length=128) 3. 注册app01 不注册它，你的数据库就不知道该给哪个app创建表 12345678910# djangostart/settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01',] 4. 生成建表文件1234&gt; python manage.py makemigrationsMigrations for 'app1':app1\migrations\0001_initial.py- Create model UserInfo 5. 执行建表操作123456789101112131415161718&gt; python manage.py migrateOperations to perform:Apply all migrations: admin, app1, auth, contenttypes, sessionsRunning migrations:Applying contenttypes.0001_initial... OKApplying auth.0001_initial... OKApplying admin.0001_initial... OKApplying admin.0002_logentry_remove_auto_add... OKApplying app1.0001_initial... OKApplying contenttypes.0002_remove_content_type_name... OKApplying auth.0002_alter_permission_name_max_length... OKApplying auth.0003_alter_user_email_max_length... OKApplying auth.0004_alter_user_username_opts... OKApplying auth.0005_alter_user_last_login_null... OKApplying auth.0006_require_contenttypes_0002... OKApplying auth.0007_alter_validators_add_error_messages... OKApplying auth.0008_alter_user_username_max_length... OKApplying sessions.0001_initial... OK 6. 保存用户数据1234567891011# app01/views.pydef register(request): print(request.method) if request.method == 'POST': username = request.POST.get("username", None) password = request.POST.get("password", None) # 添加数据到库 UserInfo.objects.create(username=username, password=password) # 查询数据 user_list = UserInfo.objects.all() return render(request, 'register.html', &#123;'user_list': user_list&#125;) 7. 修改templates/demo01.html，添加以下数据123456789101112&lt;hr&gt;&lt;h1&gt;所有用户&lt;/h1&gt;&#123;% if user_list %&#125; &lt;table&gt; &#123;% for user in user_list %&#125; &lt;tr&gt; &lt;td&gt;&#123;&#123; user.username &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; user.password &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &#123;% endfor %&#125; &lt;/table&gt;&#123;% endif %&#125; 8. 访问结果 9. 小结至此，一个要素齐全，主体框架展示清晰的django项目完成了]]></content>
      <categories>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>返回动态页面</tag>
        <tag>与数据库建立连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django初探-02返回HTML页面]]></title>
    <url>%2F2019%2F07%2F24%2Fweb%E5%BC%80%E5%8F%91%2Fdjango%E5%88%9D%E6%8E%A2-02%E8%BF%94%E5%9B%9EHTML%E9%A1%B5%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[通常在实际开发中，我们会将html代码与业务逻辑代码分离，这样结构更清晰 1. 编写html文件我们写这么一个templates/demo01.html文件，内容来源： http://v3.bootcss.com/getting-started/#template http://v3.bootcss.com/css/#forms css-js文件 html内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# templates/demo01.html&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;div class="col-md-12"&gt; &lt;form&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2. 修改views文件添加具体要执行的业务内容 12345# app01/views.pyfrom django.shortcuts import renderdef demo01(request): # 参数1固定的，参数2为模块文件，具体可看render源码（最终返回一个HttpResponse对象） return render(request, 'demo01.html') 3. 配置Settings为了让django知道我们的html文件在哪里，需要修改settings文件的相应内容。 123456789101112131415161718# djangostart/settings.pyTEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 修改此处，让Django到这里的目录找html模板文件 'DIRS': [os.path.join(BASE_DIR, 'templates')], # APP_DIRS为True时，会自动去INSTALLED_APPS应用的templates查找html文件 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.Template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 4.保存()ctrl+s 5. 启动web服务查看结果：能够正确找到html文件，但是静态文件似乎没有加载（F12查看） 6. 使用静态文件（用bootstrap写一个信息录入页面）在django中，一般将静态文件放在static目录中.接下来，在mysite/app01中新建个static目录并准备好资源. 准备静态文件 Jquery为网络资源 Bootstrap相关的为本地资源 放到./static目录： 所有静态文件（css/js/imgs）都可以放到这个目录 7. settings配置：站点的配置信息都在这里12345678# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.11/howto/static-files/# 静态文件以/static/开头STATIC_URL = '/static/'# 静态文件查找路径，注意不要写错参数名STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static')] STATIC_URL是指引用名，不是具体的目录，HTML文件中静态文件名字需要与它对应, 表示哪种文件会被识别成静态文件 STATICFILES_DIR去这里配置的目录下找静态文件(注意此处为list or tuple否则加载静态文件会报错) 8. 修改html文件中的引用123456# 修改前&lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt;&lt;script src="js/bootstrap.Min.js"&gt;&lt;/script&gt;# 修改后&lt;link href="/static/css/bootstrap.min.css" rel="stylesheet"&gt;&lt;script src="/static/js/bootstrap.min.js"&gt;&lt;/script&gt; 9. 重新启动web服务刷新浏览器，查看结果. 10.修改模板文件 文件：templates/demo01.html input添加name from表单的几个要素：methodmethod=get 11.修改视图函数12345678910# app01/views.pyfrom django.shortcuts import renderdef demo01(request): print(request.method) if request.method == 'POST': username = request.POST.get("username") password = request.POST.get("password") user = &#123;'username':username, 'password':password&#125; return render(request, 'demo01.html', &#123;'user': user&#125;) 12. 浏览器测试输入用户名，密码 要在浏览器上可以看到提交的信息, 浏览器上要做以下渲染 django采用自己的模板语言，类似jinja2，根据提供的数据，替换掉html中的相应部分。 1234&lt;hr/&gt;用户信息：&#123;&#123;user&#125;&#125;&lt;br/&gt;用户名：&#123;&#123;user.username&#125;&#125;&lt;br/&gt;密码：&#123;&#123;user.password&#125;&#125; 13. POST方式会有一个跨站请求保护机制 可将form表单提交方式分别设置成GET、POST方式 Post方式提交时，出错，因为django有一个跨站请求保护机制，我们目前可在settings文件中将它关闭。 修改settings设置，暂时先取消使用这个中间件， 12345678910# djangostart/settings.pyMIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 14.登录页面 修改djangostart/urls.py 修改djangostart\app01\views.py 在此路径下添加一个html页面（注意要与views.py的return文件一样） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="/static/app01/css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;简单的表单提交&lt;/h1&gt; &lt;div class="col-md-5"&gt; &#123;% csrf_token %&#125; &lt;form method="post"&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputEmail1"&gt;Email address&lt;/label&gt; &lt;input name="email" type="email" class="form-control" id="exampleInputEmail1" placeholder="Email"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputPassword1"&gt;Password&lt;/label&gt; &lt;input name="password" type="password" class="form-control" id="exampleInputPassword1" placeholder="Password"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label for="exampleInputFile"&gt;File input&lt;/label&gt; &lt;input type="file" id="exampleInputFile"&gt; &lt;p class="help-block"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class="checkbox"&gt; &lt;label&gt; &lt;input type="checkbox"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type="submit" class="btn btn-default"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="/static/app01/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 用户名密码正确 错误则返回登录页面]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>返回HTML页面</tag>
        <tag>登录页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django初探-01]]></title>
    <url>%2F2019%2F07%2F24%2Fweb%E5%BC%80%E5%8F%91%2Fdjango%E5%88%9D%E6%8E%A2-01%2F</url>
    <content type="text"><![CDATA[1. 常用命令 django-admin: 常用来创建项目及应用 123456789101112131415161718192021222324252627Type 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django]checkcompilemessagescreatecachetabledbshelldiffsettingsdumpdataflushinspectdbloaddatamakemessagesmakemigrationsmigraterunserversendtestemailshellshowmigrationssqlflushsqlmigratesqlsequenceresetsquashmigrationsstartappstartprojecttesttestserver manage.py：常用来管理项目，如运行开发环境，数据库操作，用户操作等 12345678910111213141516171819202122232425262728293031323334353637Type 'manage.py help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[auth] changepassword createsuperuser[contenttypes] remove_stale_contenttypes[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver[sessions] clearsessions[staticfiles] collectstatic findstaticrunserver 2. 创建项目 创建项目 ： django-admin startproject djangostart 创建应用：cd djangostart;django-admin startapp app01 在项目目录下djangostart下创建app01 3. 站点结构解析 将apps目录加入到全局搜索路径(mark as-source) 找到setting.py文件，添加app01 Django功能目录介绍 .git 配置、版本历史 gitignore 忽略某些文件（不检查编号，不上传git仓库） Django的APP以及目录介绍 __init__.py:初始化文件 setting.py:配置文件 urls.py:拥有强大的路由系统，做路由的（地址栏） wsgi.py:web网关服务接口,连接webserver和application的接口 manage.py：常用来管理项目，如运行开发环境，数据库操作，用户操作等 admin.py:Django有一个非常强大的后台管理系统，通过这个文件，来连接 apps.oy:对本项目做一些配置的文件 models.py:模型层，和数据库相关的东西都放在这里面 tests.py:测试用例放在里面 views.py:视图文件 4.编写一个最简单的页面 编写路由（路由都在urls文件里，它将浏览器输入的url映射到相应的业务处理逻辑。） 12345678910# mysite/urls.pyfrom django.conf.urls import urlfrom django.contrib import adminfrom app1 import viewsurlpatterns = [ # admin后台路由 url(r'^admin/', admin.site.urls), # 自定义路由 url(r'^demo01/', views.demo01),] 编写业务处理逻辑（业务处理逻辑都在views.py文件里） 12345678910# app1/views.pyfrom django.shortcuts import renderfrom django.shortcuts import HttpResponse# request 必填，名字可以修改，封装了用户请求的所有内容def demo01(request): html = '&lt;h1&gt;i am demo01&lt;/h1&gt;' print(html) # 此处不能直接return html, 必须返回一个HttpResponse对象 return HttpResponse(html) 运行web服务 命令行执行python manage.py runserver 127.0.0.1:8000 或者鼠标选中整个项目，然后点三角形 404页面 Django的错误页，非常重要的排错依据，务必仔细阅读 错误原因：地址栏应该是127.0.0.1:8000/demo01]]></content>
      <categories>
        <category>python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>站点解析</tag>
        <tag>简单页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求响应流程]]></title>
    <url>%2F2019%2F07%2F23%2Fweb%E5%BC%80%E5%8F%91%2F%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[MVC模式 模型（M）:定义数据库相关的内容，负责业务对象与数据库的映射（ORM） 视图（V）:定义HTML等静态网页文件相关，负责与用户的交互（页面） 控制器（C）:定义业务逻辑相关，就是你的主要代码，负责接收用户的输入调用模型和视图完成用户的请求 Django的MTV模式 M代表模型（Model）：负责业务对象和数据库的关系映射（ORM）（如何存取，如何验证有效性，包含哪些行为以及数据之间的关系等） T代表模板（Template）：负责如何把页面展示给用户（html） V代表视图（View）：负责业务逻辑，并在适当时候调用Model和Template MVC/MVT设计模式关键的优势 开发者更改一个应用程序中的URL而不用影响到这个程序底层的实现 设计师可以改变HTML页面的样式而不用接触业务逻辑代码 数据库管理员可以重新命名数据表并且只需更改模型 请求响应流程图（简版） 请求响应流程图（复杂版） 前面的图片展示了从一个访客的浏览器到Django应用并返回的一个web请求的简单历程。如下是数字标识的路径： 浏览器发送请求（基本上是字节类型的字符串）到web服务器 web服务器（比如，Nginx）把这个请求转交到一个WSGl（比如，uWSGl），或者直接地文件系统能够取出一个文件（比如，一个CSS文件） 不像web服务器那样，WSGl服务器可以直接运行Python应用。请求生成一个被称为environ的Ptyhon字典，而且，可以选择传递过去几个中间件的层，最终，达到Diango应用 URLconf中含有属于应用的urls.py选择一个视图处理基于请求的URL的那个请求，这个请求就已经变成了 HttpRequest——一个Python字典对象 被选择的那个视图通常要做下面所列出的一件或者更多件事情： A. 通过模型与数据库对话 B. 使用模板渲染HTML或者任何格式化过的响应 C. 返回一个纯文本响应（不被显示的） D. 抛出一个异常 HttpResponse对象离开Django后，被渲染为一个字符串 在浏览器见到一个美化的，渲染后的web页面]]></content>
      <categories>
        <category>python</category>
        <category>Django请求响应流程</category>
      </categories>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django介绍]]></title>
    <url>%2F2019%2F07%2F23%2Fweb%E5%BC%80%E5%8F%91%2FDjango%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[Django介绍1).Django历史 源自于一个在线新闻Web站点，于2005年以开源的形式被释放出来。 官网：https://www.djangoproject.com/?tdsourcetag=s_pcqq_aiomsg 2).Django特点 主要目的是简便、快速地开发数据库驱动的网站 功能丰富：自带ORM、URL分发、模板系统、表单处理、Cache系统、会话管理、国际化、后台管理 可扩展：pypi及git上有很多基于Django开发的应用 3).Django优缺点 优点 完美的文档 全套的解决方案 强大的URL路由配置 自助管理后台 缺点 系统紧耦合，灵活性差 4).关于性能 性能问题最常出现在数据库访问和文件读写上（磁盘） 没有一定的访问量前谈性能其实是没有多大意义的 人力成本才是最贵的（21世纪，人才最贵）]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django基本介绍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github创建Djanggo项目流程]]></title>
    <url>%2F2019%2F07%2F23%2Fweb%E5%BC%80%E5%8F%91%2Fgithub%E5%88%9B%E5%BB%BADjanggo%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Git创建Django项目及其配置 在GitHub上创建一个仓库，后期所有代码都上传到Django_learning这个仓库 克隆仓库到本地，做好相关配置 git clone https://github.com/chenxl18/Django-learning.git 初始化Git git init 基于master新建一个分支： $ git checkout -b v0.1-django-start 在v0.1分支创建虚拟环境: $ python -m venv venv 进入虚拟环境 $ source venv/Scripts/activate 在虚拟环境下安装Django pip install django==1.11.20 配置虚拟环境（将虚拟环境下的安装包写入此文件） pip freeze &gt; requirements.txt 退出虚拟环境 deactivate 修改.gitignore文件 .idea/ venv/ 把改动提交到仓库 12345678910$ git status# 查看状态$ git add requirements.txt# 标记requirements.txt$ git add .gitignore# 标记.gitignore$ git commit -m 'env init'# 提交到远程仓库的注释信息$ git push --set-upstream origin v0.1-django-start# 配置提交的远程分支 把不需要的文件提交到了远程仓库怎么办？ 改.gitignore文件 mv venv01 /tmp 提交一次（git add,git commit,git push） mv /tmp venv01 提交一次（git add,git commit,git push）]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP和LNMP]]></title>
    <url>%2F2019%2F07%2F13%2Flinux%2FLAMP%E5%92%8CLNMP%2F</url>
    <content type="text"><![CDATA[LAMP和LNMPLNMP:（一种开发环境） linux nginx MySQL php/python/perl(php是一门语言，专门写网站) zabbix (监控软件)–&gt;php–&gt;LANP LAMP: linux apache(httpd) MySQL(mariadb) php/python/perl 为什么企业非常喜欢使用LAMP/LNMP 因为免费并且开源 成本低廉（吸引人的地方） 搭建一个自己的网站​ nginx：Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 apache和nginx的差异？ 安装、软件名字 apache的提供服务的软件包名叫httpd，nginx的叫nginx 市场上的占有率 apache比nginx多 apache出来的时间早 ，nginx是后起之秀 工作原理：apache采用进程，nginx采用线程（线程更省资源，进程更稳定） 软件功能和大小 apache功能多（ 重量级），代码多 轻量级的web服务器软件（nginx） 讲讲配置项的差异 Server: BWS/1.1 安装：yum 安装可以使用epel源或者官方源 123456789101112131415[root@sanchuang ~]# yum install epel-release -y[root@sanchuang ~]# cd /etc/yum.repos.d/[root@sanchuang yum.repos.d]# lsCentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo epel-testing.repoCentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo epel.repo[root@sanchuang yum.repos.d]# vim nginx.repo[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[root@sanchuang yum.repos.d]# yum install nginx -y[root@sanchuang nginx]# pwd/etc/nginx 123456789101112131415nginx.conf --》主配置文件[root@sanchuang ~]# yum install httpd -y[root@sanchuang ~]# cd /etc/httpd/ 存放配置文件的路径[root@sanchuang httpd]# lsconf conf.d conf.modules.d logs modules run[root@sanchuang httpd]# cd conf[root@sanchuang conf]# lshttpd.conf magic配置文件的路径： serverroot nginx --》/etc/nginx/nginx.conf httpd --&gt;/etc/httpd/conf/httpd.conf存放网页的路径： documentroot httpd --》DocumentRoot "/var/www/html" nginx --》root /usr/share/nginx/html;配置文件对比 进程和线程方式 location --》路由 对某个目录进行权限的设置 12345&lt;Directory "/var/www"&gt; AllowOverride None # Allow open access: Require all granted&lt;/Directory&gt; 注：将welcome.conf 删除，这样httpd的网站根目录就成了一个ftp服务器，可以下载文件 httpd.conf配置部分解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@sanchuang conf]# cat httpd.conf |egrep -v "^#|^$|\s+#"ServerRoot "/etc/httpd" --》安装的目录Listen 8080 --》监听的端口号Include conf.modules.d/*.conf --》包括其他的配置文件User apache 启动进程使用的用户Group apache 启动进程使用的组ServerAdmin root@localhost 管理员的邮箱&lt;Directory /&gt; AllowOverride none Require all denied&lt;/Directory&gt;DocumentRoot "/var/www/html" --》存放网页目录&lt;Directory "/var/www"&gt; AllowOverride None Require all granted&lt;/Directory&gt;&lt;Directory "/var/www/html"&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt;&lt;IfModule dir_module&gt; DirectoryIndex index.html --》规定网站的首页 DirectoryIndex shouye.html index.html index.php 指定多个首页文件，按从左到右的顺序，去查询&lt;/IfModule&gt;&lt;Files ".ht*"&gt; Require all denied&lt;/Files&gt;ErrorLog "logs/error_log"LogLevel warn&lt;IfModule log_config_module&gt; LogFormat "%h %l %u %t \"%r\" %&gt;s %b \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\"" combined LogFormat "%h %l %u %t \"%r\" %&gt;s %b" common &lt;IfModule logio_module&gt; LogFormat "%h %l %u %t \"%r\" %&gt;s %b \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\" %I %O" combinedio &lt;/IfModule&gt; CustomLog "logs/access_log" combined&lt;/IfModule&gt;&lt;IfModule alias_module&gt; ScriptAlias /cgi-bin/ "/var/www/cgi-bin/" Alias /chenxianle "/var/www/html/chenxianle" # 访问的url 192.168.0.241:8080/chenxianle 会自动访问/var/www/html/chenxianle目录里的网页&lt;/IfModule&gt;&lt;Directory "/var/www/cgi-bin"&gt; AllowOverride None Options None Require all granted&lt;/Directory&gt;&lt;IfModule mime_module&gt; TypesConfig /etc/mime.types AddType application/x-compress .Z AddType application/x-gzip .gz .tgz AddType text/html .shtml AddOutputFilter INCLUDES .shtml&lt;/IfModule&gt;AddDefaultCharset UTF-8&lt;IfModule mime_magic_module&gt; MIMEMagicFile conf/magic&lt;/IfModule&gt;EnableSendfile onIncludeOptional conf.d/*.conf[root@sanchuang conf]# 搭建一个网站： 1.apache --》8080 ---》www.dinglang.com 2.nginx --》80 ---&gt;www.jack.comnginx里的配置文件/etc/hosts windows里的主配置文件C:\Windows\System32\drivers\etc\hosts apache和nginx都是对静态页面的支持 apache如何支持php写的程序 nginx如何知道python写的程序 动静分离： 静态页面---》nginx 动态页面 --》php/python 通过url来实现识别 静态页面和动态页面的区别？ 是否有后端程序去数据库里读写数据，数据的变化 12345[root@sanchuang conf.modules.d]# vim 00-mpm.conf LoadModule mpm_prefork_module modules/mod_mpm_prefork.soStartServers 50ServerLimit 256MaxSpareServers 10 核心特性与多处理模块(MPM)—》apache 1.prefork ：预先产生进程，等着客户来访问 ——》apache默认的处理模式 StartServers 200 ：启动多少进程数 MinSpareServers ：最少备用的进程数 MaxSpareServers 20 ：最多备用的进程数 MaxRequestWorkers ： 同时最多可以有多少请求数 MaxConnectionsPerChild ： 一个进程可以处理多少次的请求 ServerLimit 256 ：最多支持256个访问量 进程：优点：稳定。缺点：消耗资源（内存、cpu） 2.worker：多进程和多线程混合的模式 multi-threaded multi-process web server 1234567ServerLimit 16StartServers 2MaxRequestWorkers 150MinSpareThreads 25MaxSpareThreads 75ThreadsPerChild 25zabbix --》 3.event ：纯线程处理模式 ：event MPM: A variant of the worker MPM with the goal of consuming threads only for connections with active processing（默认nginx处理模式） 如何验证？ 模拟同时1000人去访问 压力测试 服务器的瓶颈在哪里？ 资源的角度：cpu、内存、网络带宽、磁盘IO ab—apache压力测试软件（httpd自带的软件，不需要下载） 12345678910111213141516[root@sanchuang ~]# ab -c 10000 -n 10000 http://192.168.0.241/root/index.htmlThis is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking 192.168.0.241 (be patient)socket: Too many open files (24)[root@sanchuang ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 7221max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024 默认内核允许一个进程最多可以打开1024个文件 123456789101112131415161718[root@sanchuang ~]# ulimit -n 100000 临时修改内核允许的一个进程可以打开多少文件数量的限制[root@sanchuang ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 7221max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 100000pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 7221virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 查看nginx日志（哪个ip地址xshell使用nginx测试的次数） 1234567891011121314[root@sanchuang nginx]# cat access.log |awk '&#123;print $1&#125;'|sort |uniq -c 32 192.168.0.102 38 192.168.0.104 50 192.168.0.126 17 192.168.0.13 4 192.168.0.140 8051 192.168.0.152 8 192.168.0.155 102 192.168.0.208 3577 192.168.0.241 4 192.168.0.35 72 192.168.0.41 5 192.168.0.50 6 192.168.0.61]]></content>
      <categories>
        <category>linux高阶</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
        <tag>LAMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上下文管理器]]></title>
    <url>%2F2019%2F07%2F11%2Fpython%2F%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[闭包与装饰器]]></title>
    <url>%2F2019%2F07%2F10%2Fpython%2F%E9%97%AD%E5%8C%85%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是闭包 在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。 闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。 在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 形成闭包的三个条件，缺一不可： 必须有一个内嵌函数（函数里定义的函数）——这对应函数之间的嵌套 内嵌函数必须引用一个定义在闭合范围内（外部函数里）的变量——内部函数引用外部变量 外部函数必须返回内嵌函数——必须返回那个内部函数 闭包的概念很简单：一个可以引用在函数闭合范围内变量的函数。即”内部函数”，只有那个内部函数才有所谓的__closure__属性。 Python 变量作用域的规则是 LEGB LEGB含义解释： L —— Local(function)；函数内的名字空间 通过 locals() 可以查看 Local 的所有变量 E —— Enclosing function locals；外部嵌套函数的名字空间(例如closure) G —— Global(module)；函数定义所在模块（文件）的名字空间、 通过 globals() 可以查看 globals 的所有变量。 1234import syssys.int_infoOutput:sys.int_info(bits_per_digit=30, sizeof_digit=4) - 调用模块时，就需要指定路径 - B —— Builtin(Python)；Python内置模块的名字空间 - Python 自带的 内置命名空间，主要是 内置函数，异常类 等。可以通过 ` dir(__builtins__)`来查看 - 该部分的部分一般情况不应该修改。 - 真正修改/删除 或 新增时，需要`__builtins__.****`来指定 - 可以在本地增加同名的命名，由于 Locals 和 Global 优先于 builtin，该命名的优先级就高于 Builtin 了 闭包 形成闭包之后，闭包函数会获得一个非空的__closure__属性（对比我们最后的函数test，test是一 个不具备闭包的函数，它的__closure__属性是None），这个属性是一个元组。 元组里面的对象为cell对象，而访问cell对象的cell_contents属性则可以得到闭包变量的当前值 （即上一次调用之后的值）。 而随着闭包的继续调用，变量会再次更新。 所以可见，一旦形成闭包之后，python确实会将__closure__和闭包函数绑定作为储存闭包变量的 场所 123456789101112131415#定义一个包含斜率、截距、X坐标三参数的直线方程函数f(x)=kx+bdef funx(k=3, b=4): def funy(x): y = k * x + b print(y) return funyline = funx(5,3)line(1)line(2)Output:8131823 闭包的好处 闭包不是必须的 没了闭包，python的功能一点都不会被影响 有了闭包，只是给你一种额外的解决方法 1234567891011121314151617181920212223242526#实现统计函数运行时间import timedef cost(func): def _cost(*args,**kwargs): start = time.time() ret = func(*args,**kwargs) cost = time.time() - start print(f"&#123;func.__name__&#125;函数花费&#123;cost&#125;秒") return ret return _cost@costdef line(x,k=1,b=-4): time.sleep(1) return k*x+b@costdef add(a,b): time.sleep(1) return a+bprint(add(1,2))print(line(2))Output:add函数花费1.000878095626831秒3line函数花费1.0009534358978271秒-2 什么是装饰器？ 装饰器是这样一种设计模式：如果一个类（函数）希望添加其他类（函数）的一些功能，而不希望 通过继承或是直接修改源代码实现，那么可以使用装饰器模式 简单来说Python中的装饰器就是指某些函数或其他可调用对象，以函数或类作为可选输入参数， 然后返回函数或类的形式。通过这个在Python2.6版本中被新加入的特性可以用来实现装饰器设计 模式。 装饰器就是一个可以接受调用也可以返回调用的函数，该函数接受被装饰的函数作为其位置参数。 装饰器通过使用该参数来执行某些操作，然后返回原始参数或一些其他的调用 函数也是对象，也可以当做参数传递 装饰器有什么用？ 你可以考虑在装饰器中置入通用功能的代码来降低程序复杂度 引入日志 增加计时逻辑来检测性能 给函数加入事务的能力 权限控制 123456789101112131415161718192021222324252627282930# 用装饰器实现权限控制# 定义一个全局变量：username，定义add函数，实现两个数相加# 实现login_required装饰器，如果username值为root，提示"欢迎"并计算结果，否则"没有权限"username = input("请输入你的用户名")def login_required(func): def dec(*args,**kwargs): if username == "root": print("欢迎") ret = func(*args,**kwargs) return ret else: raise PermissionError("没有权限") return dec@login_requireddef add(a,b): return a+bprint(add(1,2))Output(true):请输入你的用户名root欢迎3Output(false):请输入你的用户名123Traceback (most recent call last): File "E:/python/python study/python高阶/闭包与装饰器/闭包.py", line 173, in &lt;module&gt; print(add(1,2)) File "E:/python/python study/python高阶/闭包与装饰器/闭包.py", line 168, in dec raise PermissionError("没有权限")PermissionError: 没有权限 编写和使用装饰器 123456789101112131415161718# 应用多个装饰器# 定义两个装饰器(log, cost)# 定义一个函数(add)，将两个装饰器应用到该函数import timedef log(func): def _log(*args,**kwargs): now = time.strftime("%Y-%m-%d %X",time.localtime()) ret = func(*args,**kwargs) print(f"在&#123;now&#125;执行了&#123;func.__name__&#125;函数") return ret return _log@logdef add(a,b): return a + bprint(add(1,10))Output:在2019-07-10 20:42:23执行了add函数11 1234567891011121314151617#上一题的另一种方法（通过调用logging模块）import loggingimport timedef log(func): logging.basicConfig(format='%(asctime)s:%(name)s:%(message)s',level=logging.DEBUG) def _log(*args,**kwargs): ret = func(*args,**kwargs) logging.info(f"执行了&#123;func.__name__&#125;函数") return ret return _log@logdef add(a,b): return a+bprint(add(1,6))Output:72019-07-10 20:52:28,752:root:执行了add函数 多个装饰器装饰类 调用是自上而下 封装是自下而上 在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录 @login_required ， 再验证权限够不够时 @permision_allowed 什么是元数据？ 元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是 描述数据属性（property）的信息 函数的重要的元信息比如名字、文档字符串、注解和参数签名等 装饰器后，为什么元数据会丢失？ 因为return执行的，是经过调用封装后的函数 保留元数据 利用@functools.wraps(fun)，将一个函数的重要内容复制到另一个函数 提醒：任何时候你定义装饰器的时候,都应该使用 functools 库中的 @wraps 装饰器来注解底层 包装函数。（需要import functolls） 用类实现装饰器 1234567891011121314151617181920212223242526#定义一个类logging实现记录日志的装饰器#装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了__call__()方法，那么这个对象就是callable的。class log(object): def __init__(self,func): print("封装log功能") self.func = func def __call__(self, *args, **kwargs): print("记一条日志~~") ret = self.func(*args,**kwargs) return ret@logdef add(a,b): return a+bprint(add(1,3))print(add(1,3))print(add(1,3))Output:封装log功能记一条日志~~4记一条日志~~4记一条日志~~4 用类实现装饰器(带参数) 123456789101112131415161718192021222324252627#定义一个类logging实现记录日志的装饰器（带参数同时保留了元数据）import functoolsclass log2(object): def __init__(self,level="DEBUG"): self.level = level def __call__(self,func): @functools.wraps(func) def _dec(*args,**kwargs): print(f"[&#123;self.level&#125;]记一条日志") return func(*args,**kwargs) return _dec@log2(level="INFO")def add(a,b): return a+bprint(add(1,3))print(add(1,3))print(add(1,3))Output:[INFO]记一条日志4[INFO]记一条日志4[INFO]记一条日志4 1234567891011121314151617181920212223242526272829303132333435#定义一个装饰器sorted_by_create_time实现装饰类的装饰器#装饰器的功能：按创建时间将实例进行排序import timedef sorted_by_createtime(cls): origin_init = cls.__init__ def new_init(self, *args, **kwargs): self.create_time = time.time() origin_init(self,*args, **kwargs) cls.__init__ = new_init cls.__lt__ = lambda self, other: self.create_time &lt; other.create_time return cls@sorted_by_createtimeclass Sortable(object): def __init__(self, id): self.id = id def __str__(self): return f"str:&#123;self.id&#125;" def __repr__(self): return f"repr:&#123;self.id&#125;"a = Sortable(1)time.sleep(1)b = Sortable(2)time.sleep(1)c = Sortable(3)li = [c, b, a]print(sorted(li))Output:[repr:3, repr:2, repr:1] 内置的装饰器 Python还提供了类装饰器与@staticmethod，@classmethod，@property和这三个在面向对象编程中常用的装饰器 staticmethod：把类中定义的实例方法变成静态方法 classmethod：把类中定义的实例方法变成类方法 property：把类中定义的实例方法变成类属性。 为什么使用装饰器？ 模块化且清晰明确 代码重用 装饰器是显式的，增强可读性 装饰器的应用：Python标准库中包括很多包含装饰器的模块，并且很多常用工具和框架利用它们实现常功能 要使用一个类上的方法不需要这个类的实例(@classmethod或@staticmethod) mock模块（单元测试python3.3后加入标准库-@mock.patch或@mock.patch.object） Django(@login_required, @permission_reqired) Flask(@app.route) 充当url与函数之间的注册表 Celery(@task) 返回Task类实例 插入日志、性能测试、事务处理、缓存、权限校验等场景 记录结果、增加计时逻辑来检测性能等 小练习 实现函数注册表：所有被装饰的函数都放到registry列表中 12345678910111213141516register = []def register1(func): def _dec(*args,**kwargs): register.append(func.__name__) ret = func(*args,**kwargs) print(register) return ret return _dec@register1def add(a,b): return a+bprint(add(1,8))Output:['add']9 将被装饰函数的结果转json格式：默认返回列表/字典格式 12345678910111213141516import jsondef json1(func): def _dec(*args,**kwargs): ret = func(*args,**kwargs) r = json.dumps(ret) print(type(r)) return r return _dec@json1def add(a,b): return a+bprint(add(1,8))Output：&lt;class 'str'&gt;9 一个简单的日志管理功能：记录所有函数名，执行时间，执行耗时等 12345678910111213141516171819import timedef log(func): def _log(*args,**kwargs): start = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()) start_now = time.time() ret = func(*args,**kwargs) cost = time.time() - start_now print(f"&#123;start&#125;执行&#123;func.__name__&#125;函数,执行耗时：&#123;cost&#125;\n执行结果：&#123;json.dumps(ret)&#125;") return json.dumps(ret) return _log@logdef add(a,b): time.sleep(1) return a+badd(1,7)Output:2019-07-11 20:46:29执行add函数,执行耗时：1.000678539276123执行结果：8 补充知识（模块）time模块 time模块中时间表现的格式主要有三种： timestamp时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量 struct_time时间元组，共有九个元素组。 format time 格式化时间，已格式化的结构使时间更具可读性。包括自定义格式和固定格式。 主要time生成方法和time格式转换方法实例： 123456789101112131415161718192021222324252627282930313233import time# 生成timestamptime.time()# 1477471508.05#struct_time to timestamptime.mktime(time.localtime())#生成struct_time# timestamp to struct_time 本地时间time.localtime()time.localtime(time.time())# time.struct_time(tm_year=2016, tm_mon=10, tm_mday=26, tm_hour=16, tm_min=45, tm_sec=8, tm_wday=2, tm_yday=300, tm_isdst=0)# timestamp to struct_time 格林威治时间time.gmtime()time.gmtime(time.time())# time.struct_time(tm_year=2016, tm_mon=10, tm_mday=26, tm_hour=8, tm_min=45, tm_sec=8, tm_wday=2, tm_yday=300, tm_isdst=0)#format_time to struct_timetime.strptime('2011-05-05 16:37:06', '%Y-%m-%d %X')# time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=16, tm_min=37, tm_sec=6, tm_wday=3, tm_yday=125, tm_isdst=-1)#生成format_time#struct_time to format_timetime.strftime("%Y-%m-%d %X")time.strftime("%Y-%m-%d %X",time.localtime())# 2016-10-26 16:48:41#生成固定格式的时间表示格式time.asctime(time.localtime())time.ctime(time.time())# Wed Oct 26 16:45:08 2016 struct_time元组元素结构 属性 值 tm_year（年） 比如2011 tm_mon（月） 1 - 12 tm_mday（日） 1 - 31 tm_hour（时） 0 - 23 tm_min（分） 0 - 59 tm_sec（秒） 0 - 61 tm_wday（weekday） 0 - 6（0表示周日） tm_yday（一年中的第几天） 1 - 366 tm_isdst（是否是夏令时） 默认为-1 format time结构化表示 格式 含义 %a 本地（locale）简化星期名称 %A 本地完整星期名称 %b 本地简化月份名称 %B 本地完整月份名称 %c 本地相应的日期和时间表示 %d 一个月中的第几天（01 - 31） %H 一天中的第几个小时（24小时制，00 - 23） %I 第几个小时（12小时制，01 - 12） %j 一年中的第几天（001 - 366） %m 月份（01 - 12） %M 分钟数（00 - 59） %p 本地am或者pm的相应符 %S 秒（01 - 61） %U 一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。 %w 一个星期中的第几天（0 - 6，0是星期天） %W 和%U基本相同，不同的是%W以星期一为一个星期的开始。 %x 本地相应日期 %X 本地相应时间 %y 去掉世纪的年份（00 - 99） %Y 完整的年份 %Z 时区的名字（如果不存在为空字符） %% %字符 常见结构化时间组合： 12print time.strftime("%Y-%m-%d %X")#2016-10-26 20:50:13 time加减 1234567#timestamp加减单位以秒为单位import timet1 = time.time()t2=t1+10print time.ctime(t1)#Wed Oct 26 21:15:30 2016print time.ctime(t2)#Wed Oct 26 21:15:40 2016 datetime模块：datatime模块重新封装了time模块，提供更多接口，提供的类有：date,time,datetime,timedelta,tzinfo。 date类 datetime.date(year, month, day) 静态方法和字段 date.max、date.min：date对象所能表示的最大、最小日期； date.resolution：date对象表示日期的最小单位。这里是天。 date.today()：返回一个表示当前本地日期的date对象； date.fromtimestamp(timestamp)：根据给定的时间戮，返回一个date对象； 12345678910111213from datetime import *import timeprint 'date.max:', date.maxprint 'date.min:', date.minprint 'date.today():', date.today()print 'date.fromtimestamp():', date.fromtimestamp(time.time())#Output======================# date.max: 9999-12-31# date.min: 0001-01-01# date.today(): 2016-10-26# date.fromtimestamp(): 2016-10-26 方法和属性 d1 = date(2011,06,03)#date对象 d1.year、date.month、date.day：年、月、日； d1.replace(year, month, day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变） d1.timetuple()：返回日期对应的time.struct_time对象； d1.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推； d1.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推； d1.isocalendar()：返回格式如(year，month，day)的元组； d1.isoformat()：返回格式如’YYYY-MM-DD’的字符串； d1.strftime(fmt)：和time模块format相同。 1234567891011121314151617181920from datetime import *now = date(2016, 10, 26)tomorrow = now.replace(day = 27)print 'now:', now, ', tomorrow:', tomorrowprint 'timetuple():', now.timetuple()print 'weekday():', now.weekday()print 'isoweekday():', now.isoweekday()print 'isocalendar():', now.isocalendar()print 'isoformat():', now.isoformat()print 'strftime():', now.strftime("%Y-%m-%d")#Output========================# now: 2016-10-26 , tomorrow: 2016-10-27# timetuple(): time.struct_time(tm_year=2016, tm_mon=10, tm_mday=26, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=300, tm_isdst=-1)# weekday(): 2# isoweekday(): 3# isocalendar(): (2016, 43, 3)# isoformat(): 2016-10-26# strftime(): 2016-10-26 time类 datetime.time(hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ) 静态方法和字段 time.min、time.max：time类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999)； time.resolution：时间的最小单位，这里是1微秒； 方法和属性 t1 = datetime.time(10,23,15)#time对象 t1.hour、t1.minute、t1.second、t1.microsecond：时、分、秒、微秒； t1.tzinfo：时区信息； t1.replace([ hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )：创建一个新的时间对象，用参数指定的时、分、秒、微秒代替原有对象中的属性（原有对象仍保持不变）； t1.isoformat()：返回型如”HH:MM:SS”格式的字符串表示； t1.strftime(fmt)：同time模块中的format； 12345678910111213141516from datetime import *tm = time(23, 46, 10)print 'tm:', tmprint 'hour: %d, minute: %d, second: %d, microsecond: %d' % (tm.hour, tm.minute, tm.second, tm.microsecond)tm1 = tm.replace(hour=20)print 'tm1:', tm1print 'isoformat():', tm.isoformat()print 'strftime()', tm.strftime("%X")#Output==============================================# tm: 23:46:10# hour: 23, minute: 46, second: 10, microsecond: 0# tm1: 20:46:10# isoformat(): 23:46:10# strftime() 23:46:10 datetime类 datetime相当于date和time结合起来。datetime.datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ) 静态方法和字段 datetime.today()：返回一个表示当前本地时间的datetime对象； datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间； datetime.utcnow()：返回一个当前utc时间的datetime对象；#格林威治时间 datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息； datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象； datetime.combine(date, time)：根据date和time，创建一个datetime对象； datetime.strptime(date_string, format)：将格式字符串转换为datetime对象； 123456789101112131415161718192021from datetime import *import timeprint 'datetime.max:', datetime.maxprint 'datetime.min:', datetime.minprint 'datetime.resolution:', datetime.resolutionprint 'today():', datetime.today()print 'now():', datetime.now()print 'utcnow():', datetime.utcnow()print 'fromtimestamp(tmstmp):', datetime.fromtimestamp(time.time())print 'utcfromtimestamp(tmstmp):', datetime.utcfromtimestamp(time.time())#output======================# datetime.max: 9999-12-31 23:59:59.999999# datetime.min: 0001-01-01 00:00:00# datetime.resolution: 0:00:00.000001# today(): 2016-10-26 23:12:51.307000# now(): 2016-10-26 23:12:51.307000# utcnow(): 2016-10-26 15:12:51.307000# fromtimestamp(tmstmp): 2016-10-26 23:12:51.307000# utcfromtimestamp(tmstmp): 2016-10-26 15:12:51.307000 方法和属性 12345678910111213dt=datetime.now()#datetime对象dt.year、month、day、hour、minute、second、microsecond、tzinfo：dt.date()：获取date对象；dt.time()：获取time对象；dt. replace ([ year[ , month[ , day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ] ] ])：dt. timetuple ()dt. utctimetuple ()dt. toordinal ()dt. weekday ()dt. isocalendar ()dt. isoformat ([ sep] )dt. ctime ()：返回一个日期时间的C格式字符串，等效于time.ctime(time.mktime(dt.timetuple()))；dt. strftime (format) 参考资料:https://www.cnblogs.com/tkqasn/p/6001134.html]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>logging模块</tag>
        <tag>闭包与装饰器</tag>
        <tag>time模块</tag>
        <tag>datetime模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python笔试面试题]]></title>
    <url>%2F2019%2F07%2F09%2Fpython%2Fpython%E7%AC%94%E8%AF%95%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[python面试笔试题 1.metaclass作用？以及引用场景？ metaclass是元类，创建类的类 foo=&gt;阻止 FOO=&gt;foo 定制创建类的过程=&gt;添加一些自定义的逻辑 默认元类是type 2.魔法方法__call__怎么使用？ 12345class A(): passa = A()a(1,2,3) =&gt;调用a =&gt; a.__call__(self,*args,**kwargs)#如果没有__call__()会报错，不可调用 3.staticmethod、classmethod、property用法及功能? 装饰器：@名称 staticmethod：把类的一个方法封装成静态方法（） classmethod：把类的一个方法封装成类态方法（cls） property：把类的一个方法封装属性 4.__new__和__init__方法？ __init__：初始化实例=&gt;实例方法 __new__：创建并返回一个实例=&gt;必须与自己类相同类型的一个实例 5.python经典类与新式类的继承顺序？ 新式类：python3或由内置类型派生出来的类。 C3算法，A.mro() =&gt;方法解析顺序 1234class A(object): passclass B(A): pass 经典类：不是由内置类型派生出来的类（Python2） 深度优先方式 1234class A(): passclass B(A)： pass 注：广度优先：子节点顺序：从左到右 ​ 深度优先：子节点顺序：从左到右 6.面向对象中的一些特殊方法有哪些？如__call __str__：友好显示实例信息 1&lt;__main__.A object at 0x00000244EC33F940&gt; __eq__：判读两个对象是否相等,== __add__：两个对象相加,+ 12(self, other)a + b=&gt;a.__add__(b)=&gt;A.__add__(a,b) 7.python类中的self的具体含义是？ self代表类的实例，而非类。 self不必非写成self，但最好还是用self self总是指调用时的类的实例 在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。 8.写一个类，并让它尽可能多的支持操作符（+ - * / //% ** == &gt; &lt;） 123456789101112+:__add__-:__sub__*:__mul__/:__truediv__ 1/2 = 0.5(python3) 1/2 = 0(python2) 1.0/2 = 0.5(python2)//:__floordiv__ 1//2 = 0(python3)%:__mod__**:__pow__==:__eq__&gt;:__gt__&lt;:__lt__&gt;=:__ge__&lt;=:__le__ 9.类属性与实例属性是什么？区别和应用场景？ 类属性：写在类下面（不是方法中） 所有的实例共享类属性 实例属性：写在方法中（__init__） 每个实例拥有自己的实例属性 对象有类属性又有实例属性：先访问实例属性 10.什么情况下需要重载类的方法？ __init__没有参数，初始化对象要传参数 参数变化的时候 功能有变化 11.如何判断一个对象是函数还是方法？函数与方法的区别 type 和类绑定的是方法，和类没有绑定关系的就是函数 1234567891011121314151617181920212223242526272829303132In [1]: def fun():passIn [2]: type(fun)Out[2]: functionIn [4]: class A(object): ...: def a(self):pass ...: @staticmethod ...: def b():pass ...: @classmethod ...: def c(cls):pass ...:In [5]: type(A.a)Out[5]: functionIn [6]: type(A.b)Out[6]: functionIn [7]: type(A.c)Out[7]: methodIn [8]: a = A()In [9]: type(a.a)Out[9]: methodIn [10]: type(a.b)Out[10]: functionIn [11]: type(a.c)Out[11]: method 12.了解Documentation String吗？ py的最开始&quot;&quot;&quot;&quot;&quot;&quot; 函数、类、方法 注释 代码即文档 13.了解函数类型注解？ 类型的形式指定函数的参数类型 用 -&gt; 类型 的形式指定函数的返回值类型。Python 解释器并不会因为这些注解而提供额外的校验，没有任何的类型检查工作。也就是说，这些类型注解加不加，对你的代码来说没有任何影响。 14.是否可以在一句import中导入多个库？ 推荐使用 12import osimport sys 15.在给python模块命令的时候需要注意什么？ 不要跟内置的模块重名 不能以数字开头 字母和下划线 16.怎么规范代码？ PEP8 google python style 工具：PEP8，flake8,pycharm 17.python中的注释有几种？ #，注释单独写一行 &quot;&quot;&quot; &quot;&quot;&quot;函数写注释（多行注释） 18.请简述对python闭包和装饰器的理解 是一种设计模式 如果一个类（函数）希望添加其他类（函数）的一些功能，而不希望 通过继承或是直接修改源代码实现，那么可以使用装饰器模式。 19.装饰器可以干什么？有什么优缺点？ 模块化且清晰明确 代码重用 装饰器是显式的，增强可读性 缺点：不太容易理解 20.POST和GET的区别 POST的参数在http请求体中，GET的参数显示在地址栏 POST可以传很大的参数，GET长度2048 GET幂等操作-&gt;查询 POST插入数据-&gt; 参考资料 【1】https://www.python.org/dev/peps/pep-3107/]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python面试笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell种类及bash的产生]]></title>
    <url>%2F2019%2F07%2F05%2Flinux%2Fshell%E7%A7%8D%E7%B1%BB%E5%8F%8Abash%E7%9A%84%E4%BA%A7%E7%94%9F%2F</url>
    <content type="text"><![CDATA[shell脚本的基本组成 声明和注释（注释以#开头） 1#! /bin/bash #是声明这个脚本是使用bash来执行的 系统命令 文本处理工具（grep、cut、sed、awk） 各种变量 各种条件判断 循环结构语句 各种函数 shell的作用：命令解释器，介于系统内核与用户之间，负责解释命令行 用户进程和系统进程 用户进程：用来实现具体的某个功能应用的程序，为用户提供服务的程序。mysq1、lkdir等 系统进程：其实就是操作系统本身内部的代码运行的进程。 0.0%us：用户进程所消耗的cpu资源 0.3%sy：系统进程所消耗的cpu资源 10.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st 用户态：一般都是普通的应用程序的状态 内核态：就是操作系统内核代码运行的程序的状态 编译型语言：编写-编译-链接-运行（edit-complie-link-run） C\C++、Ada、Java、C# 脚本语言：解释器读入脚本程序代码，将其装换成内部的形式，解释器本身则是编译型程序 Shell脚本编程的优势 语法和结构通常比较简单 学习和使用通常比较简单 通常以容易修改程序的“解释”作为运行方式，而不要“编译” 登录Shell：指用户每次登录系统后自动加载的Shell程序，大多数Linux系统采用/bin/bash作为默认登录Shell /etc/shells 文件记录了系统支持的有效登录Shell 1234567[root@chenxl ~]# cat /etc/shells/bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin 如何切换Shell环境 临时切换：直接执行其他shell程序 返回到原来的shell环境时可以执行“exit”命令或者按ctrl+D快捷键 更换用户登录Shell： 需要修改/etc/passwd文件中用户记录的最后一个字段 或执行：usermod -s Shell程序路径 用户名 bash初始化：用户登录后到linux系统里，linux系统就会启动一个进程叫bash，然后我们在bash里输入命令，让bash帮我们去查找并执行 直接登录 远程登录：xshell软件、secureCRT bash初始化：启动bash这个程序的时候，需要去执行一些操作，加载某些参数或者函数 w命令 show who is logged on and what they are doing. 123456[root@chenxl ~]# w 20:12:22 up 2:49, 3 users, load average: 0.15, 0.05, 0.06USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 256月19 25:18 0.11s 0.11s -bashroot pts/0 192.168.0.48 276月19 8days 0.01s 0.01s -bashroot pts/1 192.168.0.58 19:48 6.00s 0.04s 0.00s w ps aux静态的查看进程 pstree 查看进程树 top命令 动态的查看进程的信息每隔2秒刷新一次 大写的P：根据cpu的使用率来排序 processor 大写M：根据内存的使用率来排序 memory 按q：退出quit shift+&gt;：下一页的进程信息 shift+&lt;：上一页的进程信息 Shell启动配置文件的区别 /etc/profile：配置全局环境变量，影响所有用户 ~/.bash_profile：配置个人环境，影响一个用户 /etc/bashrc：配置全局的别名或者shell选项，影响所有用户 ~/.bashrc：配置个人别名或者shell选项，影响一个用户 在用户家目录下，每个目录都有的配置文件，只对单独的用户有效。 .bash_profile:用户每次登录时执行—&gt;.bashrc .bashrc：每次进入新的Bash环境时执行（打开终端），定义别名，—&gt;/etc/bashrc .bash_logout：用户每次退出登录时执行 .bash_history：保存上次用户注销前使用的命令 环境变量：全局变量，所有人都可以使用的变量 命令历史 保存用户曾经执行过的命令操作 存放位置：~/.bash_history文件 history:查看历史命令 使用上下箭头按键逐条翻看，允许编辑并重复执行 清除历史命令：history -c(只是将加载到内存的历史命令清除) 最有效的全部清除（磁盘里的历史记录也一起清空） 先rm -rf ~/.bash_history 在history -c exit 调用历史命令 !n：执行历史记录中的的第n条命令 !str：执行历史记录中最近以”str”开头的命令 设置记录历史命令的条数 修改HISTSIZE参数（默认为1000条） alias:Bash的命令别名 命令别名：为使用频率较高的复杂命令行设置简短的调用名称 存放位置：~/.bashrc 查看命令别名：格式：alias [别名] 设置命令别名alias 别名=&#39;实际执行的命令&#39; 取消已设置的命令别名：unalias 别名或者unalias -a]]></content>
      <categories>
        <category>linux</category>
        <category>shell脚本</category>
      </categories>
      <tags>
        <tag>shell种类</tag>
        <tag>bash的产生</tag>
        <tag>w命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程练习题]]></title>
    <url>%2F2019%2F07%2F04%2Fpython%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920"""@file:homework.py@date:2019/07/04"""# list1 = [7,-8,5,4,0,-2,-5]# 正数在前负数在后# 整数从小到大# 负数从大到小list1 = [7, -8, 5, 4, 0, -2, -5]def sort1(x): if x &lt; 0: return x ** 4 else: return xret = sorted(list1, key=sort1)print(ret) 12345678910111213141516171819202122# 这是一个字符串排序，排序规则：小写&lt;大写&lt;奇数&lt;偶数# s='asdf234GDSdsf23'# 排序：小写-大写-奇数-偶数# 原理：先比较元组的第一个值，FALSEimport strings = 'asdf234GDSdsf23'def sort2(x): if x.isdigit(): if int(x) % 1 == 1: return ord(x) + 100 else: return ord(x) + 1000 elif x.islower(): return ord(x) - 100 else: return ord(x)print("".join(sorted(s, key=sort2))) 通过上面的题目 我又了解到python中sorted()方法和列表的sort方法使用详解 sorted基本用法 列表有自己的sort方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。 排序，数字、字符串按照ASCII，中文按照unicode从小到大排序 123x = [4, 6, 2, 1, 7, 9]x.sort()print (x) # [1, 2, 4, 6, 7, 9] 如果需要一个排序好的副本，同时保持原有列表不变，怎么实现呢？ 12345x = [4, 6, 2, 1, 7, 9]y = x[:]y.sort()print(y) # [1, 2, 4, 6, 7, 9]print(x) # [4, 6, 2, 1, 7, 9] 注意：y = x[:] 通过分片操作将列表x的元素全部拷贝给y，如果简单的把x赋值给y：y = x，y和x还是指向同一个列表，并没有产生新的副本。 另一种获取已排序的列表副本的方法是使用sorted函数： 1234x =[4, 6, 2, 1, 7, 9]y = sorted(x)print (y) #[1, 2, 4, 6, 7, 9]print (x) #[4, 6, 2, 1, 7, 9] sorted返回一个有序的副本，并且类型总是列表，如下： 1print (sorted('Python')) #['P', 'h', 'n', 'o', 't', 'y'] 可选参数 sort方法还有两个可选参数：key和reverse 1、key在使用时必须提供一个排序过程总调用的函数： 123x = ['mmm', 'mm', 'mm', 'm' ]x.sort(key = len)print (x) # ['m', 'mm', 'mm', 'mmm'] 2、reverse实现降序排序，需要提供一个布尔值： 123y = [3, 2, 8 ,0 , 1]y.sort(reverse = True)print (y) #[8, 3, 2, 1, 0] True为倒序排列，False为正序排列 sort和sorted的不同 有无返回值 list.sort() ：对原列表进行排序，无返回值 sorted(list)：有返回值 是否影响本身结构 sorted(list) ：不影响本身结构 sorted(list,reverse = True)：不影响本身结构 list.sort()：影响本身结构 list.sort(reverse = True)：影响本身结构 拓展文档https://www.cnblogs.com/huchong/p/8296025.html]]></content>
      <categories>
        <category>python高阶</category>
        <category>函数式编程</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>练习题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OOP]]></title>
    <url>%2F2019%2F07%2F04%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[面向对象编程（OOP）]]></content>
      <categories>
        <category>python</category>
        <category>面向对象编程</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>面向对象</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志]]></title>
    <url>%2F2019%2F07%2F03%2Flinux%2F%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[日志（log）： 1.什么是日志？ 其实就是我们的linux系统或者某个应用程序，将发生的事情记录下来的文本信息就是日志—》log 2.有什么作用？ 用于记录系统、程序运行中发生的各种事件 通过阅读日志，有助于诊断和解决系统故障 大数据：比较重要的日志 web服务器 —&gt;nginx—&gt; ssh服务器 – 》/var/log/secure 数据库服务器 12345[root@localhost log]# yum install epel-release -y[root@localhost log]# yum install nginx -y #安装nginx[root@localhost log]# service nginx restartRedirecting to /bin/systemctl restart nginx.service[root@localhost log]# 如何知道nginx服务是否起来？ 1.查看进程 123456[root@localhost log]# ps aux|grep nginxroot 5769 0.0 0.2 125096 2112 ? Ss 14:58 0:00 nginx: master process /usr/sbin/nginxnginx 5770 0.0 0.3 125484 3148 ? S 14:58 0:00 nginx: worker processroot 5772 0.0 0.0 112724 984 pts/2 S+ 14:58 0:00 grep --color=auto nginx[root@localhost log]# man psps - report a snapshot of the current processes. ps -ef 和ps aux的区别？ 答案：2个命令都是查看进程，只是显示的字段不一样。 ps -ef 主要是用来看看ppid号 2.查看端口 查看某个端口 1234567[root@localhost log]# yum install lsof -y[root@localhost log]# lsof -i:80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 5769 root 6u IPv4 84832 0t0 TCP *:http (LISTEN)nginx 5769 root 7u IPv6 84833 0t0 TCP *:http (LISTEN)nginx 5770 nginx 6u IPv4 84832 0t0 TCP *:http (LISTEN)nginx 5770 nginx 7u IPv6 84833 0t0 TCP *:http (LISTEN) 查看所有端口号的进程 123456[root@localhost yum.repos.d]# yum provides netstat#先查看这个命令来自哪个包[root@localhost yum.repos.d]# yum install net-tools -y[root@localhost yum.repos.d]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 5769/nginx: master 访问nginx服务的前期准备 1234[root@localhost yum.repos.d]# service firewalld stop #停止firewalld服务Redirecting to /bin/systemctl stop firewalld.service[root@localhost yum.repos.d]# iptables -F #清除防火墙规则firewalld底层使用的是iptable工具 通过浏览器去访问你的nginx服务 12345678910111213[root@localhost yum.repos.d]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:2d:ef:f1 brd ff:ff:ff:ff:ff:ff inet 192.168.0.101/24 brd 192.168.0.255 scope global noprefixroute dynamic ens33 valid_lft 6959sec preferred_lft 6959sec inet6 fe80::20c:29ff:fe2d:eff1/64 scope link valid_lft forever preferred_lft forever 12345678[root@localhost nginx]# pwd/var/log/nginx[root@localhost nginx]# lsaccess.log 记录正常的访问error.log 记录异常的访问[root@localhost nginx]#[root@localhost nginx]# cat access.log 192.168.0.100 - - [30/Jun/2019:15:24:49 +0800] "GET / HTTP/1.1" 200 3700 "-" "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36" "-" 知识： 日志级别 设备类型 常见的日志文件有哪些？ 日志的作用 用于记录系统、程序运行中发生的各种事件 通过阅读日志，有助于诊断和解决系统故障 日志文件的分类 内核及系统日志 由系统服务rsyslogd统一进行管理，日志格式基本相似 用户日志 记录系统用户登录及退出系统的相关信息 程序日志 由各种应用程序独立管理的日志文件，记录格式不统一 日志承包商—》rsyslogd —&gt;专供系统使用，也可以帮助用户进程记录日志 123[root@localhost nginx]# ps aux|grep rsyslogdroot 988 0.0 0.4 220776 4656 ? Ssl 08:02 0:05 /usr/sbin/rsyslogd -nroot 6311 0.0 0.0 112728 984 pts/2 S+ 15:58 0:00 grep --color=auto syslog 截取登陆失败的ip地址（安全问题） 123456[root@localhost cron]# cat /var/log/secure|grep "Failed"Jun 30 16:06:54 localhost sshd[6445]: Failed password for root from 192.168.0.101 port 60200 ssh2Jun 30 16:07:00 localhost sshd[6445]: Failed password for root from 192.168.0.101 port 60200 ssh2[root@localhost cron]# cat /var/log/secure|grep "Failed"|awk '&#123;print $11&#125;'192.168.0.101192.168.0.101 日志的格式： 时间、地点、人物（进程）、事件 1234567891011[root@califeng ~]# vim /etc/rsyslog.conf # Log anything (except mail) of level info or higher.# Don't log private authentication messages!*.info;mail.none;authpriv.none;cron.none /var/log/messages# The authpriv file has restricted access.authpriv.* /var/log/secure# Log all the mail messages in one place.mail.* -/var/log/maillog# Log cron stuffcron.* /var/log/cron log level python中日志级别：日志记录级别的数值在下表中给出。如果你想要定义自己的级别，并且需要它们具有相对于预定义级别的特定值。如果你定义具有相同数值的级别，它将覆盖预定义的值；预定义的名称丢失。 级别 数值 CRITICAL 50 ERROR 40 WARNING 30 INFO 20 DEBUG 10 NOTSET 0 Linux中日志消息的级别 0 EMERG（紧急）：会导致主机系统不可用的情况 1 ALERT（警告）：必须马上采取措施解决的问题 2 CRIT（严重）：比较严重的情况 3 ERR（错误）：运行出现错误 —》异常里最多–》程序不能运行 4 WARNING（提醒）：可能会影响系统功能的事件 5 NOTICE（注意）：不会影响系统但值得注意 6 INFO（信息）：一般信息 7 DEBUG（调试）：程序或系统调试信息等 8 none 不记录 设备类型 AUTHPRIV 与认证有关的设备 —》sshd 服务需要登录，登录需要验证 cron 与计划任务相关 mail 与邮件相关 kern 与linux内核相关 local1~7 自定义的设备类型 rsyslogd 记录日志的时候需要确定3个东西： 1.设备类型 2.消息级别 3.记录到哪里 sshd进程—》rsyslog 1.authpriv 2.INFO 解释 123456789101112131415cron.* /var/log/croncron.info /var/log/croncron这种类型的info以上级别的日志都记录到/var/log/cron文件设备类别[连接符]日志级别 . ：记录大于等于后面的级别日志 .=：只记录等于后面的级别日志.!=：只记录不等于后面的级别日志# The authpriv file has restricted access.authpriv.* /var/log/secure记录authpriv这种设备类型所有级别的日志到/var/log/secure* 代表所有的日志级别*.info;mail.none;authpriv.none;cron.none /var/log/messages所有的设备类型的info以上消息级别都记录到/var/log/messages,但是mail、authpriv、cron设备类型的不记录/var/log/messages 会记录几乎常见的日志信息，特别是你不知道到某个程序到哪里去看日志的时候，可以到此一游，看看有没有日志信息 12345#Logging#SyslogFacility AUTHSyslogFacility AUTHPRIV#LogLevel INFO 记录INFO以上级别 1234[root@califeng ~]# vim /etc/rsyslog.conf authpriv.* /var/log/leizhengjie.log #自己修改下[root@califeng ~]# service rsyslog restart #刷新服务Redirecting to /bin/systemctl restart rsyslog.service 看效果 1234567[root@califeng log]# cat leizhengjie.log Jun 30 16:38:51 califeng polkitd[601]: Unregistered Authentication Agent for unix-process:7038:3101537 (system bus name :1.952, object path /org/freedesktop/PolicyKit1/AuthenticationAgent, locale zh_CN.UTF-8) (disconnected from bus)Jun 30 16:39:54 califeng unix_chkpwd[7079]: password check failed for user (root)Jun 30 16:39:54 califeng sshd[7077]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=califeng user=rootJun 30 16:39:54 califeng sshd[7077]: pam_succeed_if(sshd:auth): requirement "uid &gt;= 1000" not met by user "root"Jun 30 16:39:57 califeng sshd[7077]: Failed password for root from 192.168.0.101 port 60202 ssh2Jun 30 16:41:24 califeng sshd[7077]: Connection closed by 192.168.0.101 port 60202 [preauth] 修改设备类型 1234[root@localhost ~]# vim /etc/ssh/sshd_config SyslogFacility local6[root@localhost ~]# vim /etc/rsyslog.conf local6.* /var/log/dinglang.log 刷新2个服务 123456[root@localhost ~]# service sshd restartRedirecting to /bin/systemctl restart sshd.service[root@localhost ~]# service rsyslog restartRedirecting to /bin/systemctl restart rsyslog.service[root@califeng log]# cat dinglang.log Jun 30 16:45:23 califeng sshd[7226]: Failed password for root from 192.168.0.101 port 60204 ssh2 sshd的日志 /var/log/secure /var/log/messages /var/log/cron nginx的日志 /var/log/nginx 安装mariadb(数据库) 123[root@califeng ~]# yum install mariadb mariadb-server -y #安装[root@califeng ~]# service mariadb start #启动Redirecting to /bin/systemctl start mariadb.service 登陆数据库 12345678910111213[root@califeng ~]# mysql -uroot -p #登录Enter password: #直接回车，没有密码Welcome to the MariaDB monitor. Commands end with ; or \g.Your MariaDB connection id is 2Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.MariaDB [(none)]&gt; MariaDB [(none)]&gt; quit #退出Bye 查看数据库的日志 123456[root@califeng ~]# cd /var/log[root@califeng log]# lsmariadb[root@califeng log]# cd mariadb/[root@califeng mariadb]# lsmariadb.log 修改配置文件 12345678910[root@califeng ~]# vim /etc/my.cnf[mysqld]datadir=/var/lib/mysqlcalifeng i love you #自己随意输入，会导致服务起不来socket=/var/lib/mysql/mysql.sock[root@califeng ~]# tailf /var/log/mariadb/mariadb.log 190630 17:03:50 Percona XtraDB (http://www.percona.com) 5.5.59-MariaDB-38.11 started; log sequence number 1597945190630 17:03:50 [Note] Plugin 'FEEDBACK' is disabled.190630 17:03:50 [ERROR] /usr/libexec/mysqld: unknown option '--califeng i love you'190630 17:03:50 [ERROR] Aborting 系统日志保存位置： 默认位于：/var/log 目录下 主要日志文件介绍 内核及公共消息日志：/var/log/messages 计划任务日志：/var/log/cron 系统引导日志：/var/log/dmesg 邮件系统日志：/var/log/maillog yum.log yum安装过的软件的日志 boot.log linux系统启动时候的日志，哪些服务启动了，哪些没有启动 secure 与安全相关的日志，特别是sshd服务默认的日志文件 日志文件非常重要，需要备份 需要定时备份，所有需要计划任务去执行脚本备份 mariadb 程序启动不了，怎么办？1.百度2.Google3.查看日志 —》第1位4.重启5.selinux 需要关闭]]></content>
      <categories>
        <category>linux</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计划任务]]></title>
    <url>%2F2019%2F06%2F30%2Flinux%2F%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[计划任务： 按时去做某件事情，不需要人手工的去操作。 首先写一个脚本 需求：备份/var/log目录下的所有的日志文件，备份整个目录，每天的3点30和22点都进行备份，备份到/backup目录下，文件名里需要有当天的日志，日期精确到秒。 12345678910111213vim backup_log.sh#!/bin/bash#获得当前的时间，精确到秒ctime=$(date +%F%H%M%S)#建立备份目录mkdir -p /backup#进行备份tar -czf /backup/log_$&#123;ctime&#125;.tar.gz /var/log &amp;&gt;/dev/nullecho "backup log ok" 计划任务：计划任务的背后其实是一个程序在每隔一段时间帮我们去查看是否有任务需要执行，如果有就立马执行。 如何查看linux的所有进程 12345ps aux|grep crond #crond进程就是专门盯着计划任务的[root@mysql-2 ~]# ps aux|grep crondroot 5444 0.0 0.0 126284 1628 ? Ss 06:13 0:00 /usr/sbin/crond -nroot 11605 0.0 0.0 112728 984 pts/1 S+ 09:55 0:00 grep --color=auto crond crond这个进程会每隔一分钟去检查用户的计划任务，最短时间间隔为1分钟 如果需要每隔1秒钟做一件事情，建议自己写脚本或者程序来完成 1234567#!/bin/bashwhile :do echo "$RANDOM" sleep 1done crond服务：是linux系统自带的不需要安装，而且开机自动运行。不要kim这个进程，不然linux系统的计划任务都不会运行。 服务： 干什么用的？ 需要安装哪些软件 配置文件在哪里 配置文件：作用其实就往程序传递参数，指导程序安装人的意思去运行，从而达到我们想要的效果。 去改配置文件 调试 看效果 排错–》日志 计划任务 1234567891011121314151617[root@localhost ~]# vim /etc/crontab SHELL=/bin/bash #计划任务使用的shell是bashPATH=/sbin:/bin:/usr/sbin:/usr/bin #计划任务执行的时候会到PATH变量的目录下查找命令，如果没有找到就不执行，建议大家在写脚本的时候，使用绝对路径，避免不被执行MAILTO=root #计划任务出问题或者正常的信息给谁发邮件# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed30 3 * * * bash /root/6_30/backup_log.sh# * 表示任意 使用任务计划 1.创建计划任务：编辑一个计划任务 1234567[root@localhost ~]# crontab -e #编辑计划任务30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh[root@localhost ~]# crontab -l #查看计划任务30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh 如何知道计划任务是否执行？ 直接看效果 查看日志 12[root@localhost log]# cat /var/log/cronJun 30 10:55:01 localhost CROND[3253]: (root) CMD (bash /root/6_30/backup_log.sh) 如何删除计划任务？ 编辑计划任务，注释或者dd删除相关行就可以了 1234[root@localhost log]# crontab -l30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh 存放计划任务的文件：存放在/var/spool/cron 123456789101112[root@localhost log]# cd /var/spool/cron/[root@localhost cron]# lsroot[root@localhost cron]# cat root 30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh[root@localhost cron]# crontab -l30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh dinglang创建的计划任务，所有的人都可以创建计划任务，每个用户对应一个文件，文件名和用户名同名 1234567[root@localhost 6_30]# cd /var/spool/cron/[root@localhost cron]# lsdinglang root[root@localhost cron]# cat dinglang */1 * * * * date &amp;&gt;&gt;~/ding.txt[root@localhost cron]#[root@localhost cron]# 操作系统本身背后也会有很多事情需要计划任务来执行的 12345[root@localhost cron]# cd /etc/cron. 紧接着按两下tab键 cron.monthly/ 每月执行的任务cron.daily/ 每天执行的任务cron.hourly/ 每小时执行的任务cron.weekly/ 每周执行的任务 以上是4个文件夹，只要把脚本放到文件夹里，crond进程就是自动去执行 利用脚本搭顺风车 123456789101112[root@localhost cron.daily]# pwd/etc/cron.daily[root@localhost cron.daily]# lslogrotate man-db.cron[root@localhost cron.daily]# [root@localhost cron.daily]# cd /etc/cron.hourly/[root@localhost cron.hourly]# ls0anacron[root@localhost cron.hourly]# cd /etc/cron.monthly/[root@localhost cron.monthly]# ls[root@localhost cron.monthly]# cd /etc/cron.weekly/[root@localhost cron.weekly]# ls 用户如何不登录linux系统，他的计划任务是否会执行？ 答案：不需要登录，计划任务还是会执行 目的：自动化 查看丁浪用户的计划任务 12345678910111213141516第一种：[root@localhost dinglang]# crontab -l30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh第二种：[root@localhost dinglang]# crontab -l -u dinglang*/5 * * * * date &amp;&gt;&gt;~/ding.txt[root@localhost dinglang]# cd /var/spool/cron/ [root@localhost cron]# ls dinglang root #一个用户对应一个文件[root@localhost cron]# */5 * * * * date &amp;&gt;&gt;~/ding.txt* */1 * * * date &amp;&gt;&gt;~/ding.txt* * */2 * * date &amp;&gt;&gt;~/ding.txt 练习题目 示例1（root用户）： 每天早上7:50自动开启sshd服务，22点50时关闭 1250 7 * * * service sshd start50 22 * * * service sshd stop 每隔5天的12点整清空一次FTP服务器公共目录/var/ftp/pub 10 12 */5 * * rm -rf /var/ftp/pub/* 每周六的7:30时，重新启动httpd服务 130 7 * * 6 service httpd restart - 每周一、三、五的17:30时，打包备份/etc/httpd目录 130 17 * * 1,3,5 tar czf /backup/httpd.tar.gz /etc/httpd - 每天晚上的2点30执行/mysql/backup_mysql.sh脚本（脚本暂时可以不去写） 130 2 * * * bash /mysql/backup_mysql.sh 示例2（dinglang用户）： 每周日晚上23:55时将“/etc/passwd”文件的内容复制到宿主目录中，保存为pwd.txt文件 12[root@localhost 6_30]# crontab -e -u dinglang55 23 * * 7 cp /etc/passwd ~/pwd.txt 时间数值的特殊表示方法 * 表示该范围内的任意时间 ， 表示间隔的多个不连续时间点 - 表示一个连续的时间范围 /n 指定间隔的时间频率 应用实例 0 17 * * 1-5 周一到周五每天17:00 30 8 * * 1,3,5 每周一、三、五的8点30分 0 8-18 * * * 8点到18点整 0 12 */3 * * 每隔3天的12点整]]></content>
      <categories>
        <category>linux</category>
        <category>计划任务</category>
      </categories>
      <tags>
        <tag>shell脚本</tag>
        <tag>计划任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码的调试与测试]]></title>
    <url>%2F2019%2F06%2F29%2Fpython%2F%E4%BB%A3%E7%A0%81%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[代码调试与测试 什么是代码调试与测试？ 测试是为了发现错误而执行程序的过程。 调试是定位错误，修改程序以修正错误，为了程序可运行。 测试从一个已知的条件开始,有预知的结局。 调试从未知的条件开始,其结局不可预知。 为什么要做代码调试与测试？ 代码测试是为了增强代码的健杜倒 代码调试是为了解决已知问题 代码调试方法 print 简单直接粗暴有效 适合开发中 IDE Debuger Pycharm 开发中出错了 pdb 交互的源代码调试功能 命令行中使用 Logging 日志定位问题济记录程序运行情况 发布上线后，记日志 代码测试 assert：断言方便开关 单元测试 什么是单元测试： 1.单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作 2.把上面这些测试用例放到一个测试模块里，就是一个完整的单元测试 测试需要一定时间，而我们完全可以用这些时间去编写代码，为什么要测试而不是去做那些最有生产效率的事？ 1.测试可以保证你的代码在一系列给定条件下正常工作 2.测试允许人们确保对代码的改动不会破坏现有的功能 3.测试自使人们在不寻常条件的情况下思考代码，这可能会揭示出逻辑错误 4.良好的测试要求模块化，解耦代码，这是一个良好的系统设计的标志 unittest单元测试：unittest是Python自带的单元测试框，可以用来作自动化测试框架的用例组织执行框架 优点：提供用例组织与执行方法提供比较方法 提供丰富的日志、清晰的报告 方法： assertEqual(a,b)a == b assertNotEqual(a,b)a != b assertTrue(x)bool(x) is True assertFalse(x)bool(x) is False assertIs(a,b)a is b assertIsNot(a,b)a is not b assertIn(a,b)a in b assertNotIn(a,b)a not in b 单元测试注意事项 在写测试用例的时候尽量代码简单 如果测试用例逻辑比较复杂，那么也可能会出现错误 单元测试即使通过了，也不代表程序本身一点问题都没有 如果单元测试没有通过那程序本身肯定是存在bug的 常用调试方法 print函数 优点：使用简单，直接锁定定位的变量查看结果 缺点：如果程序代码很大，会出现大量的print，运行结果也会包括很多不必要的垃圾信息，等到项目正式发布的时候对于这些print代码还要都删除掉 12345678def fun(): r = input('请输入一个数字') print(type(r)) n = int(r) print('s的值为：%s' % n) result = 100/n return resultprint(fun()) assert断言 在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行时渍，不如在出现错误条件时就崩渍，这时候就需要assert断言的帮助。 断言可以简简单单的想象为raise-if 语句（更准确的说是raise-if-not 语句）。 测试一个表达式，如果返回值是假，触发异常。 文档：https://docs.python.org/3/reference/simple_stmts.html#assert 格式 12assert expression[, arguments]assert 表达式[, 参数] 等价语句 12if __debug__: if not expression1:raise AssertionError(expression2) 断言需要开启dubug模式 查看：debug 的值 查看：help(“assert”) 开启非Debug模式：python -O 小案例 检查列表长度必须大于2 1assertlen(mylist) &gt;= 1 ​ 检查成绩必须在0~100之间 12score = 101assert score &gt;= 0 and score &lt;=100, 'score is error' - 应用情况 - 防御性的编程：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。 - 合约性检查 比如前置条件，后置条件 如成绩方位、数据类型等 - 运行时对程序逻辑的检测 logging模块 介绍： logging模块是Python内置的标准模块，主要用于输出运行日志，可以设百输出日志的等级、日志保存路径、日志文件轮转 logging模块是标准库之一 优点 可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大呈的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； logging.basicConfig函数各参数 filename：指定日志文件名 filemode：和file函数意义相同，指定日志文件的打开模式，’w’或者’a’ stream：指定将日志的输出流可以指定输出到sys.stderr，sys.stdout或者文件 默认输出到sys.stderr 当stream和filename同时指定时，stream被忽 level：设置日志级别，默认为logging.WARNNINGFATAL：致命错误 CRITICAL：特别糟糕的事情，如内存耗尽、磁盘空间为空，一般很少使用 ERROR：发生错误时，如IO操作失败或者连接问题 WARNING：发生很重要的事件，但是并不是错误时，如用户登录密码错误 INFO：处理请求或者状态变化等日常事务 DEBUG：调试过程中使用DEBUG等级，如算法中每个循环的中间状态 format：指定输出的格式和内容，format可以输出很多有用的信息%（levelno）s：打印日志级别的数值 %（levelname）s：打印日志级别的名称 %（pathname）s：打印当前执行程序的路径，其实就是sys.argv[0] %（filename）s：打印当前执行程序名 %（funcName）s：打印日志的当前函数 %（lineno）d：打印日志的当前行号 %（asctime）s：打印日志的时间 %（thread）d：打印线程ID %（threadName）s：打印线程名称 %（process）d：打印进程ID%（message）s：打印日志信息 datefmt：指定时间格式，同time.strftime）； handler名称：位置；作用 StreamHandler:logging.StreamHandler 日志输出到流，可以是sys.stderr，sys.stdout或者文件FileHandler:logging.FileHandler 日志输出到文件SysLogHandler:logging.handlers.SysLogHandler 日志输出到syslog BaseRotatingHandler:logging.handlers.BaseRotatingHandler 基本的日志回滚方式RotatingHandler:logging.handlers.RotatingFileHandler 日志回滚方式，支持日志文件最大数量和日志文件回滚TimeRotatingHandler:logging.handlers.TimeRotatingHandler 日志回滚方式，在一定时间区域内回滚日志文件SocketHandler:logging.handlers.SocketHandler 远程输出日志到TCP/IP sockets DatagramHandler:logging.handlers.DatagramHandler 远程输出日志到UDP sockets SMTPHandler:logging，.handlers.SMTPHandler 远程输出日志到邮件地址NTEventLogHandler:logging，.handlers.NTEventLogHandler 远程输出日志到Windows NT/2000/XP的事件日志MemoryHandler:logging.handlers.MemoryHandler 日志输出到内存中的指定buffer HTTPHandler:logging.handlers.HTTPHandler 通过”GET”或者”POST”远程输出到HTTP服务器 日志级别l ogging中可以选择很多消息级别 debug：看不到 info warning error critical：程序要崩溃了 logging是线程安全不是进程安全 线程安全： 多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 官方logging线程安全 https://docs.python.org/3/library/logging.html#thread-safety pdb-python调试器 使用pdb在代码中设置断点（硬编码） 创建模块mypdb_base.py 123456789import pdba = 2b = a * 2c = a + b# 设置断点pdb.set_trace()print(a)print(b)print(c) 启动调试器 python mypdb_base.py pdb指令 下一条语句：n，next 打印变量信息：p变量名 打印脚本信息：l 退出pdb:q 查看帮助：h 单步调试：每次执行一行 适合场景：短小的脚本 创建模块mypdb_base.py 1234i = 0while True: print(i) i += 1 启动调试器 注意： 远程调试、多线程，pdb搞不定 pdb指令 完整命令 简写命令 描述 args a 打印当前函数的参数 break b 设置断点 clear d 清除断点 condition 无 设置条件断点 continue c或者cont 继续运行，知道遇到断点或者脚本结束 disable 无 禁用断点 enable 无 启用断点 help h 查看pdb帮助 ignore 无 忽略断点 jump j 跳转到指定行数运行 list l 列出脚本清单 next n 执行下条语句，遇到函数不进入其内部 p p 打印变量值，也可以用print quit q 退出pdb return r 一直运行到函数返回 tbreak 无 设置临时断点，断点只中断一次 step s 执行下一条语句，遇到函数进入其内部 where w 查看所在的位置 ！ 无 在pdb中执行语句 IDE Debuger Pycharm 断点设置：遇到断点，程序会停下来，保留所有当前状态数据 启动调试器 常用快捷键 搜索变量：Alt +F8 /Debug行的最后一个按钮（小方形） 下一个断点：F9 下一条语句：F8 进入当前语句的执行：F7 拓展文档： https://blog.csdn.net/u013088062/article/details/50216015 单元测试：单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 12345比如对于函数abs0，我们可以编写的测试用例为：①输入正数，比如1、1.2、0.99，期待返回值与输入相同②输入复数，比如-1、-1.2、-0.99，期待返回值与输入相反③输入0，期待返回0④输入非数值类型，比如None、、0、期待抛出TypeError 把上面这些测试用例放到一个测试模块里，就是一个完整的单元测试 测试的目的（测试需要一定的时间，而我们完全可以用这些时间去编代码，为什么要测试而不是去做那些最有生产效率的事？） 测试可以保证你的代码在一系列给定条件下正常工作 测试允许人们确保对代码的改动不会破坏现有的功能 测试迫使人们在不寻常条件的情况下思考代码，这可能会揭示出逻辑错误 良好的测试要求模块化，解耦代码，这是一个良好的系统设计的标志 unittest单元测试：unittest是Python自带的单元测试框，可以用来作自动化测试框架的用例组织执行框架。 优点： 提供用例组织与执行方法； 提供比较方法； 提供丰富的日志、清晰的报告。 unittest单元测试方法 方法 检查 assertEqual（a，b） a==b assertNotEqual（a，b） a!=b assertTrue（x） bool（x）is True assertFalse（x） bool（x）is False assertls（a，b） a is b assertlsNot（a，b） a is not b assertin（a，b） a in b assertNotiln（a，b） a not in b 注意事项 在写测试用例的时候尽量代码简单。 如果测试用例逻辑比较复杂，那么也可能会出现错误。 单元测试即使通过了，也不代表程序本身一点问题都没有 如果单元测试没有通过那程序本身肯定是存在bug的]]></content>
      <categories>
        <category>python高阶</category>
        <category>python代码的调试和测试</category>
      </categories>
      <tags>
        <tag>logging模块</tag>
        <tag>pdb模块</tag>
        <tag>单元测试</tag>
        <tag>unittest模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML的学习]]></title>
    <url>%2F2019%2F06%2F26%2Fweb%E5%BC%80%E5%8F%91%2FHTML%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[网页前端三剑客 HTML 超文本标记语言 标记页面中有哪些元素 CSS 层叠样式表 我不生产元素，我只让元素变个样子 JavaScript 动态脚本语言 我来决定什么时候使用CSS，更重要的是，我可以创建和修改元素 HTML：要展现的信息 CSS：美化要展示的信息 JS：技能(更好的实现交互) 一个标准的HTML的格式 12345678910&lt;!DOCTYPE html&gt; #声明文档类型&lt;html lang="en"&gt; #页面的根元素，html的语言，en-&gt;英语&lt;head&gt; #头部信息，head标签包含了文档的元(meta)数据 &lt;meta charset="UTF-8"&gt; #编码为utf-8 &lt;title&gt;Title&lt;/title&gt; #标题：浏览器上看到的标题栏&lt;/head&gt;&lt;body&gt; #文档的主体：网页可见的内容&lt;/body&gt;&lt;/html&gt; 例图 HTML学习教程 [1.标题与段落](http://localhost:50766/python/python study/django框架及前端知识/HTML20190626/标题与段落.html) HTML的标签 HTML的标签是由尖括号包围的关键词，比如&lt;html&gt;&lt;/html&gt; HTML的标签通常是成对出现的，比如&lt;b&gt;和&lt;/b&gt; 标签对中的的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML的属性 HTML标签可以拥有属性。属性提供了有关HTML元素的更多的信息。 属性总是以名称/值对的形式出现，比如：name=”value”. 属性总是在HTML元素的开始标签中规定。 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一id style style_definition 规定元素的行内样式（inline style） title text 规定元素的额外信息（可在工具提示中显示） HTML元素 HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 开始标签 元素内容 结束标签 &lt;p&gt; This is a paragraph &lt;/p&gt; &lt;a href=”default.html”&gt; This is a link &lt;/a&gt; &lt;br/&gt; hr标签：水平线 p标签：段落 &lt;h1&gt; to &lt;h6&gt;：定义HTML标题 标签:这是一个注释 &lt;br&gt;标签：换行 &lt;body&gt;：定义文档的主体 列表：无序和有序 &lt;ol&gt;：定义有序列表 &lt;ul&gt;：定义无序列表 &lt;li&gt;：定义列表项 &lt;dl&gt;：定义自定义列表 &lt;dt&gt;：定义自定义项目 &lt;dd&gt;：定义自定义的描述 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;列表&lt;/h1&gt;&lt;h2&gt;无序列表&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt; &lt;li&gt;第三项&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;有序列表&lt;/h2&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt; &lt;li&gt;第三项&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;自定义列表&lt;/h2&gt;&lt;dl&gt; &lt;dt&gt;Tag部分&lt;/dt&gt; &lt;dd&gt;数据部分&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;Tag部分&lt;/dt&gt; &lt;dd&gt;数据部分&lt;/dd&gt;&lt;/dl&gt;&lt;/body&gt;&lt;/html&gt; 例图 列表无序列表 第一项 第二项 第三项 有序列表 第一项 第二项 第三项 自定义列表Tag部分 ​ 数据部分 Tag部分 ​ 数据部分 文本格式化标签 &lt;b&gt;：定义粗体文本 &lt;big&gt;：定义大号字 &lt;em&gt;：定义着重文字 &lt;i&gt;：定义斜体字 &lt;small&gt;：定义小号字 &lt;strong&gt;：定义加重语气 &lt;sub&gt;：定义下标字 &lt;sup&gt;：定义上标字 &lt;ins&gt;：定义插入字 &lt;del&gt;：定义删除字 CSS 什么是CSS？ CSS指层叠样式表（Cascading Style Sheets） 样式定义如何显示HTML元素 样式通常存储在样式表中 把样式添加到HTML4.0中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 样式对网页中元素位置的排版进行像素级精确控制 CSS语法 CSS规则由两个主要的部分构成：选择器，以及一条或多条声明； 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 id选择器（#id） id 选择器可以为标有特定id的HTML元素指定特定的样式。 ID属性不要以数字开头，数字开头的ID在Mozilla/Firefox浏览器中不起作用。 Remark ID属性只能在每个HTML文档中出现一次。具体的解释，请参阅XHTML：网站重构。 class选择器(.id) class 选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在HTML中以class属性表示，在CSS中，类选择器以一个点”：“号显示 所有的p元素使用class=”center”让该元素的文本居中： p.center{text-align:center} 样式层叠次序 当同一个HTML元素定义了多个样式时，应该使用哪个样式？(就近原则) 浏览器缺省设置 外部样式表 内部样式表（位于&lt;head&gt;标签内部）&lt;style&gt;&lt;/style&gt; 内联样式（在HTML元素内部）&lt;p style=&quot;color:red&quot;&gt;xx&lt;/p&gt; JS 基本语法 浏览器属性和DOM属性]]></content>
      <categories>
        <category>python</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web的学习]]></title>
    <url>%2F2019%2F06%2F26%2Fweb%E5%BC%80%E5%8F%91%2FWeb%E7%9A%84%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是web开发？ 基于Web技术开发的使用浏览器访问的项目 web开发技术栈 前端 浏览器：Chrome、firefox、IE、Opera、Linux命令客户端、python-request/urllib 网页三剑客：html、css、js 后端 开发语言：Python、java、GO、PHP、Node.js Web框架：接受请求、生成响应、框架的特性、针对业务进行扩展 Django Flask Tornado 服务器操作系统： Linux：CentOS、RedHat、Ubuntu windows server 中间件 负载均衡 WAF(web应用防护) 缓存 运维监控 全文搜索 数据库(备份、容灾、调优) 关系型数据库：MySQL、Sqlite、SqlServer、Oracle 非关系型数据库：NoSQL、MongoDB（key:value） 技术方案 Nginx Restful API OAuth2.0 Docker 消息队列 单面应用与多页应用 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用(css.js) 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 url模式 a.com/#/pageone；a.com/#/pagetwo a.com/pageone.html；a.com/pagetwo.html 拓展： 从MVC到前后端分离 https://blog.csdn.net/shaobingj126/article/details/49420145 前端：你要懂的单页面应用和多页面应用 https://juejin.im/post/5a0ea4ec6fb9a0450407725c 17素材网 http://www.17sucai.com/]]></content>
      <categories>
        <category>python</category>
        <category>web开发</category>
      </categories>
      <tags>
        <tag>web简介</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器和生成器]]></title>
    <url>%2F2019%2F06%2F24%2Fpython%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如何判断一个对象是可迭代对象，迭代器对象或生成器 如何确认一个对象是不是可迭代对象 用Iterable判断 123456789101112131415161718&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt;&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; c = (4,5,6)&gt;&gt;&gt; d = &#123;"name":"tom","age":22&#125;&gt;&gt;&gt; if isinstance(a,Iterable):... print("a是可迭代对象")...a是可迭代对象&gt;&gt;&gt; if isinstance(b,Iterable):... print("b是可迭代对象")...b是可迭代对象&gt;&gt;&gt; if isinstance(c,Iterable):... print("c是可迭代对象")...c是可迭代 判断迭代器 Iterator判断 12345678from collections import Iterable, Iteratorran = range(3)if isinstance(ran,Iterator): print("ran是迭代器")else: print("ran不是迭代器“)输出：ran不是迭代器 ------ - 1234567891011121314是否实现了__iter__和__next__方法from collections import Iterable, Iteratorran = range(3)if isinstance(ran,Iterator): print("ran是迭代器")else: print("ran不是迭代器")print(ran,dir(ran))ran = iter(ran)print(ran,dir(ran))输出：ran不是迭代器range(0, 3) ['__bool__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index', 'start', 'step', 'stop']&lt;range_iterator object at 0x000001AF8A8585F0&gt; [__iter__', '__next__', ] 如何判断迭代器 12345678可以使用 isinstance 函数来判断def _(): yield Nonegenerator=type(_())x =( k for k in range(10))print(isinstance(x,generator))输出：true 迭代器与生成器的区别 迭代器 通过iter()方法获得了list的迭代器对象，然后就可以通过next()方法来访问list中的元素了。当容器中没有可访问的元素后，next()方法将会抛出一个StopIteration异常终止迭代器。 生成器 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator） 生成器属于一种特殊的迭代器，而且因为自动创建了iter()和next()，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。 yield 通常和生成器一起使用 异同 通过实现迭代器协议对应的iter()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。 生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义iter()和next()方法。 生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。 如何获取可迭代对象、迭代器与生成器中的数据 可迭代对象 用for循环 迭代器 用next()方法 生成器 用next()方法 用yield from 扩展阅读https://docs.python.org/3/library/stdtypes.html#iterator-typeshttps://anandology.com/python-practice-book/iterators.htmlhttps://docs.python.org/3/reference/expressions.html#yieldexpryield from ： http://blog.theerrorlog.com/yield-from-in-python-3.htmlhttp://blog.csdn.net/mingc0758/article/details/53783001Python中生成器和迭代器的区别 http://blog.csdn.net/u014745194/article/details/70176117]]></content>
      <categories>
        <category>python高阶</category>
        <category>迭代器和生成器</category>
      </categories>
      <tags>
        <tag>集合、元组、列表推导式</tag>
        <tag>可迭代对象</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[raid-廉价磁盘冗余阵列]]></title>
    <url>%2F2019%2F06%2F23%2Flinux%2Fraid-%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97%2F</url>
    <content type="text"><![CDATA[raid-廉价磁盘冗余阵列 raid 磁盘阵列（独立冗余磁盘阵列） 硬raid（推荐）：会有一个raid卡，用来控制这个raid，是正raid的大脑 容错功能 专门有数据处理的芯片 软raid：通过软件来实现raid控制功能，不需要需要硬件。 需要使用电脑的cpu里来处理数据 磁盘阵列（Redundant Arrays of Independent Drives，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个磁盘上 磁盘会坏，坏了就意味着数据丢失 RAID0、RAID1、RAID5、RAID6、RAID10、RAID01 功能： 1.数据冗余 2.容错 3.存取数据速度快 raid0：读写速度快，但是没有容错功能。2块以上磁盘组成。磁盘利用率100%–》条带卷 raid1：镜像卷：2块磁盘组成，有容错功能。磁盘利用率50% raid5：背后的原理是分布校验+条带：可以容错，至少3块磁盘，最多坏一块。 磁盘利用率：（n-1）/n raid6：背后的原理是分布校验+分布校验+条带：可以容错，至少4块磁盘，最多坏2块。 磁盘利用率：（n-2）/n RAID配置总结 级别 RAID0 RAID1 RAID5 RAID6 磁盘数 &gt;=2 2 &gt;=3 &gt;=4 容错功能 无 有 有 较强 读写速度 最快 写入慢 较快较快 较快 磁盘空间利用 100% 50% n-1 n-2 如何知道磁盘坏了？ 1.看磁盘的灯是否亮–》需要人去现场看–》很傻 2.查看raid的数据，里面有显示那些是好的，那些是坏的。–》监控脚本或者程序 软件raid：只能通过Linux系统本身来查看 1cat /proc/mdstat #可以看到raid级别，状态等信息。 硬件raid：最佳的办法是通过已安装的raid厂商的管理工具来查看，有cmdline，也有图形界面 如Adaptec公司的硬件卡就可以通过下面的命令进行查看： 1/usr/dpt/raidutil-L all #可以看到非常详细的信息。 raid的配置是在安装系统之前就配置好了的 裸机–》系统做raid1，数据磁盘做raid5–》安装系统—》存放数据 能自己购买服务器的公司—》有钱的行为 只有真实的服务器需要做raid 购买云服务器的公司不做raid 云服务产商会提供数据不丢失的保障 99.9999% LVM(Logical Volume Manager),逻辑卷管理 动态扩容 分区结构不需要修改]]></content>
      <categories>
        <category>linux高级</category>
        <category>文件系统</category>
        <category>raid</category>
      </categories>
      <tags>
        <tag>raid廉价磁盘冗余阵列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F2019%2F06%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络之网络层 TCP/IP五层协议： 应用层、传输层、网络层、数据链路层、物理层 网络层：ip、arp、icmp3个协议 传输层：tcp、udp ip协议—-internet protocol互联网协议 现在的互联网协议：ipv4 下一代互联网协议：ipv6 IP数据包格式（只记住重点） TTL–&gt;time to live=生命周期 广播与广播域 广播：将广播地址做为目的地址的数据帧 广播域：网络中能接收到同一个广播所有节点的集合 MAC ARP协议：Address Resolution Protocol 地址解析协议 1.request 请求包 源ip：自己的 目的ip：别人的 源mac：自己的 目的mac：000000000000 2.response 响应包 数据链路层里的帧的封装格式 源mac：自己的 目的mac：ffffffffffff 为什么交换机收到arp包会转发？ 为什么叫arp广播？ 如果是arp request包会转发到所有的接口 arp缓存表里的内容是可以更新的。 arp缓存表是在内存里存放的. linux系统中的ARP命令 arp-a：查看ARP缓存表·arp-n 查看ARP缓存表 arp-d：清除ARP缓存 arp-s：绑定ip地址和mac地址。 ICMP协议：是一个“错误侦测与回馈机制”，是通过IP数据包封装的，用来发送错误和控制消息 三层交换]]></content>
      <categories>
        <category>计算机网络</category>
        <category>网络层笔记</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的多进程和多线程]]></title>
    <url>%2F2019%2F06%2F18%2Fpython%2Fpython%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[python的多进程和多线程 进程和进程之间通信，有哪些方式？ 管道 共享内存 信号 kill 是linux中杀死进程的命令 9) SIGKILL 信号类型 –&gt;被强制杀死（都来不及保存数据） 为什么kill进程的时候需要接-9？ 强制杀死，因为-9的信号类型是不能被屏蔽的，所以可以达到强制杀死进程的目的 15) SIGTERM 告诉进程自我终结 signal terminate—&gt;15这种信号是可以被屏蔽的 1) SIGHUP signal HUP—-&gt; 挂起 父进程开启了一堆的子进程，如果把父进程杀死，父会给子进程发HUP信号，操作系统会将所有收到HUP信号的子进程全部杀死 2) SIGINT 中断信号 signal inerrupt—-&gt;按ctrl+c其实就是发中断信号 队列 信号量 socket（槽） 网络socket = ip : port 文件socket 12345678910111213141516from multiprocessing import Processimport timedef foo(i): print('chlid , arg i is &#123;&#125;'.format(i)) time.sleep(1) print('child , arg i is &#123;&#125;'.format(i))if __name__ == '__main__': p_lst = [] for i in range(4): p = Process(target=foo, args=(i,)) p.start() p_lst.append(p) p.join() #[p.join() for p in p_lst] 进程里包含线程，一个进程里可以包含很多线程 进程 ：pcb（process控制块） + 代码 + 数据 线程 ：tcb （thread控制块） + 代码 + 数据 进程消耗资源多（cpu、内存、磁盘、网络等） 线程可以共享进程里的一些公共资源，更加节约系统的资源。 为什么线程在cpu里运行会比进程快？ 线程在上下文切换的时候，因为有公共部分，所以节约很多的时间，有很多的数据不需要切换，直接使用。 为什么线程更加节省资源（cpu、内存）？ 内存空间上：因为线程有公共部分，所以更加节约空间。 多进程更加稳定、但消耗资源多 多线程速度快，但是一个进程被杀死，进程里的线程都杀死，不够稳定—-nginx\mysql等 进程和线程的差异？ 进程里包含线程 线程更加节省资源 为啥节省资源？ 1.一个进程里起的线程可以共享部分内存空间–》节省内存 2.在上下文切换的时候，速度会更加快 进程稳定 杀死一个进程，会杀死这个进程里的所有的线程 为什么nginx起的进程的数量需要和cpu的核心的数量一样？ 井行，同时处理 同一个进程里的线程不需要在不同的cpu里切换，速度更加快 cpu在处理数据的时候，linux对待进程，和对待线程是一样的 进程与线程 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 真正在cpu上运行的是线程 线程在执行过程中，需要协作同步 多进程与多线程 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复余，需要用IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机稻比较简单 适应于多核分布式 进程占优 GIL锁是什么？有什么用？为什么需要这个锁？为什么有这个锁？Python GIL与多线程 GIL全称Global Interpreter Lock（全局解释器锁） GIL和Python语言没有任何关系，只是因为历史原因导致在官方推荐的解释器Cpython中遗留的问题（Jpython无此类问题） 每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，控制线程的执行顺序 cpython作者这样写，历史遗留原因；1991年的硬件非常差，根本没有多核的概念 GIL锁的坏处就是不能同时使用多个cpu核心。–》不能同时使用cpu去运行，意味着多线程不能同时工作，速度起不来。 python里的多进程与多线程的选择 io密集型计算用多线程–》读写数据非常多 cpu密集型计算用多进程—》计算非常多–》需要大量使用cpu c语言里的多进程与多线程的选择(个人看法) io密集型计算用多线程 cpu密集型计算用多进程 多线程：（） Gil全局解释锁和线程互斥锁的关系 https://www.cnblogs.com/Keep-Ambition/p/7596098.html 协程和线程的区别？协程是否有上下文切换的概念？多线程是否上下文切换？ 总结： 不一致读 互斥锁：控制多线程执行的顺序 GIL锁 threading线程模块 创建线程的类—-&gt;Thread 创建锁的类—-&gt;Lock]]></content>
      <categories>
        <category>python高阶</category>
        <category>多进程和多线程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>进程间通信方式</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的20个面试题]]></title>
    <url>%2F2019%2F06%2F18%2Fgit%E7%9A%8420%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[GIT和SVN有什么区别？ Git SVN 1. Git是一个分布式的版本控制工具 1. SVN 是集中版本控制工具 2.它属于第3代版本控制工具 2.它属于第2代版本控制工具 3.客户端可以在其本地系统上克隆整个存储库 3.版本历史记录存储在服务器端存储库中 4.即使离线也可以提交 4.只允许在线提交 5.Push/pull 操作更快 5.Push/pull 操作较慢 6.工程可以用 commit 自动共享 6.没有任何东西自动共享 什么是GIT? Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。 与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。 每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。 还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。 在GIT中提交的命令是什么？ git commit -a/-m -a：是指git提交已修改的所有被跟踪文件的新内容。 -m：指备注信息 什么是GIT中的“裸存储库”？ Git 中的 “裸” 存储库只包含版本控制信息而没有工作文件（没有工作树），并且它不包含特殊的 .git 子目录。相反，它直接在主目录本身包含 .git 子目录中的所有内容，其中工作目录包括： 一个 .git 子目录，其中包含你的仓库所有相关的 Git 修订历史记录。 工作树，或签出的项目文件的副本。 GIT是用什么语言编写的？ Git使用 C 语言编写。 GIT 很快，C 语言通过减少运行时的开销来做到这一点。 在GIT中，你如何还原已经push并公开的提交？ 删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我将使用的远程存储库 1git commit -m "commit message" 创建一个新的提交，撤消在错误提交中所做的所有更改。可以使用命令 1git revert &lt;name of bad commit&gt; git pull 和git fetch 有什么区别？ git pull 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。 git fetch 也用于相同的目的，但它的工作方式略有不同。当你执行 git fetch 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 git fetch 之后执行git merge。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式： git pull = git fetch + git merge git 中的“staging area” 或“index”是什么？ 在完成提交之前，可以在称为“staging area”或“index”的中间区域中对其进行格式化和审查；从图中可以看出，每个更改首先在暂存区域中进行验证，称为“stage file”，然后将更改提交到存储库。 https://segmentfault.com/img/bVbtc0c?w=655&amp;h=645 什么是git stash? 通常情况下，一直在处理项目的某一部分时，如果想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，不想把完成了一半的工作的提交，以便以后就可以回到当前的工作。解决这个问题的答案是 git stash。 stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，可以随时重新应用这些更改。 什么是git stash drop? git stash drop命令用于删除隐藏的项目。 默认情况下，它将删除最后添加的存储项，如果提供参数的话，它还可以删除特定项。 如何找到特定提交中已更改的文件列表？ 要获取特定提交中已更改的列表文件，请使用以下命令： git diff-tree -r {hash} 给定提交哈希，这将列出在该提交中更改或添加的所有文件。 -r 标志使命令列出单个文件，而不是仅将它们折叠到根目录名称中。 你还可以包括下面提到的内容，虽然它是可选的，但有助于给面试官留下深刻印象。 输出还将包含一些额外信息，可以通过包含两个标志把它们轻松的屏蔽掉： git diff-tree –no-commit-id –name-only -r {hash} 这里 -no-commit-id 将禁止提交哈希值出现在输出中，而 -name-only 只会打印文件名而不是它们的路径。 git config 的功能是什么？ 用来查看或修改你的git配置，包括用户名 提交对象包含什么？ 一组文件，表示给定时间点的项目状态 引用父提交对象 SHAI 名称，一个40个字符的字符串，提交对象的唯一标识。 如何在GIT中创建存储库？ 要创建存储库，先为项目创建一个目录（如果该目录不存在），然后运行命令 git init。通过运行此命令，将在项目的目录中创建 .git 目录。 怎样将N次提交压缩成一次提交? 如果要从头开始编写新的提交消息，请使用以下命令： 12git reset –soft HEAD~N &amp;&amp;git commit 如果你想在新的提交消息中串联现有的提交消息，那么需要提取这些消息并将它们传给 git commit，可以这样： 12git reset –soft HEAD~N &amp;&amp;git commit –edit -m"$(git log –format=%B –reverse .HEAD@&#123;N&#125;)" 什么是GIT bisect?如何使用它来确定（回归）错误的来源？ Git bisect 用于查找使用二进制搜索引入错误的提交。 1git bisect &lt;subcommand&gt; &lt;options&gt; 此命令用了二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。你可以通过告诉它已知包含该错误的“错误”提交以及在引入错误之前已知的“良好”提交来使用它。然后 git bisect 在这两个端点之间选择一个提交，并询问你所选的提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。 如果想要在提交之前运行代码性检查工具，并在测试失败时阻止提交，该怎么配置GIT存储库？ 这可以通过与存储库的 pre-commit hook 相关的简单脚本来完成。git 会在提交之前触发 pre-commit hook。你可以在这个脚本中运行其他工具，例如 linters，并对提交到存储库中的更改执行完整性检查。 描述一下你所使用的分支策略？ 功能分支（Feature branching） 要素分支模型将特定要素的所有更改保留在分支内。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。 任务分支（Task branching） 在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。 发布分支（Release branching） 一旦开发分支获得了足够的发布功能，你就可以克隆该分支来形成发布分支。创建该分支将会启动下一个发布周期，所以在此之后不能再添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该包含在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它还应该再将自发布以来已经取得的进展合并回开发分支。 如果分支是否已合并为master，你可以通过什么手段知道？ git branch –merged 它列出了已合并到当前分支的分支。 git branch –no-merged 它列出了尚未合并的分支。 什么是SubGit？ SubGit 是将 SVN 到 Git迁移的工具。它创建了一个可写的本地或远程 Subversion 存储库的 Git 镜像，并且只要你愿意，可以随意使用 Subversion 和 Git。 这样做有很多优点，比如你可以从 Subversion 快速一次性导入到 Git 或者在 Atlassian Bitbucket Server 中使用SubGit。我们可以用 SubGit 创建现有 Subversion 存储库的双向 Git-SVN 镜像。你可以在方便时 push 到 Git 或提交 Subversion。同步由 SubGit 完成。 https://segmentfault.com/a/1190000019315509]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>分布式版本控制系统</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F06%2F16%2FGit%2F</url>
    <content type="text"><![CDATA[Git .gitignore仓库log目录，不希望同步到仓库中去，写到.gitignore文件 /log/ 凡是写到这个文件中了，那么git add.的时候就不会被添加到仓库中去 .pyc 常用命令 git log：查看历史 git add：标记文件添加到仓库 git add . =&gt;标记当前目录及子目录文件（.gitignore文件指定的内容是不添加的） 不能同步空目录 git clone：克隆仓库 12git clone https://github.com/chenxl18/chenxl18.github.io.git#=&gt; 当前目录 12/d/hexo/myblog/source/_posts (master)# master =&gt;master 分支 web页面（服务器）修改-&gt;同步-&gt;本地 1.在web页面修改 2.在本地仓库中执行：git pull origin master 3.git pull [&lt;远程仓库名&gt; &lt;分支名&gt;] 本地修改-&gt;同步-&gt;web页面（服务器） 1.本地修改：vim，右击创建 2.标记待添加到仓库： 1git add liu.txt 配置邮箱、用户名(必须配置此项才能提交数据到仓库) 1(master)$ git config user.name 'yourname' (master)$ git config user.email 'youremail@163.com' 提交文件到本地仓库： 1git commit #一定要写备注信息，否则此次提交会被忽略 提交到远程仓库： 1git push origin master 注意：当进行push/commit之前，最好先pull一下 注意： 不要在仓库下进行克隆 当web页面有更新，本地也有更新的时候，注意可能会产生冲突 如果能自动合并的，它会自动合并，不能自动合并的，需要手动合并 Web页面上修改 本地修改、add、commit 提交到远程仓库 本地在push的时候，跟服务器版本有不一致的地方，所以有以上提示，需要先pull pull时，因为本地和远程都修改了同一个文件，无法自动合并，所以进入了merge模式 pull的时候，如果能自动合并的，它会自动合并，不能自动合并的，手动合并 MERGING模式 12345&lt;&lt;&lt;&lt;HEAD 你的修改 ====== 远程仓库的修改 &gt;&gt;&gt;&gt;&gt; 版本号 把自己需要的部分保留，不需要的删除。修改完成后再次add/commit即可退出merge模式 （&gt;&gt;&gt;&gt; ==== &lt;&lt;&lt;&lt;&lt;这些行一定删除） 再次git push到远程仓库 可查看git log日志 在仓库中把califeng文件删除，是否能找回 可以找回 注意： 不要仓库下进行克隆 gitee_python_study (master) master =&gt; master分支 遇到的问题 第一次 push时都需要输入密码 .git/conﬁg [remote “origin”] url = http://git.sanchuangedu.cn:3000/chenxl/python_study.git fetch = +refs/heads/:refs/remotes/origin/ .gitignore 本地-&gt; Web commit 修改文件: vim, touch, mkdir。。。。 标记为暂存状态: git add 提交到本地仓库：git commit 提交到远程仓库：git push 为开源的项目提交代码、只读的项目 写权限=&gt; 删除修改文件 =&gt; push 克隆项目：你自己帐户下的python_study 写代码：根目录下创建以自己名字命名的文件 配置：git config 同步到远程仓库 添加远程仓库 git remote add 名字 仓库地址 git remote add source http://git.sanchuangedu.cn:3000/cali/python_study.git 从远程仓库拉取最新的信息 git pull source master 测试：尝试向source push一点东西 403错误 bigbusiness =》 开发者权限 （读、写）读 fork -&gt; 可以 pull -&gt; 可以 clone -&gt; 可以 开发者 push -&gt; 可以 git clone 克隆 git add 标记 git commit 提交 git pull 拉文件 git push 推文件 git log 查看日志 git status 查看当前状态 git remote (add / remove / -v) 查看远程源 git rm 删除 git mv ﬁle newﬁle 更改文件名 git branch -a 查看所有分支 git checkout 切换分支 git reset git conﬁg 配置 git branch dev 创建新分支 基于当前分支来创建git branch init ca752793c1b6e957636b192777da3ba72da8e35c 基于某一个提交点创建分支 git checkout -b init02 创建init02并切换到分支 git branch -d init 删除分支 注：git的官方文档 https://git-scm.com/book/zh/v2/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中IP地址的配置]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Flinux%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[进入ip地址配置目录1cd /etc/sysconfig/network-scripts 打开配置文件1vim ifcfg-ens33 修改配置文件12345678BOOTPROTO=noneNAME=ens33DEVICE=ens33ONBOOT=yesIPADDR=192.168.0.156NETMASK=255.255.255.0GATEWAY=192.168.0.1DNS1=114.114.114.114 重启网络服务1service network restart 测试配置ip地址1ping www.baidu.com 如下面的差不多就代表配置成功12345[root@chenxianle ~]# ping www.baidu.comPING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=55 time=29.6 ms64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=55 time=30.4 ms64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=55 time=30.2 ms]]></content>
      <categories>
        <category>linux</category>
        <category>IP地址配置</category>
      </categories>
      <tags>
        <tag>ip基本配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux的基本操作]]></title>
    <url>%2F2019%2F06%2F12%2Flinux%2Ftmux%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[如何在linux机器中使用tmux(分屏工具)tmux（介绍）tmux（terminal multiplexer）是Linux上的终端复用神器，可从一个屏幕上管理多个终端（准确说是伪终端）。使用该工具，用户可以连接或断开会话，而保持终端在后台运行。类似的工具还有screen，个人对这二者的使用感受是，用过tmux就再也不想用screen了 更新epel源1yum install epel-release -y 下载tmux工具1yum install tmux -y 开启tmux终端1tmux tmux基本操作打开一个新窗口1ctrl b + " 光标上下切换1ctrl b + 上下方向键 退出tmux1ctrl b + d 删除光标所在一个tmux窗口1ctrl b + x 列出所有命令1tmux list-command Tmux的快捷键使用说明： Ctrl+b 激活控制台；此时以下按键生效 系统操作 ? 列出所有快捷键；按q返回 d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 D 选择要脱离的会话；在同时开启了多个会话时使用 Ctrl+z 挂起当前会话 r 强制重绘未脱离的会话 s 选择并切换会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 窗口操作 c 创建新窗口 &amp; 关闭当前窗口 数字键 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口；这样便于识别 . 修改当前窗口编号；相当于窗口重新排序 f 在所有窗口中查找指定文本 面板操作 ” 将当前面板平分为上下两块 % 将当前面板平分为左右两块 x 关闭当前面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 注：详细的请查看参考资料 参考资料https://www.cnblogs.com/kevingrace/p/6496899.html]]></content>
      <categories>
        <category>linux</category>
        <category>linux分屏工具</category>
      </categories>
      <tags>
        <tag>linux分屏工具</tag>
        <tag>tmux的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题31-45]]></title>
    <url>%2F2019%2F06%2F11%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%9831-45%2F</url>
    <content type="text"><![CDATA[31. filter、map、reduce的作用？filter：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）。 filter(function or None, sequence) -&gt; list, tuple, or string：入参为函数和列表/元组/字符串，返回值为item列表/元组/字符串。 map:对sequence中的item依次执行function(item)，将执行结果function(item)组成一个List返回。 map(function, sequence[, sequence, …]) -&gt; list：入参是为函数和列表/元组/字符串，返回值为function(item)列表。 reduce:对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用。function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。 reduce(function, sequence[, initial]) -&gt; value：入参是为函数和列表/元组/字符串和初始值，返回值为数值。32. 常用的 Python 标准库都有哪些?​ os、time、random、pymysql、threading、multiprocess、queue33. 至少列举8个常用模块都有那些?​ requests、re、md5、hashlib、django、sys、math、random、time 34. re的match和search区别？​ match:只匹配一个，从字符串开头进行匹配，如果字符串开始不符合正则表达式，则匹配失败，函数返回None search:只匹配一次，在字符串中进行匹配，直到找到一个匹配，否则也返回None35. 什么是正则的贪婪匹配？重复运算符在默认条件下是贪婪的，匹配尽可能多的字符36. 介绍一下 except 的作用和用法?Python的except用来捕获所有异常， 因为Python里面的每次错误都会抛出 一个异常，所以每个程序的错误都被当作一个运行时错误。37. 在 except 中 return 后还会不会执行 finally 中的代码?怎么抛出自定义异常?（1）不管有木有出现异常，finally块中代码都会执行； （2）当try和catch中有return时，finally仍然会执行； （3）finally是在return语句执行之后，返回之前执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前就已经确定了； （4）finally中如果包含return，那么程序将在这里返回，而不是try或catch中的return返回，返回值就不是try或catch中保存的返回值了38. Python 的魔法方法?​ __init__：通过此方法我们可以定义一个对象的初始操作 __new__：是用来创建类并返回这个类的实例 __del__ ：在对象生命周期调用结束时，__del__ 方法会被调用，39. init和new的区别? __init__: __init__方法通常用在初始化一个类实例的时候 __new__:__new__方法接受的参数虽然也是和 __init__一样，但 __init__是在类实例创建之后调用，而 __new__方法正是创建这个类实例的方法。 __init__和__new__最主要的区别在于：__init__通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。__new__通常用于控制生成一个新实例的过程。它是类级别的方法。 40. 说明一下 os.path 和 sys.path 分别代表什么?(1)os.path 主要是用于对系统路径文件的操作。 (2)sys.path 主要是对Python解释器的系统环境参数的操作（动态的改变Python解释器搜索路径）。41. Python 的 sys 模块常用方法?sys.argv#命令行参数List，第一个元素是程序本身路径 sys.path#返回模块的搜索路径，初始化时使用PYTHONPATH环境变里的值 sys.modules.keys（）#返回所有已经导入的模块列表 sys.modules#返回系统导入的模块字段，key是模块名，value是模块 sys.exc_info（）#获取当前正在处理的异常类，exc_type、exc_value、exc_traceback当前处理的异常详细信息 sys.exit（n）#退出程序，正常退出时exit（e) sys.hexversion#获取Python解释程序的版本值，16进制格式如：0x020403F0 sys.version#获取Python解释程序的版本信息 sys.platform#返回操作系统平台名称 sys.maxint#最大的Int值 sys.stdout#标准输出 sys.stdout.write（“aaa&apos;）#标准输出内容 sys.stdout.writelines（）#无换行输出 sys.stdin#标准输入 sys.stdin.read（）#输入一行 sys.stderr#错误输出 sys.exc_clear（）#用来清除当前线程所出现的当前的或最近的错误信息 sys.exec_prefix#返回平台独立的python文件安装的位置 sys.byteorder#本地字节规则的指示器，big-endian平台的值是‘big’，little-endian平台的值是little sys.copyright#记录python版权相关的东西 sys.api_version#解释器的c的API版本 sys.version_info#’final表示最终，也有‘candidate’表示候选，表示版本级别，是否有后继的发行 sys.getdefaultencoding（）#返回当前你所用的默认的字符编码格式 sys.getfilesystemencoding（）#返回将Unicode文件名转换成系统文件名的编码的名字 sys.builtin_module_names#Python解释器导入的内建模块列表 sys.executable#Python解释程序路径 sys.getwindowsversion（）#获取indows的版本 sys.stdin.readline（）#从标准输入读一行， sys.stdout.write（a）屏幕输出a sys.setdefaultencoding（name）#用来设置当前默认的字符编码（详细使用参考文档） sys.displayhook（value）#如果value非空，这个函数会把他输出到sys.stdout（详细使用参考文档）42. os和sys模块的作用？​ os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。43. 读取文件的几种方法的区别?（1）直接打开就读：虽然f是一个文件实例，但可以通过以上方式对每一行进行循环处理了，处理时每一行是一个字符串str,而且这个是速度最快最简洁的方法 （2）用read（）打开：这个函数把文件全部内容一次性读到一个字符串中。就是一坨的那种，如果把ff用循环读取的方式输出，会是一个一个字符，因为ff是字符串，本质上是tuple （3）用readlines():这个函数将文件所用内容以行为区分读到一个列表中 ，列表中的每一个元素是一行；lines是list，line 是str （4）用readline():这种方式是一行一行的读，非常的省内存，当文件巨大的情况下是有好处的44. 谈谈你对面向对象的理解？​ 面向对象编程是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象45. Python面向对象中的继承有什么特点？继承更多了是为了多态，也可提升代码的复用程度。 特点： 在继承中基类的构造（init()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用； Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；]]></content>
      <categories>
        <category>python面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
        <tag>31-45</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题16-30]]></title>
    <url>%2F2019%2F06%2F11%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%9816-30%2F</url>
    <content type="text"><![CDATA[16. Python3和Python2中 int 和 long的区别？​ Python 2有为非浮点数准备的int和long类型。int类型的最大值不能超过sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个L来定义长整型，显然，它比int类型表示的数字范围更大。 Python 3里，只有一种整数类型int，大多数情况下，它很像Python 2里的长整型。由于已经不存在两种类型的整数，所以就没有必要使用特殊的语法去区别他们。17. 4G 内存怎么读取一个 5G 的数据?​ (1)可以通过生成器，分多次读取，每次读取数量相对少的数据（比如 500MB）进行处理，处理结束后在读取后面的 500MB 的数据 (2)可以通过 linux 命令 split 切割成小文件，然后再对数据进行处理，此方法效率比较高。可以按照行数切割，可以按照文件大小切割。18. read、readline 和 readlines 的区别?​ read() ： 一次性读取整个文件内容。推荐使用read(size)方法，size越大运行时间越长 readline() ：每次读取一行内容。内存不够时使用，一般不太用 readlines() ：一次性读取整个文件内容，并按行返回到list，方便我们遍历19. 文件操作时：xreadlines和readlines的区别？在Python 2里，文件对象有一个xreadlines()方法，它返回一个迭代器，一次读取文件的一行。这在for循环中尤其有用。 在Python 3里，xreadlines()方法不再可用了，可改为for line in a_file。20. 列举布尔值为False的常见值？0，空字符串，空元组，空列表，空字典21. 字符串、列表、元组、字典每个常用的5个方法？​ 字符串： find() replace() split() join() strip() 列表： append() remove() pop() reverse() sort() 元组： sort() tuple + index() count() 字典： items() keys() values() del() pop()22. lambda表达式格式及应用场景? 用lambda函数的好处?格式：lambda x: x+1 场景：配合map、reduce等高阶函数使用，或作为列表元素排序的key23. pass的作用？continue的作用? break的作用?pass的作用：空语句，什么也不做，占坑；保证结构的完整性，可以以后实现 continue的作用：跳出本次循环 break的作用：结束循环24. arg 和*kwarg作用？实现了不定长传参 其中args为可变长参数，允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple； *kw为关键字参数，允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。25. is和==的区别is对比内存地址是否一致； == 对比值是否相等26. 简述Python的深浅拷贝以及应用场景？浅拷贝指仅仅拷贝数据集合的第一层数据 深拷贝指拷贝数据集合的所有层 对于只有一层的数据集合来说深浅拷贝的意义是一样的，比如字符串，数字，还有仅仅一层的字典、列表、元祖等。 对于 数字和字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。场景: 数据完整备份（隔离）27. 拷贝的注意点?(1)拷贝的对象是可变类型还是不可变类型 (2)拷贝后是否允许两个变量同时操控同一内存空间28. Python垃圾回收机制？Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。29. Python的可变类型和不可变类型？​ 不可变类型:数值类型（int和float）、字符串str、元组tuple 可变类型:列表list、字典dict、集合set30. 列举常见的内置函数？sum：对元素类型是数值的可迭代对象中的每个元素求和 int：根据传入的参数创建一个新的整数 range：根据传入的参数创建一个新的range对象 sorted：对可迭代对象进行排序，返回一个新的列表 help：返回对象的帮助信息 dir：返回对象或者当前作用域内的属性列表 type：返回对象的类型，或者根据传入的参数创建一个新的类型 len：返回对象的长度 format：格式化显示值]]></content>
      <categories>
        <category>python面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
        <tag>16-30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题1-15]]></title>
    <url>%2F2019%2F06%2F11%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%981-15%2F</url>
    <content type="text"><![CDATA[Python和Java、PHP、C、C#、C++等其他语言的对比？​ （1）Java:优点----简单性、面向对象性、健壮性、跨品台性、高性能（自动垃圾回收机制）、多线程、动态性、安全性。 缺点----运行速度相对于C/C++有些缓慢了，这是机制原因导致的。 适用于----网页、企业级开发、普通应用软件、游戏后台。 （2）PHP:优点----跨平台，性能优越；语法简单，入门快；目前主流技术都支持；有比较完整的支持；有很多成熟的框架；PHP 5已经有成熟的面向对象体系，能够适应基本的面向对象要求；有成熟的社区来支持PHP的开发；目前已经很多大型应用都是使用PHP；有很多开源的框架或开源的系统可以使用；配置及部署相对简单一些。 缺点----多线程支持不太好，大多数时候我们只能简单的模拟去实现的；对语法不太严谨；PHP的解释运行机制繁琐。 适用于----主要是网络前端，用于生成网页。也可以整个web服务器都用php，比如很多论坛引擎。 （3）C:优点----简洁紧凑、灵活方便;运算符丰富;数据结构丰富;C是结构式语言;C语法限制不太严格，程序设计自由度大;C语言允许直接访问物理地址，可以直接对硬件进行操作;C语言程序生成代码质量高，程序执行效率高;C语言适用范围大，可移植性好;C语言有一个突出的优点就是适合于多种操作系统;有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护. 缺点----运算符和运算优先级过多，不便于记忆，语法定义不严格，编程自由度大，对新手不友好。 适用于----系统底层, 驱动, 嵌入式开发。 （4）C#:优点----相比java，有更先进的语法体系、强大的周边。 缺点----没有考虑代码量 （5）C++:优点----可扩展性、高效简洁快速、可移植性、面向对象的特性、强大而灵活的表达能力和不输于C的效率、支持硬件开发、程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障、通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便 适用于----游戏开发, 大规模, 高性能, 分布式要求的程序开发。 （6）Python:优点----简单、易学、免费开源、高层语言、可移植性、解释性、面向对象、可扩展性、可嵌入性、丰富的库、 缺点----运行速度慢，架构选择台繁琐 适用于----信息安全，大数据处理，数据可视化机器学习，物联网开发，各大软件的api，桌面应用，都需要python简述解释型和编译型编程语言？​ (1)编译型语言: 把源程序的每一条语句都编译成机器语言，并保存为二进制文件，运行时计算机就可以直接以机器语言来运行此程序 (2)解释型语言: 只是在程序执行时，才会一条一条的解释成机器语言给计算机执行​ 代码中要修改不可变数据会出现什么问题? 抛出什么异常？​ 代码会报错，抛出TypeError异常 可变数据类型：列表list和字典dict，集合set 不可变数据类型：基本数据类型（int, float, string）元组tupleprint 调用 Python 中底层的什么方法?​ print方法调用sys.stdout.write方法。就是往控制台打印字符串。简述你对 input()函数的理解?​ 在Python3中，input（）获取用户输入，不论用户输入什么，获取到的都是字符串类型。 在Python2中有raw_input() input(),raw_input()在Python3中的input()作用一样，input()输入什么数据类型，获取到的就是什么数据类型。Python解释器种类以及特点？​ Cpython:默认Cpython解释器，c语言实现 Ipython:基于Cpython之上的一个交互式解释器 Jpython:java实现，python代码会先转化成Java字节码 IronPython:C#实现 PyPy:python实现的python解释器pypy运行效率高Python2 中 range 和 xrange 的区别?​ 两者用法大致相同，不同的是range返回的结果是一个列表，而xrange的结果是一个生成器，前者是直接开辟一块内存空间来保持列表，后者是边循环边使用，只有在使用的时候才会开辟内存空间，所以当列表很长时，使用xrange性能比range好。位和字节的关系？​ 1 字节 = 8 位 1 Byte = 8 bit 1 B = 8 bb、B、KB、MB、GB 的关系？​ 1 GB = 1024 MB 1 MB = 1024 KB 1 KB = 1024 B 1 B = 8 bit请至少列举5个 PEP8 规范（越多越好）。​ （注：在python3中） 1.缩进: 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。 2.变量: 常量--大写加下划线 私有变量--小写和一个前导下划线--_value 内置变量--小写,两个前导下划线和两个后置下划线--__init__ 3.空行：顶级定义之间空2行, 方法定义之间空1行，顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行. 4.空格：按照标准的排版规范来使用标点两边的空格，括号内不要有空格，按照标准的排版规范来使用标点两边的空格 5.导入格式：每个导入应该独占一行，导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组: 标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.python递归的最大层数？递归函数停止的条件?​ python递归的最大层数为：3221（根据查的百度：得到的最大数字在3925-3929之间浮动，这个是和计算机有关系的，不然也不会是一个浮动的数字了） 停止的条件： （1）判断递归的次数是否达到某一个限定值 （2）判断运算的结果是否达到某个范围等，根据设计的目的来选择ascii、unicode、utf-8、gbk 区别？​ 常见字符集：ASCII字符集、GB2312、Uniclde字符集 常见字符编码：UTF ASCII码:在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit），有0和1两种状态，因此，8个二进制位可以组合出256种状态，这被称为字节（byte)。 GBK码:GBK编码是对GB2312的扩展，完全兼容GB2312。采用双字节编码方案，剔出xx7F码位，共23940个码位，共收录汉字和图形符号21886个。 Unicode码：有一种编码，将世界上所有的符号都纳入其中，每一种符号都给予独一无二的编码，那么乱码问题就不会存在了。因此，产生了Unicode编码，这是一种所有符号的编码。 UTF8字符编码：UTF8就是在互联网中使用最多的对Unicode的实现方式。字节码和机三元运算规则以及应用场景？器码的区别？​ 机器码是电脑CPU直接读取运行的机器指令，是电脑的CPU可直接解读的数据，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到； 字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。三元运算规则以及应用场景？i = A if condition else B，主要运用与结构简单的条件语句，这样可以节省代码列举 Python2和Python3的区别？​ *核心类区别：* 1.Python3对Unicode字符的原生支持。 Python2中使用ASCII码作为默认编码方式导致string有两种类型str和Unicode，Python3中只支Unicode类型的string。 2.Python3中采用的是绝对路径的方式进行import。 Python2中相对路径的import会导致标准库导入变得困难（同一目录下有file.py，如何同时导入这个文件和标准库文件file）。Python3中这一点被修改了，如果还需要导入同一目录的文件必须使用绝对路径，否则只能使用相关导入的方式来进行导入。 3.Python2中存在老式类和新式类，Python3中统一采用新式类。 新式类申明要求继承object，必须使用新式类应用多重继承。 4.Python3使用更加严格的缩进。 Python2的缩进机制中，一个tab和8个space是等价的，所以在缩进中同时允许tab和space在代码中共存。这种等价机制会导致部分IDE使用存在问题。Python3中1个tab只能找另一个tab代替，因此tab和space共存会导致报错：TabError：inconsistent use of tabs and spaces in indentaion. *废弃类差别：* 1. print 语句被 Python3 废弃，统一使用 print 函数 2. exec 语句被 python3 废弃，统一使用 exec 函数 3. execfile 语句被 Python3 废弃，推荐使用 exec(open(&quot;./filename&quot;).read()) 4. 不相等操作符&quot;&lt;&gt;&quot;被 Python3 废弃，统一使用&quot;!=&quot; 5. long 整数类型被 Python3 废弃，统一使用 int 6. xrange 函数被 Python3 废弃，统一使用 range,Python3 中 range 的机制也进行修改并提高了大数据集生成效率 7. Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换： mydict={&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3} mydict.keys() #&lt;built-in method keys of dict object at 0x000000000040B4C8&gt; list(mydict.keys()) #[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;] 8. 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) 9. raw_input 函数被 Python3 废弃，统一使用 input 函数 10. 字典变量的 has_key 函数被 Python 废弃，统一使用 in 关键词 11. file 函数被 Python3 废弃，统一使用 open 来处理文件，可以通过 io.IOBase 检查文件类型 12. apply 函数被 Python3 废弃 13. 异常 StandardError 被 Python3 废弃，统一使用 Exception *修改类差异：* 1. 浮点数除法操作符“/”和“//”的区别： &quot;/&quot;： Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。 python3为真除法，运算结果为float类型。 “//”： Python2 中返回小于除法运算结果的最大整数，从类型上讲，与&quot;/&quot;运算符返回类型逻辑一致。 Python3中与python2作用相同。 2. 异常抛出和捕捉机制的区别。 Python2 1. raise IOError, &quot;file error&quot; #抛出异常 2. except NameError, err: #捕捉异常 Python3 1. raise IOError(&quot;file error&quot;) #抛出异常 2. except NameError as err: #捕捉异常 3. for循环中变量值区别。 Python2 中，for循环会修改外部相同名称变量的值。 i=1 print(&apos;comprehension: &apos;, [i for i in range(5)]) print(&apos;after: i=.&apos;,i) #i=4 Python3中，for循环不会修改外部相同名称变量的值。 i=1 print(&apos;comprehension: &apos;, [i for i in range(5)]) print(&apos;after: i=.&apos;,i) #i=1 4. round函数返回值区别 Python2中，round函数返回float类型值。 isinstance(round(15.5),float) #True Python3中，round函数返回int类型值。 isinstance(round(15.5),int) #True 5. 比较操作符的区别。 Python2中任意两个对象都可以比较。 Python3中只有同一类型数据的对象才可以进行比较。]]></content>
      <categories>
        <category>python面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
        <tag>1-15</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP协议-应用层问题在浏览器里输入https://www.baidu.com 一个回车后，浏览器里会显示百度的首页，请详细说下背后发送什么事情，越细致越好？ DNS域名解析：浏览器缓存、系统缓存、路由器、ISP的DNS服务器、根域名服务器。把域名转化成IP地址。 与IP地址对应的服务器建立TCP连接，经历三次握手：SYN，ACK、SYN，ACK 以get，post方式发送HTTP请求，get方式发送主机，用户代理，connection属性，cookie等 获得服务器的响应，显示页面 如果打开https://www.baidu.com网站，会有哪些问题，你如果排除？https协议的实现原理–》加密的原理http协议：超文本传输协议 特点：明文 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 ​ site–&gt;站点–&gt;网站 website–&gt;网站 ​ page–&gt;页面 ​ URL：例如： http://hn.qq.com/a/20190118/002018.html ​ URL即统一资源定位符(Uniform Resource Locator)，用来唯一地标识万维网中的某一个文档。URL由协议、主机和端口(默认为80)以及文件名三部分构成。 https协议：加密的超文本传输协议 特点：密文 html语言 最常见的超文本格式是超文本标记语言 搭建一个属于自己的网站1.准备一个linux系统，确保可以上网123ifup ens33 #激活网卡ip add #查看ip地址ping www.baidu.com #测试你的linux机器是否可以和baidu通信 2.安装httpd 和 epel-release软件 httpd 提供web服务器的软件 ​ 命令：yum install httpd epel-release -y epel-release —&gt;这是一个软件源头的软件—》提供很多的软件可以下载 安装nginx web服务器软件 ​ 命令： yum install nginx -y ​ nginx是一个俄罗斯人开发的web服务器软件 补充 ​ mirror：镜像 另外一个地方和原来的服务器里的内容，一模一样。 源码下载，编译安装 1curl -O http://nginx.org/download/nginx-1.17.1.tar.gz 3.启动nginx软件 yum 安装的nginx启动 1234命令： service nginx start #开启nginx服务Redirecting to /bin/systemctl start nginx.service #表示成功启动命令： service nginx stop #停止nginx服务Redirecting to /bin/systemctl stop nginx.service #表示成功关闭 编译安装nginx启动 12cd /usr/local/nginx/sbin #进入安装目录./nginx #启动nginx 补充yum install lsof -y #安装lsof命令 lsof 软件是用来查看服务器里那个端口被那个程序使用了 1lsof -i:80 #查看80端口被那个程序使用了 端口号和程序之间的关系？ ​ 只有对外提供服务的程序会占用端口。 ​ 端口号—》窗口 ​ 1-1024 系统内置的端口–》很经典的使用端口 ​ 基本上都会被占了 ​ 1-65535 一共有这么多可以用的端口号 架构 ​ b/s架构 —》browser server –&gt;方便—》流行 ​ c/s架构 —-》client server —》socket 编程 启动和关闭httpd服务器 ​ service httpd start 开启httpd服务 ​ service httpd stop关闭httpd服务 4.关闭防火墙​ iptables -F 5.查看ip地址​ ip add 6.在windows系统里打开浏览器7.修改网站的首页12cd /usr/share/nginx/html/ #存放网页的目录ls #查看当前目录的文件及文件夹 ​ 访问window机器下的index.html ​ index.html 首页：网站访问的第一个页面 –》入口 ​ vim index.html ​ 编辑index.html页面 web服务器软件 nginx httpd ​ apache是httpd软件的名字 tomcat 修改nginx web服务的80端口—-改为8080端口 cd /etc/nginx/ ​ 进入文件修改配置文件 vim nginx.conf ​ 编辑配置文件 service nginx restart ​ Redirecting to /bin/systemctl restart nginx.service ​ 表示成功 修改配置文件后一定要重启一下服务 URL 域名： domain name ​ www.baidu.com –》ip ​ 域名：baidu.com ​ 主机名：www ​ www只是baidu.com这个域里的一个主机的名字 http协议 请求报文 —》request：即从客产端（浏览器）向Web服务器发送的请求报文。 GET 方法：去索取内容 POST 方法： 提交 GET和POST区别 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded或multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET方法向URL 添加数据；URL的长度是受限制的（URL的最大长度是2048个字符）。 无限制。 对数据类型的限制 只允许ASCII字符。 没有限制。也允许二进制数据。 安全性 与POST相比，GET的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用GET！ POST比GET更安全，因为参数不会被保存在浏览器历史或web服务器日志中。 可见性 数据在URL中对所有人都是可见的。 数据不会显示在URL中。 重点的首部字段 host:访问的网址 accept： 接受的内容 accept-language：语言 user-agent： 客户机的浏览器和系统的信息 accept-encoding： 编码 connection: 是否是长连接 响应报文 –》response：从Web服务器到客户机（浏览器）的应答。 状态码 Connection: keep-alive Date: Fri, 18 Jan 2019 08:31:31 GMT Server: nginx/1.12.2（web服务器的软件名） type: set-cookie 版本 最新2.0版本 现在http协议的版本： ​ HTTP/1.1版本 长连接 keepalive_timeout 65； 持久性连接：在一个连接中，可以进行多次文档的请求和响应。 服务器在发送完响应后，并不立即释放连接，浏览 器可以使用该连接继续请求其他文档。连接保持的 时间可以由双方进行协商。 Connection: keep-alive 短连接 非持久性连接：即浏览器每请求一个Web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放 无状态性：是指同一个客户端（浏览器）第二次访问同个Web服务器上的页面时，服务器无法知道这个客户曾经访问过。HTTP的无状态性简化了服务器的设计，使其更容易支持大量并发的HTTP请求。（主要为了支持大并发） 状态码 200：访问成功，服务器正常响应请求 301：网页位置发生变化 304：Not Modified —》按CTRL+F5 强制刷新网页内容，不从缓存里读取网页内容 403：服务器里的网页设置了权限不让用户访问 Forbidden 404：网页不存在 5**：服务器的内部问题 HTTP 500：服务器遇到错误，无法完成请求 HTTP 502：网关错误 Error 501：未实现 cookie和session 用来保存客户的信息（用户名，密码、购物车的信息） cookie：数据存储在浏览器端（客户端） https://baijiahao.baidu.com/s?id=1612804856429135825&amp;wfr=spider&amp;for=pc 方便与JavaScript交换数据 方便获取用户信息 session：（会话）数据存储在服务器 高效、安全、不依赖浏览器端环境、服务器端会为每一个用户用一个ID来标识 一次连接就会产生一个session 代理 http 代理 proxy server 代理服务器：中间的一个服务器，代理大家去上网 http://http.taiyangruanjian.com/newrecharge/ user-agent：用户代理–》浏览器 浏览器代人去访问了服务器 http2.0和http1.1的差异 Http和Https的区别（面试常考题） https://blog.csdn.net/qq_38289815/article/details/80969419?tdsourcetag=s_pctim_aiomsg CDN CDN的全称是Content Delivery Network，即内容分发网络 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 精准调度 秒级加速 降低访问 协议 应用层：ftp、http、https、rsync http:80端口 https:443端口 提供web服务的软件都能读懂http协议： 常见web服务器软件：nginx、Apache、Tomcat、IIS、Django、flask 常见浏览器：chrome、Firefox、curl 编译安装nginx的配置文件各项配置详细解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#user nobody; #以哪个用户身份后动nginx进程--》worker进程worker_processes 1; #启动动1个工作进程，这个参数和CPU核心数量一致#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024; #启动1024个线程去接待用户的请求&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] "$request" ' # '$status $body_bytes_sent "$http_referer" ' # '"$http_user_agent" "$http_x_forwarded_for"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #超时时间65s #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; minme.types：规定哪些程序对应哪些文件类型—&gt;后缀名 nginx可以调用对应的程序去打开 1/usr/local/nginx/conf/minme.types]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http协议</tag>
        <tag>nginx配置</tag>
        <tag>抓包工具的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog添加搜索功能]]></title>
    <url>%2F2019%2F05%2F30%2Fblog%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[添加搜索功能插件安装直接在自己的博客文件夹下（我的是blog）点击鼠标右键选择Git Bash Here 1npm install hexo-generator-searchdb --save 修改站点配置文件 路径：blog/_config.yml，找到Extensions，在下面插入如下代码 12345search: path: search.xml field: post format: html limit: 10000 注：每个冒号后面都有一个空格 修改主题配置文件 路径：blog/themes/next/_config.yml，找到local_search，把false改为ture 12local_search: enable: false 改为： 12local_search: enable: true]]></content>
      <categories>
        <category>Hexo+Next GitPages个人博客</category>
      </categories>
      <tags>
        <tag>搜索功能</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的使用]]></title>
    <url>%2F2019%2F05%2F28%2Fmysql%2FMySQL%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MySQL的使用技巧如果不知道pstree命令可以使用 yum provides pstree 12[root@mysql-2 ~]# yum provides pstree[root@mysql-2 ~]# yum install psmisc -y https://wx4.sinaimg.cn/mw690/006BsDmEgy1g3mr7gz0pij30jf09a3yq.jpg pstree命令：用来查看进程树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@mysql-2 ~]# pstree -p # 查看进程树结构，并且显示pid号systemd(1)─┬─NetworkManager(5474)─┬─&#123;NetworkManager&#125;(5518) │ └─&#123;NetworkManager&#125;(5521) ├─VGAuthService(5444) ├─auditd(5422)───&#123;auditd&#125;(5423) ├─chronyd(5457) ├─crond(5478) ├─dbus-daemon(5455) ├─irqbalance(5449) ├─login(5481)───bash(8235) ├─lvmetad(2799) ├─master(6082)─┬─pickup(15979) │ └─qmgr(6099) ├─mysqld_safe(5943)───mysqld(6034)─┬─&#123;mysqld&#125;(6848) │ ├─&#123;mysqld&#125;(6962) │ ├─&#123;mysqld&#125;(6963) │ ├─&#123;mysqld&#125;(6964) │ ├─&#123;mysqld&#125;(6965) │ ├─&#123;mysqld&#125;(6966) │ ├─&#123;mysqld&#125;(6967) │ ├─&#123;mysqld&#125;(6968) │ ├─&#123;mysqld&#125;(6969) │ ├─&#123;mysqld&#125;(6970) │ ├─&#123;mysqld&#125;(6971) │ ├─&#123;mysqld&#125;(6973) │ ├─&#123;mysqld&#125;(7453) │ ├─&#123;mysqld&#125;(7454) │ ├─&#123;mysqld&#125;(7455) │ ├─&#123;mysqld&#125;(7456) │ ├─&#123;mysqld&#125;(7457) │ ├─&#123;mysqld&#125;(7464) │ ├─&#123;mysqld&#125;(7465) │ ├─&#123;mysqld&#125;(7466) │ ├─&#123;mysqld&#125;(7467) │ ├─&#123;mysqld&#125;(7468) │ ├─&#123;mysqld&#125;(7469) │ ├─&#123;mysqld&#125;(7470) │ ├─&#123;mysqld&#125;(7690) │ ├─&#123;mysqld&#125;(7691) │ ├─&#123;mysqld&#125;(15744) │ ├─&#123;mysqld&#125;(15790) │ ├─&#123;mysqld&#125;(16005) │ ├─&#123;mysqld&#125;(16006) │ └─&#123;mysqld&#125;(16007) ├─polkitd(5447)─┬─&#123;polkitd&#125;(5458) │ ├─&#123;polkitd&#125;(5473) │ ├─&#123;polkitd&#125;(5503) │ ├─&#123;polkitd&#125;(5504) │ ├─&#123;polkitd&#125;(5505) │ └─&#123;polkitd&#125;(5506) ├─rsyslogd(5784)─┬─&#123;rsyslogd&#125;(5892) │ └─&#123;rsyslogd&#125;(5901) ├─sshd(5777)─┬─sshd(15703)───bash(15705)───mysql(15789) │ ├─sshd(15750)───bash(15752) │ └─sshd(15977)───bash(15980)───pstree(16054) ├─systemd-journal(2780) ├─systemd-logind(5475) ├─systemd-udevd(2807) ├─tuned(5779)─┬─&#123;tuned&#125;(7331) │ ├─&#123;tuned&#125;(7332) │ ├─&#123;tuned&#125;(7376) │ └─&#123;tuned&#125;(7593) └─vmtoolsd(5454)───&#123;vmtoolsd&#125;(5511) 查看MySQL的进程1234[root@mysql-2 ~]# ps aux|grep mysqlroot 7321 0.0 0.0 11816 1620 ? S 3月10 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 7417 0.0 9.9 1571636 185360 ? Sl 3月10 0:16 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pidroot 19744 0.0 0.0 112728 988 pts/2 S+ 10:10 0:00 grep --color=auto mysql mysqld_safe和mysqld进程，他们之间的关系是什么？答：mysqld_safe是mysqld进程的父进程mysql数据库是一个进程里启动很多线程的程序。只要有人远程连接到mysqld进程，就会产生一个线程去接待。完成相关的数据库的操作。 进程里包含很多线程进程占用的资源多（内存、cpu等），线程占用的资源少，但是作用都差不多，都可以用来处理操作。1个进程里可以启用很多额线程。 当mysqld进程没有启动的时候，是不能连接到mysql数据库里的1234[root@mysql-2 support-files]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)[root@mysql-2 support-files]# 连接mysql的2种方式：通过文件socket：同一台电脑里的不同的进程之间，可以使用文件socket来通信。 123[root@mysql-2 support-files]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2) --》说明文件socket 不存在 -S 指定mysql的socket文件在路径 12345678910111213[root@mysql-2 tmp]# mysql -S /tmp/mysql.sock -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. 修改mysql的socket文件的路径** my.cnf 的作用是当mysqld进程启动的时候，会读取my.cnf文件里的配置，然后加载运行，启动相应的功能。关于定制mysql的配置，有2个地方：1.在cmake编译的时候，指定配置 1234567[root@changsha-tianlong-db-2 mysql-5.7.25]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \ #mysql安装目录-DMYSQL_DATADIR=/data/mysql \ #数据库文件目录-DSYSCONFDIR=/etc \ #配置文件目录-DMYSQL_USER=mysql \ #运行mysql进行的用户，如果没有需要提前添加用户和用户组-DDEFAULT_CHARSET=utf8 \ #默认字符集-DDEFAULT_COLLATION=utf8_general_ci \ #默认校对规则-DWITH_BOOST=boost #boost库，带boost的源码包只需要这样即可，不带boost源码包需要指明boost目录 2.在配置文件my.cnf里指定 123456789101112[root@mysql-2 tmp]# vim /etc/my.cnf[mysqld_safe]log-error=/var/log/mysql/mysql.log#这是指定mysql的日志文件的路径#指定mysqld_safe进程的配置#需要在mkdir /var/log/mysql 目录，然后使用命令chown mysql:mysql /var/log/mysql#因为mysql进程需要往/var/log/mysql目录里写东西，需要权限，不然不能往目录下写日志[mysqld]socket=/data/mysql/mysql.sock#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置 授权给mysql用户 1234[root@mysql-2 log]# cd /var/log[root@mysql-2 log]# mkdir mysql[root@mysql-2 log]# chown mysql:mysql mysql[root@mysql-2 log]# 重新启动mysqld服务 123456789[root@mysql-2 tmp]# service mysqld restart 重新启动mysqld服务Shutting down MySQL. SUCCESS! Starting MySQL. SUCCESS! [root@mysql-2 tmp]# ps aux|grep mysqlroot 22682 0.6 0.0 11812 1616 pts/1 S 10:57 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 22795 6.0 9.4 1571372 176028 pts/1 Sl 10:57 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pid --socket=/data/mysql/mysql.sockroot 22831 0.0 0.0 112724 984 pts/1 S+ 10:57 0:00 grep --color=auto mysql[root@mysql-2 tmp]# 注释：–basedir=/usr/local/mysql #指定的mysql的安装路径–datadir=/data/mysql #数据存放的目录–plugin-dir=/usr/local/mysql/lib/plugin #插件的目录–user=mysql #使用mysql这个用户启动的–log-error=/var/log/mysql/mysql.log # 日志文件的路径–pid-file=/data/mysql/mysql-2.pid #mysql的进程的pid存放的文件，此文件是方便关闭mysql的时候，去kill 进程–socket=/data/mysql/mysql.sock #指定的socket文件的路径修改了socket文件的路径后，使用mysql命令连接到mysql数据库里，需要指定socket文件的路径 123456789[root@mysql-2 tmp]# ps aux|grep mysqlroot 22682 0.6 0.0 11812 1616 pts/1 S 10:57 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 22795 6.0 9.4 1571372 176028 pts/1 Sl 10:57 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pid --socket=/data/mysql/mysql.sockroot 22831 0.0 0.0 112724 984 pts/1 S+ 10:57 0:00 grep --color=auto mysql[root@mysql-2 tmp]# cat /data/mysql/mysql-2.pid 22795[root@mysql-2 tmp]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2) ‘/tmp/mysql.sock’ (2) –》默认会到/tmp目录下查找使用-S 选项指定 1[root@mysql-2 tmp]# mysql -S /data/mysql/mysql.sock -uroot -p'Sanchuang123#' #指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。 通过网络socketip:port 192.168.0.133:3306 –&gt;网络socket可以实现不同的计算机之间的进程之间的通信。 可以通过-h 192.168.0.133 指定访问的数据库服务器的ip地址，使用网络socket的方式访问-h host 123456789101112131415[root@mysql-2 mysql]# mysql -h 192.168.0.133 -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 12Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 什么是socket？网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。 socket 可以实现不同的进程之间的通信，是不同进程之间通信的一种方式。 12345678910111213141516[root@mysql-2 support-files]# yum install net-tools -y 安装net-tools工具得到netstat命令[root@mysql-2 support-files]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 12290/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6561/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 6861/master tcp 0 0 192.168.0.133:22 192.168.0.188:51832 ESTABLISHED 19720/sshd: root@pt tcp 0 0 192.168.0.133:22 192.168.0.188:51853 ESTABLISHED 19806/sshd: root@pt tcp 0 52 192.168.0.133:22 192.168.0.188:50459 ESTABLISHED 18112/sshd: root@pt tcp6 0 0 :::80 :::* LISTEN 12290/nginx: master tcp6 0 0 :::22 :::* LISTEN 6561/sshd tcp6 0 0 ::1:25 :::* LISTEN 6861/master udp 0 0 127.0.0.1:323 0.0.0.0:* 6270/chronyd udp6 0 0 ::1:323 :::* 6270/chronyd [root@mysql-2 support-files]# 注释：0.0.0.0:80 —–&gt;0.0.0.0表达这台本机上所有的IP地址 网络socket的使用使用SQLyog远程连接到MySQL 1.授权一个用户能远程登录 12mysql&gt; grant ALL on *.* to 'cali'@'%' identified by 'Sanchuang123#';Query OK, 0 rows affected, 1 warning (0.00 sec) 授权cali这个用户可以从任何机器上远程连接过来，使用密码Sanchuang123# 可以对mysql数据库的所有的数据库进行操作。 使用SQLyog远程连接 MySQL里破解密码 第1步：停止MySQL进程的运行 123[root@mysql-2 mysql]# service mysqld stopShutting down MySQL.. SUCCESS! [root@mysql-2 mysql]# 第2步：修改配置文件 1234[root@mysql mysql]# vim /etc/my.cnfuser=mysql #指定启动MySQL进程的用户skip-grant-tables #跳过密码验证#validate-password=off #需要禁用密码复杂性策略 第3步：启动MySQL进程 12[root@mysql mysql]# service mysqld start 启动MySQL进程Starting MySQL. SUCCESS! 第4步：登录MySQL，不接密码 1234567891011121314151617181920212223242526[root@mysql-2 mysql]# mysql -S /data/mysql/mysql.sock -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; set password='123456'; ----》会报错ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statementmysql&gt; flush privileges; ----》刷新权限（会加载原来没有加载的权限表）Query OK, 0 rows affected (0.01 sec)mysql&gt; set password='Sanchuang1234#'; ----》会报错ERROR 1133 (42000): Can't find any matching row in the user tablemysql&gt; set password for 'root'@'localhost' = 'Sanchuang1234#'; ----》修改密码Query OK, 0 rows affected (0.00 sec)mysql&gt; quitBye 第5步：重新修改mysql的配置文件 1234[mysqld]socket=/data/mysql/mysql.sock#user=mysql --》注释掉#skip-grant-tables --》注释掉 *第6步：刷新服务 * 1234[root@mysql-2 mysql]# service mysqld restart #重新刷新服务Shutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS! [root@mysql-2 mysql]# 第7步：验证修改密码是否成功 1[root@mysql-2 mysql]# mysql -S /data/mysql/mysql.sock -uroot -p'Sanchuang1234#' my.cnf配置文件部分配置使用介绍12345678910111213[mysqld]port = 3309 #修改端口号max_connections = 330 #最大并发连接数 ，增大该值需要相应增加允许打开的文件描述符数 max_connect_errors = 100 #如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，open_files_limit = 8192 #设置打开文件的句柄数量，在系统里面可以用ulimit –a 查看，可以使用ulimit -n 65535修改，同时添加到/etc/rc.local里innodb_buffer_pool_size = 1G #指定innodb存储引擎的缓冲池的大小。--》从内存当前拿出多少空间来做缓存使用[mysql] ----&gt;专门针对mysql这个命令的配置auto-rehash #可以在命令可以使用tab键补齐prompt=\\u@\\d \\R:\\m mysql&gt; #在Mysql命令显示用户名和数据库名字、时间[mysqld_safe]log-error=/var/log/mysql/mysql.log 基本的MySQL的操作查看MySQL数据库系统里有哪些库123456789101112[root@mysql-2 mysql]# mysql -uroot -p'Sanchuang1234#' -S /data/mysql/mysql.sockmysql&gt; show databases; #查看MySQL数据库系统里有哪些库+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 创建lizengzhi数据库**1234567891011121314mysql&gt; create database lizengzhi ; #创建lizengzhi数据库Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || lizengzhi || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) 切换当前使用的数据库到lizengzhi123456789mysql&gt; use lizengzhi; #切换当前使用的数据库到lizengzhiDatabase changedmysql&gt; select database(); #查询当前在哪个数据库里+------------+| database() |+------------+| lizengzhi |+------------+1 row in set (0.00 sec) linux内核对一个进程可以打开多少个文件进行了限制，默认情况下一个进程只能打开1024个文件 文件描述符进程对打开的文件进行编号，这个编号就是文件描述符。 12345[root@mysql-2 mysql]# ulimit -aopen files (-n) 1024 #打开的文件数量[root@mysql-2 mysql]# ulimit -n 655350 #临时修改一个进程可以打开的文件数量[root@mysql-2 mysql]# ulimit -n 1000000[root@mysql-2 mysql]# 查看mysql里默认的最大并发数是多少1234567root@(none) 15:37 mysql&gt;show variables like 'max_connections'; #查看max_connections这个变量+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 151 |+-----------------+-------+1 row in set (0.01 sec) 看当前mysql里的所有的变量1root@(none) 15:39 mysql&gt;show variables ; #查看当前mysql里的所有的变量 查看mysql的端口号1234567root@(none) 15:39 mysql&gt;show variables like 'port';+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3309 |+---------------+-------+1 row in set (0.05 sec) 查看打开文件的最大数1234567root@(none) 15:42 mysql&gt;show variables like 'open%';+------------------+-------+| Variable_name | Value |+------------------+-------+| open_files_limit | 5000 |+------------------+-------+1 row in set (0.00 sec) 查看内存的使用情况1234[root@mysql-2 boot]# free -m #查看内存的使用情况（以M为单位显示大小） total used free shared buff/cache availableMem: 1819 369 210 9 1240 1210Swap: 2047 0 2047 查看mysql缓冲池大小1234567root@(none) 15:42 mysql&gt;show variables like 'innodb_buffer_pool_size';+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| innodb_buffer_pool_size | 134217728 |+-------------------------+-----------+1 row in set (0.00 sec) 如何让linux系统开机执行 ulimit -n 655350 ？答案： 将这条命令写入/etc/rc.local文件** 123[root@mysql-2 boot]# vim /etc/rc.local ulimit -n 655350 --》在文件的末尾添加[root@mysql-2 boot]# chmod +x /etc/rc.d/rc.local #需要授予可执行权限，不然不会生效 如果今后有需要开机执行某个命令的需求，建议将命令放到/etc/rc.local里 mysqld服务启动不起来？如何排除?123[root@mysql-2 boot]# service mysqld restartShutting down MySQL.... SUCCESS! Starting MySQL... ERROR! The server quit without updating PID file (/data/mysql/mysql-2.pid). 排错主要看错误提醒和日志文件1[root@mysql-2 boot]# cat /var/log/mysql/mysql.log 2019-03-11T08:18:43.399355Z 0 [ERROR] unknown option ‘–auto-rehash’ –》不知道的选项，只有配置文件里有选项–》配置文件里的配置有问题2019-03-11T08:18:43.399445Z 0 [ERROR] Aborting [ERROR] 错误信息 –》非常重视[Note] 普通的信息 1234567891011[mysqld]socket=/data/mysql/mysql.sockport = 3309open_files_limit = 8192innodb_buffer_pool_size = 256Mauto-rehash ##存放的位置不对prompt=\\u@\\d \\R:\\m mysql&gt; #存放的位置不对#user=mysql#skip-grant-tables#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置 修改配置文件 123[mysql] ---》是在mysql进程里的配置，不是mysqld进程的配置auto-rehashprompt=\\u@\\d \\R:\\m mysql&gt; 修改了配置文件，一定要刷新服务 12[root@mysql-2 boot]# service mysqld startStarting MySQL. SUCCESS! 使用SQLyog来建表建库，认识表和库是什么？库里存放表，表里存放一条一条的信息 查看哪个ip地址连上你的mysql数据库1netstat -anplut 查看当前时间的函数1234567select now();+---------------------+| now() |+---------------------+| 2019-08-27 10:04:11 |+---------------------+1 row in set (0.00 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的各种安装方式]]></title>
    <url>%2F2019%2F05%2F28%2Fmysql%2FMySQL%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MySQL是什么？123456MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是一个软件，用来存放数据。用它来存放数据，特别方便，查找和存储数据都非常方便。MySQL 是一个中小型数据库。MySQL是开源数据库。不是免费的数据库软件。有开源版本的数据库，这个是不要钱。MySQL 的开源版本不要钱。企业版都是需要购买。 哪些地方需要使用数据库？ 12银行、股市、学校、公交车、小区、游戏、网站、快递、导航、税务等只要和钱有关的地方就有数据库 MySQL遵循的是GPL协议 GPL:通用公共许可证（General public license）:一些规定和约定，保持软件继续开源，促进软件发展。 安装MySQL安装linux系统centos7 1810.iso数据库服务器是公司的核心服务器–&gt;配置必须要 下载MySQL软件官方网站https://www.mysql.com/The world’s most popular open source database。世界上最流行的开源数据库。Oracle MySQL Cloud Service (commercial) 云服务器版本MySQL Enterprise Edition (commercial) 企业版MySQL Cluster CGE (commercial) 集群版本MySQL Community Edition (GPL) 社区版 –》免费 MySQL的版本：8版本–》 8.0.155版本–》 5.7MySQL Community Server 5.7.25 安装MySQLrpm包方式安装500M–》linux系统里 1[root@localhost ~]# yum install lrzsz -y #解决传输文件的问题 windows--》linux传文件 安装步骤 解压安装包 1[root@localhost ~]# tar xf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar 安装 1[root@localhost ~]# yum install mysql-community-* mysql-community-server 是MySQL提供服务功能的软件包mysql-community-client 客户端管理需要的工具mysql-community-libs 库文件 librarymysql-community-devel 开发工具和接口程序 developmentmysql-community-test 测试环境软件mysql-community-embedded 嵌入式相关的软件 启动MySQL程序** 12[root@localhost ~]# service mysqld startRedirecting to /bin/systemctl start mysqld.service 查看防火墙和selinux的情况 12345service firewalld stopgetenforcesetenforce 0vim /etc/sysconfig/selinuxSELINUX=disabled mysql daemon 守护进程 –》mysqld守护进程：这个程序是一直运行的，不是运行一下，马上就关闭。因为有人会随时来访问，都可以访问这个进程。 123456[root@localhost ~]# service mysqld status #参看mysql的状态[root@localhost ~]# ps aux|grep mysqld #查看mysqld的进程是否存在mysql 27129 0.3 4.8 1119708 185728 ? Sl 15:13 0:01 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidroot 27172 0.0 0.0 112724 984 pts/0 S+ 15:19 0:00 grep --color=auto mysqld[root@localhost ~]# lsof -i:3306[root@localhost ~]# netstat -anplut|grep mysql mysql会开发3306端口 使用lsof命令查看端口号是否被占用 1234[root@localhost ~]# yum install lsof -y[root@localhost ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 27129 mysql 22u IPv6 76271 0t0 TCP *:mysql (LISTEN) 如何知道本机里开发了哪些端口？ 1234567891011121314[root@localhost ~]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6085/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 6307/master tcp 0 0 192.168.0.37:22 192.168.0.11:57980 ESTABLISHED 14958/sshd: root@pt tcp 0 0 192.168.0.37:22 192.168.0.11:50402 ESTABLISHED 15518/sshd: root@pt tcp 0 52 192.168.0.37:22 192.168.0.11:53222 ESTABLISHED 15890/sshd: root@pt tcp6 0 0 :::3306 :::* LISTEN 15798/mysqld tcp6 0 0 :::22 :::* LISTEN 6085/sshd tcp6 0 0 ::1:25 :::* LISTEN 6307/master udp 0 0 0.0.0.0:68 0.0.0.0:* 15443/dhclient udp 0 0 127.0.0.1:323 0.0.0.0:* 5501/chronyd udp6 0 0 ::1:323 :::* 5501/chronyd 0.0.0.0 本机上任意的ip地址。127.0.0.1 本地的回环测试接口，只能本机自己访问，别的机器不能访问:::3306 本机上任意的ip地址上开启3306端口 –》ipv6 查看别的机器开启了哪些端口？扫描工具nmap 1234567891011[root@localhost ~]# yum install nmap -y #安装nmap软件[root@localhost ~]# nmap 192.168.0.37Starting Nmap 6.40 ( http://nmap.org ) at 2019-05-06 16:39 CSTNmap scan report for 192.168.0.37Host is up (0.000014s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh3306/tcp open mysqlNmap done: 1 IP address (1 host up) scanned in 0.30 seconds 登录MySQL服务器** mysql命令是用来登录mysql服务器的客户端工具 1234[root@localhost ~]# mysql -u root -pEnter password:ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)[root@localhost ~]# 使用密码登录MySQL数据库 1[root@localhost log]# mysql -uroot -p'Sanchuang123xl#' 解释-uroot 指定登录mysql的用户是root user-p’Sanchuang123xl#’ 指定登录的密码 password需要去查看日志，得到临时密码 1234567[root@localhost log]# cd /var/logmysqld.log mysql的日志文件[root@localhost log]# cat mysqld.log |grep "tem"2019-05-06T07:51:53.607329Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2019-05-06T07:51:53.630880Z 1 [Note] A temporary password is generated for root@localhost: =%rIObuds8p&amp;2019-05-06T07:51:57.783188Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables[root@localhost log]# =%rIObuds8p&amp; 是MySQL的临时密码 使用临时密码登录mysql服务器 12345678910111213141516[root@localhost lianxi]# mysql -u root -p'=%rIObuds8p&amp;'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.26Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 重新设置密码第一种方法： 12mysql&gt; set password='Root123#';Query OK, 0 rows affected (0.01 sec) 第二种方法： 1mysql&gt; alter user 'root'@'localhost' identified by 'Root123#'; 显示查看mysql里有多少个数据库 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 退出MySQL1mysql&gt; exit 存放mysql数据文件的目录 1/var/lib/mysql mysql服务安装好后，会自动设置开机启动 如何查看本机里哪些服务是开机启动的？ 123456789[root@localhost ~]# systemctl list-unit-files #查看本机开机的时候，哪些服务是启动的disabled #不启动enabled #启动[root@localhost ~]# systemctl disable firewalld #禁用firewalld服务，开机不启动[root@localhost ~]# systemctl enable firewalld #开机启动firewalld服务[root@localhost ~]# systemctl list-unit-files|grep "mysqld"mysqld.service enabled #表示mysql是开机启动mysqld@.service disabled[root@localhost ~]# windows的客户端远程连接linux里的mysql的软件 1.SQLyog –》第3方公司产品 2.workbench –》mysql官方自己出品关闭防火墙软件 12[root@localhost ~]# service firewalld stop Redirecting to /bin/systemctl stop firewalld.service 查看防火墙规则 12345678910[root@localhost ~]# iptables -L Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 使用SQLyog第1次远程连接的时候，会出现不允许连接，是因为mysql为了安全的考虑，不允许远程登录如果需要远程登录，就需要考虑去授权一个用户能远程登录到mysql，如何授权？ 授权root用户使用密码远程登录1234[root@localhost ~]# mysql -uroot -p'Root123#' mysql&gt; grant ALL on *.* to 'root'@'%' identified by 'Sanchuang123xl#'; 授权root用户可以从任何机器登录到mysql服务器上使用的密码是Sanchuang123xl#Query OK, 0 rows affected, 1 warning (0.05 sec) grant 是数据库里的授权命令ALL 是所有的权限（select、update、delete、insert等）On . 在所有的库所有的表上 mysql.user 表示mysql数据库里的user表‘root’@’%’ 这表示一个用户名是root可以从任何地方登录identified by ‘Sanchuang123#’ 指定密码为Sanchuang123# 源码编译安装—&gt;企业里使用最多方式1.可以开启很多功能2.可以指定安装路径 –》最大的好处因为MySQL需要存放数据，需要大量的磁盘空间，企业里会单独给MySQL一个存放数据的地方。 需要一台干净的linux系统 修改主机名为MySQL2 临时修改主机名 123[root@localhost ~]# hostname mysql-2 [root@localhost ~]# su - root 切换用户到root上一次登录：五 3月 8 09:56:29 CST 2019从 192.168.0.188pts/0 上 永久修改主机名 1234[root@mysql-2 ~]# vi /etc/hostname [root@mysql-2 ~]# vi /etc/hostname [root@mysql-2 ~]# cat /etc/hostname mysql-2 需要mysql的源码包 上传源码包到linux系统 mysql-boost-5.7.25.tar和mysql-5.7.25.tar.gz的差异 percona-xtrabackup、json等软件需要使用boost库，如果你安装的MySQL需要对很多软件进行支持，建议安装ysql-boost-5.7.25.tar 12[root@changsha-tianlong-db-2 ~]# yum install lrzsz -y[root@changsha-tianlong-db-2 ~]# rz 查看官方的安装文档https://dev.mysql.com/doc/refman/5.7/en/source-installation.html也可以百度 mysql 5.7.25编译安装https://www.jianshu.com/p/90769a797b88 解压 1[root@changsha-tianlong-db-2 ~]# tar xf mysql-boost-5.7.25.tar.gz cmake 是一个编译工具和 gcc一样 安装依赖关系包 1[root@changsha-tianlong-db-2 mysql-5.7.25]# yum install cmake ncurses-devel gcc gcc-c++ -y #安装依赖关系包 创建用户和组 1[root@changsha-tianlong-db-2 network-scripts]# useradd -r -s /sbin/nologin mysql -r 创建系统用户（不会创建家目录），一般会修改shell为/sbin/nologin-M 创建用户不建立家目录 123[root@changsha-tianlong-db-2 network-scripts]# id mysqluid=997(mysql) gid=995(mysql) 组=995(mysql)[root@changsha-tianlong-db-2 network-scripts]# 进入解压后的目录，开始编译前的配置 12345678910[root@changsha-tianlong-db-2 ~]# cd mysql-5.7.25/[root@changsha-tianlong-db-2 mysql-5.7.25]#[root@changsha-tianlong-db-2 mysql-5.7.25]# mkdir /data/mysql -p[root@changsha-tianlong-db-2 mysql-5.7.25]#cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \-DMYSQL_DATADIR=/data/mysql \-DSYSCONFDIR=/etc \-DMYSQL_USER=mysql \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci \-DWITH_BOOST=boost 对上面的命令进行说明： 1234567[root@changsha-tianlong-db-2 mysql-5.7.25]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \ #mysql安装目录-DMYSQL_DATADIR=/data/mysql \ #数据库文件目录-DSYSCONFDIR=/etc \ #配置文件目录-DMYSQL_USER=mysql \ #运行mysql进行的用户，如果没有需要提前添加用户和用户组-DDEFAULT_CHARSET=utf8 \ #默认字符集-DDEFAULT_COLLATION=utf8_general_ci \ #默认校对规则-DWITH_BOOST=boost #boost库，带boost的源码包只需要这样即可，不带boost源码包需要指明boost目录 编译和编译安装 12[root@changsha-tianlong-db-2 mysql-5.7.25]# make -j 2 #启用多进程去编译 -j 2 启用2个进程同时进行，目的是为了加快速度[root@changsha-tianlong-db-2 mysql-5.7.25]#make install #安装 启动MySQL 12345[root@changsha-tianlong-db-2 mysql-5.7.25]# cd /usr/local/mysql/ 进入安装目录[root@changsha-tianlong-db-2 mysql]# lsbin COPYING-test include man README shareCOPYING docs lib mysql-test README-test support-files[root@changsha-tianlong-db-2 mysql]# 对mysql的配置文件进行备份 123[root@changsha-tianlong-db-2 mysql]# cp /etc/my.cnf /root #备份[root@changsha-tianlong-db-2 mysql]# &gt;/etc/my.cnf #清空，因为这个文件是mariadb的[root@changsha-tianlong-db-2 bin]# pwd /usr/local/mysql/bin –》存放可执行文件的目录 初始化MySQL 1[root@changsha-tianlong-db-2 bin]# ./mysqld --initialize --user=mysql --basedir=/usr/local/mysql/ --datadir=/data/mysql 复制mysql客户端命令到PATH变量路径里，方便后面使用 1[root@changsha-tianlong-db-2 bin]# cp mysql /usr/bin/ 配置能使用service 方式启动mysql，因为需要一个启动脚本，这个脚本mysql官方给我们提供了，直接复制过去就ok了 12345678[root@changsha-tianlong-db-2 mysql]# cp support-files/mysql.server /etc/init.d/mysqld[root@changsha-tianlong-db-2 mysql]# service mysqld startStarting MySQL.Logging to '/data/mysql/changsha-tianlong-db-2.err'.SUCCESS! [root@changsha-tianlong-db-2 mysql]# service mysqld restartShutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS! [root@changsha-tianlong-db-2 mysql]# 登录mysql，使用临时密码 123456789101112131415[root@changsha-tianlong-db-2 mysql]# mysql -uroot -p'drNo5dIR?OXN'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.25Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; 修改密码 12345mysql&gt; set password='Sanchuang123#'; #修改密码Query OK, 0 rows affected (0.00 sec)mysql&gt; exitBye 退出验证密码是否修改成功 1234567891011121314151617[root@changsha-tianlong-db-2 mysql]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; mysql&gt; quit 退出Bye 安装完后的工作：数据库服务器一般不启用防火墙，主要是考虑性能的问题。会在数据库服务器的前面加一个防火墙。 关闭防火墙firewalld，并且设置开机不要启动。 123456789101112131415[root@changsha-tianlong-db-2 mysql]# service firewalld stop 关闭firewalld服务Redirecting to /bin/systemctl stop firewalld.service[root@changsha-tianlong-db-2 mysql]# systemctl disable firewalld 禁止开机启动Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.[root@changsha-tianlong-db-2 mysql]# iptables -L 查看防火墙规则Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@changsha-tianlong-db-2 mysql]# 关闭selinux 1234567[root@changsha-tianlong-db-2 mysql]# getenforce Enforcing[root@changsha-tianlong-db-2 mysql]# setenforce 0 #临时关闭selinux[root@changsha-tianlong-db-2 mysql]# getenforce Permissive[root@changsha-tianlong-db-2 mysql]# vi /etc/selinux/config [root@changsha-tianlong-db-2 mysql]# cat /etc/selinux/config https://wx3.sinaimg.cn/mw690/006BsDmEgy1g3mr7h2stpj30i00cvq3m.jpg 考虑设置mysql服务开机启动 123456789101112131415[root@changsha-tianlong-db-2 mysql]# systemctl enable mysqld #使用新式方式设置开机启动，提醒不能使用，建议我们使用老式的chkconfig方式mysqld.service is not a native service, redirecting to /sbin/chkconfig.Executing /sbin/chkconfig mysqld on[root@changsha-tianlong-db-2 mysql]# chkconfig mysqld on 设#置mysqld服务开机启动[root@changsha-tianlong-db-2 mysql]#[root@changsha-tianlong-db-2 mysql]#[root@changsha-tianlong-db-2 mysql]# chkconfig --list 注：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。 要列出 systemd 服务，请执行 'systemctl list-unit-files'。查看在具体 target 启用的服务请执行'systemctl list-dependencies [target]'。mysqld 0:关 1:关 2:开 3:开 4:开 5:开 6:关netconsole 0:关 1:关 2:关 3:关 4:关 5:关 6:关network 0:关 1:关 2:开 3:开 4:开 5:开 6:关[root@changsha-tianlong-db-2 mysql]# 重新启动服务器reboot 重启—-init 6poweroff关机进入linux系统 12345678[root@mysql-2 ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 6788 mysql 27u IPv6 37709 0t0 TCP *:mysql (LISTEN)[root@mysql-2 ~]# ps aux|grep mysqldroot 6619 0.0 0.0 115436 1732 ? S 15:43 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 6788 1.7 9.4 1571372 176096 ? Sl 15:43 0:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=mysql-2.err --pid-file=/data/mysql/mysql-2.pidroot 7249 0.0 0.0 112724 984 pts/0 S+ 15:44 0:00 grep --color=auto mysqld[root@mysql-2 ~]# 说明mysql真得是开机启动了 使用SQLyog远程连接到MySQL 授权一个用户能远程登录 1234mysql&gt; grant all on *.* to 'root'@'%' identified by 'Sanchuang123#';Query OK, 0 rows affected, 1 warning (0.02 sec)mysql&gt; 使用SQLyog远程连接注：编译安装mysql的时候，建议内存给大些，给4G，cpu给2个核就可以了服务器一般都是固定IP编译安装：1.编译前的配置（如果编译器是gcc）,主要是用来生成MakeFile文件–》就是编译的时候的配置文件例如：安装到什么位置，哪些功能开，哪些不开？yum install pcre-devel zlib-devel gcc gcc-c++./configure –prefix=/usr/local/nginx2.make 编译 ，根据MakeFile文件进行编译，将源代码编译成二进制文件3.make install 编译安装，其实就是将编译好的二进制文件复制到安装目录去。 yum安装-不建议使用1yum install MySQL -y poweroff 是关机的命令reboot 重新启动init 6 重新启动 centos7里默认的数据库是Mariadb不是mysql，soyum安装的数据库是mariadb mariadb是MySQL的分支 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 数据库排名https://db-engines.com/en/ranking 购买mysql的规矩：一台电脑只能安装一套软件。 根据电脑里的cpu的颗数，颗数越多价格越高]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>安装</tag>
      </tags>
  </entry>
</search>
