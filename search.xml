<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[迭代器和生成器]]></title>
    <url>%2F2019%2F06%2F24%2Fpython%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如何判断一个对象是可迭代对象，迭代器对象或生成器 如何确认一个对象是不是可迭代对象 用Iterable判断 123456789101112131415161718&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; a = &apos;abc&apos;&gt;&gt;&gt;&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; c = (4,5,6)&gt;&gt;&gt; d = &#123;&quot;name&quot;:&quot;tom&quot;,&quot;age&quot;:22&#125;&gt;&gt;&gt; if isinstance(a,Iterable):... print(&quot;a是可迭代对象&quot;)...a是可迭代对象&gt;&gt;&gt; if isinstance(b,Iterable):... print(&quot;b是可迭代对象&quot;)...b是可迭代对象&gt;&gt;&gt; if isinstance(c,Iterable):... print(&quot;c是可迭代对象&quot;)...c是可迭代 判断迭代器 Iterator判断 12345678from collections import Iterable, Iteratorran = range(3)if isinstance(ran,Iterator): print(&quot;ran是迭代器&quot;)else: print(&quot;ran不是迭代器“)输出：ran不是迭代器 ------ - 1234567891011121314是否实现了__iter__和__next__方法from collections import Iterable, Iteratorran = range(3)if isinstance(ran,Iterator): print(&quot;ran是迭代器&quot;)else: print(&quot;ran不是迭代器&quot;)print(ran,dir(ran))ran = iter(ran)print(ran,dir(ran))输出：ran不是迭代器range(0, 3) [&apos;__bool__&apos;, &apos;__class__&apos;, &apos;__contains__&apos;, &apos;__delattr__&apos;, &apos;__dir__&apos;, &apos;__doc__&apos;, &apos;__eq__&apos;, &apos;__format__&apos;, &apos;__ge__&apos;, &apos;__getattribute__&apos;, &apos;__getitem__&apos;, &apos;__gt__&apos;, &apos;__hash__&apos;, &apos;__init__&apos;, &apos;__init_subclass__&apos;, &apos;__iter__&apos;, &apos;__le__&apos;, &apos;__len__&apos;, &apos;__lt__&apos;, &apos;__ne__&apos;, &apos;__new__&apos;, &apos;__reduce__&apos;, &apos;__reduce_ex__&apos;, &apos;__repr__&apos;, &apos;__reversed__&apos;, &apos;__setattr__&apos;, &apos;__sizeof__&apos;, &apos;__str__&apos;, &apos;__subclasshook__&apos;, &apos;count&apos;, &apos;index&apos;, &apos;start&apos;, &apos;step&apos;, &apos;stop&apos;]&lt;range_iterator object at 0x000001AF8A8585F0&gt; [__iter__&apos;, &apos;__next__&apos;, ] 如何判断迭代器 12345678可以使用 isinstance 函数来判断def _(): yield Nonegenerator=type(_())x =( k for k in range(10))print(isinstance(x,generator))输出：true 迭代器与生成器的区别 迭代器 通过iter()方法获得了list的迭代器对象，然后就可以通过next()方法来访问list中的元素了。当容器中没有可访问的元素后，next()方法将会抛出一个StopIteration异常终止迭代器。 生成器 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator） 生成器属于一种特殊的迭代器，而且因为自动创建了iter()和next()，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。 yield 通常和生成器一起使用 异同 通过实现迭代器协议对应的iter()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。 生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义iter()和next()方法。 生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。 如何获取可迭代对象、迭代器与生成器中的数据 可迭代对象 用for循环 迭代器 用next()方法 生成器 用next()方法 用yield from 扩展阅读https://docs.python.org/3/library/stdtypes.html#iterator-typeshttps://anandology.com/python-practice-book/iterators.htmlhttps://docs.python.org/3/reference/expressions.html#yieldexpryield from ： http://blog.theerrorlog.com/yield-from-in-python-3.htmlhttp://blog.csdn.net/mingc0758/article/details/53783001Python中生成器和迭代器的区别 http://blog.csdn.net/u014745194/article/details/70176117]]></content>
      <categories>
        <category>python高阶</category>
        <category>迭代器和生成器</category>
      </categories>
      <tags>
        <tag>集合、元组、列表推导式</tag>
        <tag>可迭代对象</tag>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[raid-廉价磁盘冗余阵列]]></title>
    <url>%2F2019%2F06%2F23%2Flinux%2Fraid-%E5%BB%89%E4%BB%B7%E7%A3%81%E7%9B%98%E5%86%97%E4%BD%99%E9%98%B5%E5%88%97%2F</url>
    <content type="text"><![CDATA[raid-廉价磁盘冗余阵列 raid 磁盘阵列（独立冗余磁盘阵列） 硬raid（推荐）：会有一个raid卡，用来控制这个raid，是正raid的大脑 容错功能 专门有数据处理的芯片 软raid：通过软件来实现raid控制功能，不需要需要硬件。 需要使用电脑的cpu里来处理数据 磁盘阵列（Redundant Arrays of Independent Drives，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个磁盘上 磁盘会坏，坏了就意味着数据丢失 RAID0、RAID1、RAID5、RAID6、RAID10、RAID01 功能： 1.数据冗余 2.容错 3.存取数据速度快 raid0：读写速度快，但是没有容错功能。2块以上磁盘组成。磁盘利用率100%–》条带卷 raid1：镜像卷：2块磁盘组成，有容错功能。磁盘利用率50% raid5：背后的原理是分布校验+条带：可以容错，至少3块磁盘，最多坏一块。 磁盘利用率：（n-1）/n raid6：背后的原理是分布校验+分布校验+条带：可以容错，至少4块磁盘，最多坏2块。 磁盘利用率：（n-2）/n RAID配置总结 级别 RAID0 RAID1 RAID5 RAID6 磁盘数 &gt;=2 2 &gt;=3 &gt;=4 容错功能 无 有 有 较强 读写速度 最快 写入慢 较快较快 较快 磁盘空间利用 100% 50% n-1 n-2 如何知道磁盘坏了？ 1.看磁盘的灯是否亮–》需要人去现场看–》很傻 2.查看raid的数据，里面有显示那些是好的，那些是坏的。–》监控脚本或者程序 软件raid：只能通过Linux系统本身来查看 1cat /proc/mdstat #可以看到raid级别，状态等信息。 硬件raid：最佳的办法是通过已安装的raid厂商的管理工具来查看，有cmdline，也有图形界面 如Adaptec公司的硬件卡就可以通过下面的命令进行查看： 1/usr/dpt/raidutil-L all #可以看到非常详细的信息。 raid的配置是在安装系统之前就配置好了的 裸机–》系统做raid1，数据磁盘做raid5–》安装系统—》存放数据 能自己购买服务器的公司—》有钱的行为 只有真实的服务器需要做raid 购买云服务器的公司不做raid 云服务产商会提供数据不丢失的保障 99.9999% LVM(Logical Volume Manager),逻辑卷管理 动态扩容 分区结构不需要修改]]></content>
      <categories>
        <category>linux高级</category>
        <category>文件系统</category>
        <category>raid</category>
      </categories>
      <tags>
        <tag>raid廉价磁盘冗余阵列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层]]></title>
    <url>%2F2019%2F06%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[计算机网络之网络层 TCP/IP五层协议： 应用层、传输层、网络层、数据链路层、物理层 网络层：ip、arp、icmp3个协议 传输层：tcp、udp ip协议—-internet protocol互联网协议 现在的互联网协议：ipv4 下一代互联网协议：ipv6 IP数据包格式（只记住重点） TTL–&gt;time to live=生命周期 广播与广播域 广播：将广播地址做为目的地址的数据帧 广播域：网络中能接收到同一个广播所有节点的集合 MAC ARP协议：Address Resolution Protocol 地址解析协议 1.request 请求包 源ip：自己的 目的ip：别人的 源mac：自己的 目的mac：000000000000 2.response 响应包 数据链路层里的帧的封装格式 源mac：自己的 目的mac：ffffffffffff 为什么交换机收到arp包会转发？ 为什么叫arp广播？ 如果是arp request包会转发到所有的接口 arp缓存表里的内容是可以更新的。 arp缓存表是在内存里存放的. linux系统中的ARP命令 arp-a：查看ARP缓存表·arp-n 查看ARP缓存表 arp-d：清除ARP缓存 arp-s：绑定ip地址和mac地址。 ICMP协议：是一个“错误侦测与回馈机制”，是通过IP数据包封装的，用来发送错误和控制消息]]></content>
      <categories>
        <category>计算机网络</category>
        <category>网络层笔记</category>
      </categories>
      <tags>
        <tag>网络层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的多进程和多线程]]></title>
    <url>%2F2019%2F06%2F18%2Fpython%2Fpython%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[python的多进程和多线程 进程和进程之间通信，有哪些方式？ 管道 共享内存 信号 kill 是linux中杀死进程的命令 9) SIGKILL 信号类型 –&gt;被强制杀死（都来不及保存数据） 为什么kill进程的时候需要接-9？ 强制杀死，因为-9的信号类型是不能被屏蔽的，所以可以达到强制杀死进程的目的 15) SIGTERM 告诉进程自我终结 signal terminate—&gt;15这种信号是可以被屏蔽的 1) SIGHUP signal HUP—-&gt; 挂起 父进程开启了一堆的子进程，如果把父进程杀死，父会给子进程发HUP信号，操作系统会将所有收到HUP信号的子进程全部杀死 2) SIGINT 中断信号 signal inerrupt—-&gt;按ctrl+c其实就是发中断信号 队列 信号量 socket（槽） 网络socket = ip : port 文件socket 12345678910111213141516from multiprocessing import Processimport timedef foo(i): print(&apos;chlid , arg i is &#123;&#125;&apos;.format(i)) time.sleep(1) print(&apos;child , arg i is &#123;&#125;&apos;.format(i))if __name__ == &apos;__main__&apos;: p_lst = [] for i in range(4): p = Process(target=foo, args=(i,)) p.start() p_lst.append(p) p.join() #[p.join() for p in p_lst] 进程里包含线程，一个进程里可以包含很多线程 进程 ：pcb（process控制块） + 代码 + 数据 线程 ：tcb （thread控制块） + 代码 + 数据 进程消耗资源多（cpu、内存、磁盘、网络等） 线程可以共享进程里的一些公共资源，更加节约系统的资源。 为什么线程在cpu里运行会比进程快？ 线程在上下文切换的时候，因为有公共部分，所以节约很多的时间，有很多的数据不需要切换，直接使用。 为什么线程更加节省资源（cpu、内存）？ 内存空间上：因为线程有公共部分，所以更加节约空间。 多进程更加稳定、但消耗资源多 多线程速度快，但是一个进程被杀死，进程里的线程都杀死，不够稳定]]></content>
      <categories>
        <category>python</category>
        <category>多进程和多线程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>进程间通信方式</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的20个面试题]]></title>
    <url>%2F2019%2F06%2F18%2Fgit%E7%9A%8420%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[GIT和SVN有什么区别？ Git SVN 1. Git是一个分布式的版本控制工具 1. SVN 是集中版本控制工具 2.它属于第3代版本控制工具 2.它属于第2代版本控制工具 3.客户端可以在其本地系统上克隆整个存储库 3.版本历史记录存储在服务器端存储库中 4.即使离线也可以提交 4.只允许在线提交 5.Push/pull 操作更快 5.Push/pull 操作较慢 6.工程可以用 commit 自动共享 6.没有任何东西自动共享 什么是GIT? Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。 与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。 每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。 还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。 在GIT中提交的命令是什么？ git commit -a/-m -a：是指git提交已修改的所有被跟踪文件的新内容。 -m：指备注信息 什么是GIT中的“裸存储库”？ Git 中的 “裸” 存储库只包含版本控制信息而没有工作文件（没有工作树），并且它不包含特殊的 .git 子目录。相反，它直接在主目录本身包含 .git 子目录中的所有内容，其中工作目录包括： 一个 .git 子目录，其中包含你的仓库所有相关的 Git 修订历史记录。 工作树，或签出的项目文件的副本。 GIT是用什么语言编写的？ Git使用 C 语言编写。 GIT 很快，C 语言通过减少运行时的开销来做到这一点。 在GIT中，你如何还原已经push并公开的提交？ 删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我将使用的远程存储库 1git commit -m &quot;commit message&quot; 创建一个新的提交，撤消在错误提交中所做的所有更改。可以使用命令 1git revert &lt;name of bad commit&gt; git pull 和git fetch 有什么区别？ git pull 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。 git fetch 也用于相同的目的，但它的工作方式略有不同。当你执行 git fetch 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 git fetch 之后执行git merge。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式： git pull = git fetch + git merge git 中的“staging area” 或“index”是什么？ 在完成提交之前，可以在称为“staging area”或“index”的中间区域中对其进行格式化和审查；从图中可以看出，每个更改首先在暂存区域中进行验证，称为“stage file”，然后将更改提交到存储库。 https://segmentfault.com/img/bVbtc0c?w=655&amp;h=645 什么是git stash? 通常情况下，一直在处理项目的某一部分时，如果想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，不想把完成了一半的工作的提交，以便以后就可以回到当前的工作。解决这个问题的答案是 git stash。 stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，可以随时重新应用这些更改。 什么是git stash drop? git stash drop命令用于删除隐藏的项目。 默认情况下，它将删除最后添加的存储项，如果提供参数的话，它还可以删除特定项。 如何找到特定提交中已更改的文件列表？ 要获取特定提交中已更改的列表文件，请使用以下命令： git diff-tree -r {hash} 给定提交哈希，这将列出在该提交中更改或添加的所有文件。 -r 标志使命令列出单个文件，而不是仅将它们折叠到根目录名称中。 你还可以包括下面提到的内容，虽然它是可选的，但有助于给面试官留下深刻印象。 输出还将包含一些额外信息，可以通过包含两个标志把它们轻松的屏蔽掉： git diff-tree –no-commit-id –name-only -r {hash} 这里 -no-commit-id 将禁止提交哈希值出现在输出中，而 -name-only 只会打印文件名而不是它们的路径。 git config 的功能是什么？ 用来查看或修改你的git配置，包括用户名 提交对象包含什么？ 一组文件，表示给定时间点的项目状态 引用父提交对象 SHAI 名称，一个40个字符的字符串，提交对象的唯一标识。 如何在GIT中创建存储库？ 要创建存储库，先为项目创建一个目录（如果该目录不存在），然后运行命令 git init。通过运行此命令，将在项目的目录中创建 .git 目录。 怎样将N次提交压缩成一次提交? 如果要从头开始编写新的提交消息，请使用以下命令： 12git reset –soft HEAD~N &amp;&amp;git commit 如果你想在新的提交消息中串联现有的提交消息，那么需要提取这些消息并将它们传给 git commit，可以这样： 12git reset –soft HEAD~N &amp;&amp;git commit –edit -m&quot;$(git log –format=%B –reverse .HEAD@&#123;N&#125;)&quot; 什么是GIT bisect?如何使用它来确定（回归）错误的来源？ Git bisect 用于查找使用二进制搜索引入错误的提交。 1git bisect &lt;subcommand&gt; &lt;options&gt; 此命令用了二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。你可以通过告诉它已知包含该错误的“错误”提交以及在引入错误之前已知的“良好”提交来使用它。然后 git bisect 在这两个端点之间选择一个提交，并询问你所选的提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。 如果想要在提交之前运行代码性检查工具，并在测试失败时阻止提交，该怎么配置GIT存储库？ 这可以通过与存储库的 pre-commit hook 相关的简单脚本来完成。git 会在提交之前触发 pre-commit hook。你可以在这个脚本中运行其他工具，例如 linters，并对提交到存储库中的更改执行完整性检查。 描述一下你所使用的分支策略？ 功能分支（Feature branching） 要素分支模型将特定要素的所有更改保留在分支内。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。 任务分支（Task branching） 在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。 发布分支（Release branching） 一旦开发分支获得了足够的发布功能，你就可以克隆该分支来形成发布分支。创建该分支将会启动下一个发布周期，所以在此之后不能再添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该包含在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它还应该再将自发布以来已经取得的进展合并回开发分支。 如果分支是否已合并为master，你可以通过什么手段知道？ git branch –merged 它列出了已合并到当前分支的分支。 git branch –no-merged 它列出了尚未合并的分支。 什么是SubGit？ SubGit 是将 SVN 到 Git迁移的工具。它创建了一个可写的本地或远程 Subversion 存储库的 Git 镜像，并且只要你愿意，可以随意使用 Subversion 和 Git。 这样做有很多优点，比如你可以从 Subversion 快速一次性导入到 Git 或者在 Atlassian Bitbucket Server 中使用SubGit。我们可以用 SubGit 创建现有 Subversion 存储库的双向 Git-SVN 镜像。你可以在方便时 push 到 Git 或提交 Subversion。同步由 SubGit 完成。 https://segmentfault.com/a/1190000019315509]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>分布式版本控制系统</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2F2019%2F06%2F16%2FGit%2F</url>
    <content type="text"><![CDATA[Git .gitignore仓库log目录，不希望同步到仓库中去，写到.gitignore文件 /log/ 凡是写到这个文件中了，那么git add.的时候就不会被添加到仓库中去 .pyc 常用命令 git log：查看历史 git add：标记文件添加到仓库 git add . =&gt;标记当前目录及子目录文件（.gitignore文件指定的内容是不添加的） 不能同步空目录 git clone：克隆仓库 12git clone https://github.com/chenxl18/chenxl18.github.io.git#=&gt; 当前目录 12/d/hexo/myblog/source/_posts (master)# master =&gt;master 分支 web页面（服务器）修改-&gt;同步-&gt;本地 1.在web页面修改 2.在本地仓库中执行：git pull origin master 3.git pull [&lt;远程仓库名&gt; &lt;分支名&gt;] 本地修改-&gt;同步-&gt;web页面（服务器） 1.本地修改：vim，右击创建 2.标记待添加到仓库： 1git add liu.txt 配置邮箱、用户名(必须配置此项才能提交数据到仓库) 1(master)$ git config user.name &apos;yourname&apos; (master)$ git config user.email &apos;youremail@163.com&apos; 提交文件到本地仓库： 1git commit #一定要写备注信息，否则此次提交会被忽略 提交到远程仓库： 1git push origin master 注意：当进行push/commit之前，最好先pull一下 注意： 不要在仓库下进行克隆 当web页面有更新，本地也有更新的时候，注意可能会产生冲突 如果能自动合并的，它会自动合并，不能自动合并的，需要手动合并 Web页面上修改 本地修改、add、commit 提交到远程仓库 本地在push的时候，跟服务器版本有不一致的地方，所以有以上提示，需要先pull pull时，因为本地和远程都修改了同一个文件，无法自动合并，所以进入了merge模式 pull的时候，如果能自动合并的，它会自动合并，不能自动合并的，手动合并 MERGING模式 12345&lt;&lt;&lt;&lt;HEAD 你的修改 ====== 远程仓库的修改 &gt;&gt;&gt;&gt;&gt; 版本号 把自己需要的部分保留，不需要的删除。修改完成后再次add/commit即可退出merge模式 （&gt;&gt;&gt;&gt; ==== &lt;&lt;&lt;&lt;&lt;这些行一定删除） 再次git push到远程仓库 可查看git log日志 在仓库中把califeng文件删除，是否能找回 可以找回 注意： 不要仓库下进行克隆 gitee_python_study (master) master =&gt; master分支 遇到的问题 第一次 push时都需要输入密码 .git/conﬁg [remote “origin”] url = http://git.sanchuangedu.cn:3000/chenxl/python_study.git fetch = +refs/heads/:refs/remotes/origin/ .gitignore 本地-&gt; Web commit 修改文件: vim, touch, mkdir。。。。 标记为暂存状态: git add 提交到本地仓库：git commit 提交到远程仓库：git push 为开源的项目提交代码、只读的项目 写权限=&gt; 删除修改文件 =&gt; push 克隆项目：你自己帐户下的python_study 写代码：根目录下创建以自己名字命名的文件 配置：git config 同步到远程仓库 添加远程仓库 git remote add 名字 仓库地址 git remote add source http://git.sanchuangedu.cn:3000/cali/python_study.git 从远程仓库拉取最新的信息 git pull source master 测试：尝试向source push一点东西 403错误 bigbusiness =》 开发者权限 （读、写）读 fork -&gt; 可以 pull -&gt; 可以 clone -&gt; 可以 开发者 push -&gt; 可以 git clone 克隆 git add 标记 git commit 提交 git pull 拉文件 git push 推文件 git log 查看日志 git status 查看当前状态 git remote (add / remove / -v) 查看远程源 git rm 删除 git mv ﬁle newﬁle 更改文件名 git branch -a 查看所有分支 git checkout 切换分支 git reset git conﬁg 配置 git branch dev 创建新分支 基于当前分支来创建git branch init ca752793c1b6e957636b192777da3ba72da8e35c 基于某一个提交点创建分支 git checkout -b init02 创建init02并切换到分支 git branch -d init 删除分支 注：git的官方文档 https://git-scm.com/book/zh/v2/]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux中IP地址的配置]]></title>
    <url>%2F2019%2F06%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Flinux%E4%B8%ADIP%E5%9C%B0%E5%9D%80%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[进入ip地址配置目录1cd /etc/sysconfig/network-scripts 打开配置文件1vim ifcfg-ens33 修改配置文件12345678BOOTPROTO=noneNAME=ens33DEVICE=ens33ONBOOT=yesIPADDR=192.168.0.156NETMASK=255.255.255.0GATEWAY=192.168.0.1DNS1=114.114.114.114 重启网络服务1service network restart 测试配置ip地址1ping www.baidu.com 如下面的差不多就代表配置成功12345[root@chenxianle ~]# ping www.baidu.comPING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=55 time=29.6 ms64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=55 time=30.4 ms64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=55 time=30.2 ms]]></content>
      <categories>
        <category>linux</category>
        <category>IP地址配置</category>
      </categories>
      <tags>
        <tag>ip基本配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tmux的基本操作]]></title>
    <url>%2F2019%2F06%2F12%2Flinux%2Ftmux%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[如何在linux机器中使用tmux(分屏工具)tmux（介绍）tmux（terminal multiplexer）是Linux上的终端复用神器，可从一个屏幕上管理多个终端（准确说是伪终端）。使用该工具，用户可以连接或断开会话，而保持终端在后台运行。类似的工具还有screen，个人对这二者的使用感受是，用过tmux就再也不想用screen了 更新epel源1yum install epel-release -y 下载tmux工具1yum install tmux -y 开启tmux终端1tmux tmux基本操作打开一个新窗口1ctrl b + &quot; 光标上下切换1ctrl b + 上下方向键 退出tmux1ctrl b + d 删除光标所在一个tmux窗口1ctrl b + x 列出所有命令1tmux list-command Tmux的快捷键使用说明： Ctrl+b 激活控制台；此时以下按键生效 系统操作 ? 列出所有快捷键；按q返回 d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 D 选择要脱离的会话；在同时开启了多个会话时使用 Ctrl+z 挂起当前会话 r 强制重绘未脱离的会话 s 选择并切换会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 窗口操作 c 创建新窗口 &amp; 关闭当前窗口 数字键 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口；这样便于识别 . 修改当前窗口编号；相当于窗口重新排序 f 在所有窗口中查找指定文本 面板操作 ” 将当前面板平分为上下两块 % 将当前面板平分为左右两块 x 关闭当前面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 注：详细的请查看参考资料 参考资料https://www.cnblogs.com/kevingrace/p/6496899.html]]></content>
      <categories>
        <category>linux</category>
        <category>linux分屏工具</category>
      </categories>
      <tags>
        <tag>linux分屏工具</tag>
        <tag>tmux的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题31-45]]></title>
    <url>%2F2019%2F06%2F11%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%9831-45%2F</url>
    <content type="text"><![CDATA[31. filter、map、reduce的作用？filter：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）。 filter(function or None, sequence) -&gt; list, tuple, or string：入参为函数和列表/元组/字符串，返回值为item列表/元组/字符串。 map:对sequence中的item依次执行function(item)，将执行结果function(item)组成一个List返回。 map(function, sequence[, sequence, …]) -&gt; list：入参是为函数和列表/元组/字符串，返回值为function(item)列表。 reduce:对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用。function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。 reduce(function, sequence[, initial]) -&gt; value：入参是为函数和列表/元组/字符串和初始值，返回值为数值。32. 常用的 Python 标准库都有哪些?​ os、time、random、pymysql、threading、multiprocess、queue33. 至少列举8个常用模块都有那些?​ requests、re、md5、hashlib、django、sys、math、random、time 34. re的match和search区别？​ match:只匹配一个，从字符串开头进行匹配，如果字符串开始不符合正则表达式，则匹配失败，函数返回None search:只匹配一次，在字符串中进行匹配，直到找到一个匹配，否则也返回None35. 什么是正则的贪婪匹配？重复运算符在默认条件下是贪婪的，匹配尽可能多的字符36. 介绍一下 except 的作用和用法?Python的except用来捕获所有异常， 因为Python里面的每次错误都会抛出 一个异常，所以每个程序的错误都被当作一个运行时错误。37. 在 except 中 return 后还会不会执行 finally 中的代码?怎么抛出自定义异常?（1）不管有木有出现异常，finally块中代码都会执行； （2）当try和catch中有return时，finally仍然会执行； （3）finally是在return语句执行之后，返回之前执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前就已经确定了； （4）finally中如果包含return，那么程序将在这里返回，而不是try或catch中的return返回，返回值就不是try或catch中保存的返回值了38. Python 的魔法方法?​ __init__：通过此方法我们可以定义一个对象的初始操作 __new__：是用来创建类并返回这个类的实例 __del__ ：在对象生命周期调用结束时，__del__ 方法会被调用，39. init和new的区别? __init__: __init__方法通常用在初始化一个类实例的时候 __new__:__new__方法接受的参数虽然也是和 __init__一样，但 __init__是在类实例创建之后调用，而 __new__方法正是创建这个类实例的方法。 __init__和__new__最主要的区别在于：__init__通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。__new__通常用于控制生成一个新实例的过程。它是类级别的方法。 40. 说明一下 os.path 和 sys.path 分别代表什么?(1)os.path 主要是用于对系统路径文件的操作。 (2)sys.path 主要是对Python解释器的系统环境参数的操作（动态的改变Python解释器搜索路径）。41. Python 的 sys 模块常用方法?sys.argv#命令行参数List，第一个元素是程序本身路径 sys.path#返回模块的搜索路径，初始化时使用PYTHONPATH环境变里的值 sys.modules.keys（）#返回所有已经导入的模块列表 sys.modules#返回系统导入的模块字段，key是模块名，value是模块 sys.exc_info（）#获取当前正在处理的异常类，exc_type、exc_value、exc_traceback当前处理的异常详细信息 sys.exit（n）#退出程序，正常退出时exit（e) sys.hexversion#获取Python解释程序的版本值，16进制格式如：0x020403F0 sys.version#获取Python解释程序的版本信息 sys.platform#返回操作系统平台名称 sys.maxint#最大的Int值 sys.stdout#标准输出 sys.stdout.write（“aaa&apos;）#标准输出内容 sys.stdout.writelines（）#无换行输出 sys.stdin#标准输入 sys.stdin.read（）#输入一行 sys.stderr#错误输出 sys.exc_clear（）#用来清除当前线程所出现的当前的或最近的错误信息 sys.exec_prefix#返回平台独立的python文件安装的位置 sys.byteorder#本地字节规则的指示器，big-endian平台的值是‘big’，little-endian平台的值是little sys.copyright#记录python版权相关的东西 sys.api_version#解释器的c的API版本 sys.version_info#’final表示最终，也有‘candidate’表示候选，表示版本级别，是否有后继的发行 sys.getdefaultencoding（）#返回当前你所用的默认的字符编码格式 sys.getfilesystemencoding（）#返回将Unicode文件名转换成系统文件名的编码的名字 sys.builtin_module_names#Python解释器导入的内建模块列表 sys.executable#Python解释程序路径 sys.getwindowsversion（）#获取indows的版本 sys.stdin.readline（）#从标准输入读一行， sys.stdout.write（a）屏幕输出a sys.setdefaultencoding（name）#用来设置当前默认的字符编码（详细使用参考文档） sys.displayhook（value）#如果value非空，这个函数会把他输出到sys.stdout（详细使用参考文档）42. os和sys模块的作用？​ os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。43. 读取文件的几种方法的区别?（1）直接打开就读：虽然f是一个文件实例，但可以通过以上方式对每一行进行循环处理了，处理时每一行是一个字符串str,而且这个是速度最快最简洁的方法 （2）用read（）打开：这个函数把文件全部内容一次性读到一个字符串中。就是一坨的那种，如果把ff用循环读取的方式输出，会是一个一个字符，因为ff是字符串，本质上是tuple （3）用readlines():这个函数将文件所用内容以行为区分读到一个列表中 ，列表中的每一个元素是一行；lines是list，line 是str （4）用readline():这种方式是一行一行的读，非常的省内存，当文件巨大的情况下是有好处的44. 谈谈你对面向对象的理解？​ 面向对象编程是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象45. Python面向对象中的继承有什么特点？继承更多了是为了多态，也可提升代码的复用程度。 特点： 在继承中基类的构造（init()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用； Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；]]></content>
      <categories>
        <category>python面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
        <tag>31-45</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题16-30]]></title>
    <url>%2F2019%2F06%2F11%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%9816-30%2F</url>
    <content type="text"><![CDATA[16. Python3和Python2中 int 和 long的区别？​ Python 2有为非浮点数准备的int和long类型。int类型的最大值不能超过sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个L来定义长整型，显然，它比int类型表示的数字范围更大。 Python 3里，只有一种整数类型int，大多数情况下，它很像Python 2里的长整型。由于已经不存在两种类型的整数，所以就没有必要使用特殊的语法去区别他们。17. 4G 内存怎么读取一个 5G 的数据?​ (1)可以通过生成器，分多次读取，每次读取数量相对少的数据（比如 500MB）进行处理，处理结束后在读取后面的 500MB 的数据 (2)可以通过 linux 命令 split 切割成小文件，然后再对数据进行处理，此方法效率比较高。可以按照行数切割，可以按照文件大小切割。18. read、readline 和 readlines 的区别?​ read() ： 一次性读取整个文件内容。推荐使用read(size)方法，size越大运行时间越长 readline() ：每次读取一行内容。内存不够时使用，一般不太用 readlines() ：一次性读取整个文件内容，并按行返回到list，方便我们遍历19. 文件操作时：xreadlines和readlines的区别？在Python 2里，文件对象有一个xreadlines()方法，它返回一个迭代器，一次读取文件的一行。这在for循环中尤其有用。 在Python 3里，xreadlines()方法不再可用了，可改为for line in a_file。20. 列举布尔值为False的常见值？0，空字符串，空元组，空列表，空字典21. 字符串、列表、元组、字典每个常用的5个方法？​ 字符串： find() replace() split() join() strip() 列表： append() remove() pop() reverse() sort() 元组： sort() tuple + index() count() 字典： items() keys() values() del() pop()22. lambda表达式格式及应用场景? 用lambda函数的好处?格式：lambda x: x+1 场景：配合map、reduce等高阶函数使用，或作为列表元素排序的key23. pass的作用？continue的作用? break的作用?pass的作用：空语句，什么也不做，占坑；保证结构的完整性，可以以后实现 continue的作用：跳出本次循环 break的作用：结束循环24. arg 和*kwarg作用？实现了不定长传参 其中args为可变长参数，允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple； *kw为关键字参数，允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。25. is和==的区别is对比内存地址是否一致； == 对比值是否相等26. 简述Python的深浅拷贝以及应用场景？浅拷贝指仅仅拷贝数据集合的第一层数据 深拷贝指拷贝数据集合的所有层 对于只有一层的数据集合来说深浅拷贝的意义是一样的，比如字符串，数字，还有仅仅一层的字典、列表、元祖等。 对于 数字和字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。场景: 数据完整备份（隔离）27. 拷贝的注意点?(1)拷贝的对象是可变类型还是不可变类型 (2)拷贝后是否允许两个变量同时操控同一内存空间28. Python垃圾回收机制？Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。29. Python的可变类型和不可变类型？​ 不可变类型:数值类型（int和float）、字符串str、元组tuple 可变类型:列表list、字典dict、集合set30. 列举常见的内置函数？sum：对元素类型是数值的可迭代对象中的每个元素求和 int：根据传入的参数创建一个新的整数 range：根据传入的参数创建一个新的range对象 sorted：对可迭代对象进行排序，返回一个新的列表 help：返回对象的帮助信息 dir：返回对象或者当前作用域内的属性列表 type：返回对象的类型，或者根据传入的参数创建一个新的类型 len：返回对象的长度 format：格式化显示值]]></content>
      <categories>
        <category>python面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
        <tag>16-30</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题1-15]]></title>
    <url>%2F2019%2F06%2F11%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%981-15%2F</url>
    <content type="text"><![CDATA[Python和Java、PHP、C、C#、C++等其他语言的对比？​ （1）Java:优点----简单性、面向对象性、健壮性、跨品台性、高性能（自动垃圾回收机制）、多线程、动态性、安全性。 缺点----运行速度相对于C/C++有些缓慢了，这是机制原因导致的。 适用于----网页、企业级开发、普通应用软件、游戏后台。 （2）PHP:优点----跨平台，性能优越；语法简单，入门快；目前主流技术都支持；有比较完整的支持；有很多成熟的框架；PHP 5已经有成熟的面向对象体系，能够适应基本的面向对象要求；有成熟的社区来支持PHP的开发；目前已经很多大型应用都是使用PHP；有很多开源的框架或开源的系统可以使用；配置及部署相对简单一些。 缺点----多线程支持不太好，大多数时候我们只能简单的模拟去实现的；对语法不太严谨；PHP的解释运行机制繁琐。 适用于----主要是网络前端，用于生成网页。也可以整个web服务器都用php，比如很多论坛引擎。 （3）C:优点----简洁紧凑、灵活方便;运算符丰富;数据结构丰富;C是结构式语言;C语法限制不太严格，程序设计自由度大;C语言允许直接访问物理地址，可以直接对硬件进行操作;C语言程序生成代码质量高，程序执行效率高;C语言适用范围大，可移植性好;C语言有一个突出的优点就是适合于多种操作系统;有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护. 缺点----运算符和运算优先级过多，不便于记忆，语法定义不严格，编程自由度大，对新手不友好。 适用于----系统底层, 驱动, 嵌入式开发。 （4）C#:优点----相比java，有更先进的语法体系、强大的周边。 缺点----没有考虑代码量 （5）C++:优点----可扩展性、高效简洁快速、可移植性、面向对象的特性、强大而灵活的表达能力和不输于C的效率、支持硬件开发、程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障、通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便 适用于----游戏开发, 大规模, 高性能, 分布式要求的程序开发。 （6）Python:优点----简单、易学、免费开源、高层语言、可移植性、解释性、面向对象、可扩展性、可嵌入性、丰富的库、 缺点----运行速度慢，架构选择台繁琐 适用于----信息安全，大数据处理，数据可视化机器学习，物联网开发，各大软件的api，桌面应用，都需要python简述解释型和编译型编程语言？​ (1)编译型语言: 把源程序的每一条语句都编译成机器语言，并保存为二进制文件，运行时计算机就可以直接以机器语言来运行此程序 (2)解释型语言: 只是在程序执行时，才会一条一条的解释成机器语言给计算机执行​ 代码中要修改不可变数据会出现什么问题? 抛出什么异常？​ 代码会报错，抛出TypeError异常 可变数据类型：列表list和字典dict，集合set 不可变数据类型：基本数据类型（int, float, string）元组tupleprint 调用 Python 中底层的什么方法?​ print方法调用sys.stdout.write方法。就是往控制台打印字符串。简述你对 input()函数的理解?​ 在Python3中，input（）获取用户输入，不论用户输入什么，获取到的都是字符串类型。 在Python2中有raw_input() input(),raw_input()在Python3中的input()作用一样，input()输入什么数据类型，获取到的就是什么数据类型。Python解释器种类以及特点？​ Cpython:默认Cpython解释器，c语言实现 Ipython:基于Cpython之上的一个交互式解释器 Jpython:java实现，python代码会先转化成Java字节码 IronPython:C#实现 PyPy:python实现的python解释器pypy运行效率高Python2 中 range 和 xrange 的区别?​ 两者用法大致相同，不同的是range返回的结果是一个列表，而xrange的结果是一个生成器，前者是直接开辟一块内存空间来保持列表，后者是边循环边使用，只有在使用的时候才会开辟内存空间，所以当列表很长时，使用xrange性能比range好。位和字节的关系？​ 1 字节 = 8 位 1 Byte = 8 bit 1 B = 8 bb、B、KB、MB、GB 的关系？​ 1 GB = 1024 MB 1 MB = 1024 KB 1 KB = 1024 B 1 B = 8 bit请至少列举5个 PEP8 规范（越多越好）。​ （注：在python3中） 1.缩进: 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。 2.变量: 常量--大写加下划线 私有变量--小写和一个前导下划线--_value 内置变量--小写,两个前导下划线和两个后置下划线--__init__ 3.空行：顶级定义之间空2行, 方法定义之间空1行，顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行. 4.空格：按照标准的排版规范来使用标点两边的空格，括号内不要有空格，按照标准的排版规范来使用标点两边的空格 5.导入格式：每个导入应该独占一行，导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组: 标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.python递归的最大层数？递归函数停止的条件?​ python递归的最大层数为：3221（根据查的百度：得到的最大数字在3925-3929之间浮动，这个是和计算机有关系的，不然也不会是一个浮动的数字了） 停止的条件： （1）判断递归的次数是否达到某一个限定值 （2）判断运算的结果是否达到某个范围等，根据设计的目的来选择ascii、unicode、utf-8、gbk 区别？​ 常见字符集：ASCII字符集、GB2312、Uniclde字符集 常见字符编码：UTF ASCII码:在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit），有0和1两种状态，因此，8个二进制位可以组合出256种状态，这被称为字节（byte)。 GBK码:GBK编码是对GB2312的扩展，完全兼容GB2312。采用双字节编码方案，剔出xx7F码位，共23940个码位，共收录汉字和图形符号21886个。 Unicode码：有一种编码，将世界上所有的符号都纳入其中，每一种符号都给予独一无二的编码，那么乱码问题就不会存在了。因此，产生了Unicode编码，这是一种所有符号的编码。 UTF8字符编码：UTF8就是在互联网中使用最多的对Unicode的实现方式。字节码和机三元运算规则以及应用场景？器码的区别？​ 机器码是电脑CPU直接读取运行的机器指令，是电脑的CPU可直接解读的数据，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到； 字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。三元运算规则以及应用场景？i = A if condition else B，主要运用与结构简单的条件语句，这样可以节省代码列举 Python2和Python3的区别？​ *核心类区别：* 1.Python3对Unicode字符的原生支持。 Python2中使用ASCII码作为默认编码方式导致string有两种类型str和Unicode，Python3中只支Unicode类型的string。 2.Python3中采用的是绝对路径的方式进行import。 Python2中相对路径的import会导致标准库导入变得困难（同一目录下有file.py，如何同时导入这个文件和标准库文件file）。Python3中这一点被修改了，如果还需要导入同一目录的文件必须使用绝对路径，否则只能使用相关导入的方式来进行导入。 3.Python2中存在老式类和新式类，Python3中统一采用新式类。 新式类申明要求继承object，必须使用新式类应用多重继承。 4.Python3使用更加严格的缩进。 Python2的缩进机制中，一个tab和8个space是等价的，所以在缩进中同时允许tab和space在代码中共存。这种等价机制会导致部分IDE使用存在问题。Python3中1个tab只能找另一个tab代替，因此tab和space共存会导致报错：TabError：inconsistent use of tabs and spaces in indentaion. *废弃类差别：* 1. print 语句被 Python3 废弃，统一使用 print 函数 2. exec 语句被 python3 废弃，统一使用 exec 函数 3. execfile 语句被 Python3 废弃，推荐使用 exec(open(&quot;./filename&quot;).read()) 4. 不相等操作符&quot;&lt;&gt;&quot;被 Python3 废弃，统一使用&quot;!=&quot; 5. long 整数类型被 Python3 废弃，统一使用 int 6. xrange 函数被 Python3 废弃，统一使用 range,Python3 中 range 的机制也进行修改并提高了大数据集生成效率 7. Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换： mydict={&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3} mydict.keys() #&lt;built-in method keys of dict object at 0x000000000040B4C8&gt; list(mydict.keys()) #[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;] 8. 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) 9. raw_input 函数被 Python3 废弃，统一使用 input 函数 10. 字典变量的 has_key 函数被 Python 废弃，统一使用 in 关键词 11. file 函数被 Python3 废弃，统一使用 open 来处理文件，可以通过 io.IOBase 检查文件类型 12. apply 函数被 Python3 废弃 13. 异常 StandardError 被 Python3 废弃，统一使用 Exception *修改类差异：* 1. 浮点数除法操作符“/”和“//”的区别： &quot;/&quot;： Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。 python3为真除法，运算结果为float类型。 “//”： Python2 中返回小于除法运算结果的最大整数，从类型上讲，与&quot;/&quot;运算符返回类型逻辑一致。 Python3中与python2作用相同。 2. 异常抛出和捕捉机制的区别。 Python2 1. raise IOError, &quot;file error&quot; #抛出异常 2. except NameError, err: #捕捉异常 Python3 1. raise IOError(&quot;file error&quot;) #抛出异常 2. except NameError as err: #捕捉异常 3. for循环中变量值区别。 Python2 中，for循环会修改外部相同名称变量的值。 i=1 print(&apos;comprehension: &apos;, [i for i in range(5)]) print(&apos;after: i=.&apos;,i) #i=4 Python3中，for循环不会修改外部相同名称变量的值。 i=1 print(&apos;comprehension: &apos;, [i for i in range(5)]) print(&apos;after: i=.&apos;,i) #i=1 4. round函数返回值区别 Python2中，round函数返回float类型值。 isinstance(round(15.5),float) #True Python3中，round函数返回int类型值。 isinstance(round(15.5),int) #True 5. 比较操作符的区别。 Python2中任意两个对象都可以比较。 Python3中只有同一类型数据的对象才可以进行比较。]]></content>
      <categories>
        <category>python面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>python</tag>
        <tag>1-15</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http协议]]></title>
    <url>%2F2019%2F06%2F11%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[http协议问题1.在浏览器里输入https://www.baidu.com 一个回车后，浏览器里会显示百度的首页，请详细说下背后发送什么事情，越细致越好？ DNS域名解析：浏览器缓存、系统缓存、路由器、ISP的DNS服务器、根域名服务器。把域名转化成IP地址。 与IP地址对应的服务器建立TCP连接，经历三次握手：SYN，ACK、SYN，ACK 以get，post方式发送HTTP请求，get方式发送主机，用户代理，connection属性，cookie等 获得服务器的响应，显示页面 2.如果打开https://www.baidu.com网站，会有哪些问题，你如果排除？3.https协议的实现原理–》加密的原理http协议：超文本传输协议​ 特点：明文 ​ Hyper Text Transfer ​ Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 ​ site–&gt;站点–&gt;网站 website–&gt;网站 ​ URL：例如： http://hn.qq.com/a/20190118/002018.html ​ URL即统一资源定位符(Uniform Resource Locator)，用来唯一地标识万维网中的某一个文档。URL由协议、主机和端口(默认为80)以及文件名三部分构成。 https协议：加密的超文本传输协议​ 特点：密文 html语言​ 最常见的超文本格式是超文本标记语言 操作系统 ​ web服务 ​ linux 数据结构 数据库原理 搭建一个属于自己的网站1.准备一个linux系统，确保可以上网​ ifup ens33 激活网卡 ​ ip add 查看ip地址 ​ ping www.baidu.com 测试你的linux机器是否可以和baidu通信 2.安装httpd 和 epel-release软件​ httpd 提供web服务器的软件 ​ 命令： yum install httpd epel-release -y ​ epel-release —&gt;这是一个软件源头的软件—》提供很多的软件可以下载 ​ 安装nginx web服务器软件 ​ 命令： yum install nginx -y ​ nginx是一个俄罗斯人开发的web服务器软件 ​ 补充 ​ mirror：镜像 另外一个地方和原来的服务器里的内容，一模一样。 3.启动nginx软件​ 命令： service nginx start ​ 开启nginx服务 ​ Redirecting to /bin/systemctl start nginx.service ​ 表示成功启动 ​ 命令： service nginx stop ​ 停止nginx服务 ​ Redirecting to /bin/systemctl stop nginx.service ​ 表示成功关闭 补充​ yum install lsof -y ​ lsof 软件是用来查看服务器里那个端口被那个程序使用了 ​ 安装lsof命令 ​ lsof -i:80 ​ 查看80端口被那个程序使用了 ​ ​ 端口号和程序之间的关系？ ​ 只有对外提供服务的程序会占用端口。 ​ 端口号—》窗口 ​ 1-1024 系统内置的端口–》很经典的使用端口 ​ 基本上都会被占了 ​ 1-65535 一共有这么多可以用的端口号 ​ 架构 ​ b/s架构 —》browser server –&gt;方便—》流行 ​ c/s架构 —-》client server —》socket 编程 ​ 2**32 ​ 端口号的多少/报文大小 ​ 启动和关闭httpd服务器 ​ service httpd start 开启httpd服务 ​ service httpd stop关闭httpd服务 ​ 显示效果 ​ 4.关闭防火墙​ iptables -F 5.查看ip地址​ ip add ​ 效果 ​ 6.在windows系统里打开浏览器7.修改网站的首页​ cd /usr/share/nginx/html/ ​ 存放网页的目录 ​ ls ​ 查看当前目录的文件及文件夹 ​ 访问window机器下的index.html ​ index.html 首页：网站访问的第一个页面 –》入口 ​ vim index.html ​ 编辑index.html页面 ​ web服务器软件 nginx httpd ​ apache是httpd软件的名字 tomcat 修改nginx web服务的80端口—-改为8080端口 cd /etc/nginx/ ​ 进入文件修改配置文件 vim nginx.conf ​ 编辑配置文件 service nginx restart ​ Redirecting to /bin/systemctl restart nginx.service ​ 表示成功 修改配置文件后一定要重启一下服务 URL 域名： domain name ​ www.baidu.com –》ip ​ 域名：baidu.com ​ 主机名：www ​ www只是baidu.com这个域里的一个主机的名字 http协议1.请求报文 —》request​ GET 方法：去索取内容 ​ POST 方法： 提交 ​ user-agent：用户代理–》浏览器 ​ 浏览器代人去访问了服务器 ​ 重点掌握 ​ host:访问的网址 ​ accept： 接受的内容 ​ accept-language：语言 ​ user-agent： 客户机的浏览器和系统的信息 ​ accept-encoding： 编码 ​ connection: 是否是长连接 2.响应报文 –》response​ Connection: keep-alive ​ Date: Fri, 18 Jan 2019 08:31:31 GMT ​ Server: nginx/1.12.2 ​ 版本 ​ 最新2.0版本 http协议的版本： ​ 1.http协议的版本 ​ HTTP/1.1版本 ​ 2.http2 长连接​ keepalive_timeout 65; ​ 持久性连接 ​ 在一个连接中，可以进行多次文档的请求和响应。 服务器在发送完响应后，并不立即释放连接，浏览 器可以使用该连接继续请求其他文档。连接保持的 时间可以由双方进行协商。 ​ Connection: keep-alive 短连接​ 非持久性连接 ​ 无状态性 端口号 ​ 80 https协议 端口号 ​ 443 状态码 404 ​ 网页不存在 304 ​ Not Modified —》按CTRL+F5 强制刷新网页内容，不从缓存里读取网页内容 301 ​ 网页位置发生变化 200 ​ 访问成功 403 ​ 服务器里的网页设置了权限不让用户访问 Forbidden 5** ​ 服务器的内部问题 ​ HTTP 500 ​ 服务器遇到错误，无法完成请求 ​ HTTP 502 ​ 网关错误 ​ Error 501 ​ 未实现 cookie和session cookie ​ 有时也用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密） ​ https://baijiahao.baidu.com/s?id=1612804856429135825&amp;wfr=spider&amp;for=pc session ​ session会话机制是一种服务器端机制，它来保存客户端的信息。 ​ 一次连接就会产生一个session 代理 http 代理 ​ proxy server 代理服务器：中间的一个服务器，代理大家去上网 http://http.taiyangruanjian.com/newrecharge/ user-agent：用户代理–》浏览器 ​ 浏览器代人去访问了服务器 http2.0和http1.1的差异cdn CDN的全称是Content Delivery Network，即内容分发网络 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 精准调度 秒级加速 降低访问]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog添加搜索功能]]></title>
    <url>%2F2019%2F05%2F30%2Fblog%E6%B7%BB%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[添加搜索功能插件安装直接在自己的博客文件夹下（我的是blog）点击鼠标右键选择Git Bash Here 1npm install hexo-generator-searchdb --save 修改站点配置文件 路径：blog/_config.yml，找到Extensions，在下面插入如下代码 12345search: path: search.xml field: post format: html limit: 10000 注：每个冒号后面都有一个空格 修改主题配置文件 路径：blog/themes/next/_config.yml，找到local_search，把false改为ture https://wx4.sinaimg.cn/mw690/006BsDmEgy1g3mr7gtxylj30bp00z3ya.jpg 12local_search: enable: false 改为： https://wx2.sinaimg.cn/mw690/006BsDmEgy1g3mr7gtzrmj308w0133ya.jpg 12local_search: enable: true]]></content>
      <categories>
        <category>Hexo+Next GitPages个人博客</category>
      </categories>
      <tags>
        <tag>搜索功能</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的使用]]></title>
    <url>%2F2019%2F05%2F28%2Fmysql%2FMySQL%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MySQL的使用技巧如果不知道pstree命令可以使用 yum provides pstree 12[root@mysql-2 ~]# yum provides pstree[root@mysql-2 ~]# yum install psmisc -y https://wx4.sinaimg.cn/mw690/006BsDmEgy1g3mr7gz0pij30jf09a3yq.jpg pstree命令：用来查看进程树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@mysql-2 ~]# pstree -p # 查看进程树结构，并且显示pid号systemd(1)─┬─NetworkManager(5474)─┬─&#123;NetworkManager&#125;(5518) │ └─&#123;NetworkManager&#125;(5521) ├─VGAuthService(5444) ├─auditd(5422)───&#123;auditd&#125;(5423) ├─chronyd(5457) ├─crond(5478) ├─dbus-daemon(5455) ├─irqbalance(5449) ├─login(5481)───bash(8235) ├─lvmetad(2799) ├─master(6082)─┬─pickup(15979) │ └─qmgr(6099) ├─mysqld_safe(5943)───mysqld(6034)─┬─&#123;mysqld&#125;(6848) │ ├─&#123;mysqld&#125;(6962) │ ├─&#123;mysqld&#125;(6963) │ ├─&#123;mysqld&#125;(6964) │ ├─&#123;mysqld&#125;(6965) │ ├─&#123;mysqld&#125;(6966) │ ├─&#123;mysqld&#125;(6967) │ ├─&#123;mysqld&#125;(6968) │ ├─&#123;mysqld&#125;(6969) │ ├─&#123;mysqld&#125;(6970) │ ├─&#123;mysqld&#125;(6971) │ ├─&#123;mysqld&#125;(6973) │ ├─&#123;mysqld&#125;(7453) │ ├─&#123;mysqld&#125;(7454) │ ├─&#123;mysqld&#125;(7455) │ ├─&#123;mysqld&#125;(7456) │ ├─&#123;mysqld&#125;(7457) │ ├─&#123;mysqld&#125;(7464) │ ├─&#123;mysqld&#125;(7465) │ ├─&#123;mysqld&#125;(7466) │ ├─&#123;mysqld&#125;(7467) │ ├─&#123;mysqld&#125;(7468) │ ├─&#123;mysqld&#125;(7469) │ ├─&#123;mysqld&#125;(7470) │ ├─&#123;mysqld&#125;(7690) │ ├─&#123;mysqld&#125;(7691) │ ├─&#123;mysqld&#125;(15744) │ ├─&#123;mysqld&#125;(15790) │ ├─&#123;mysqld&#125;(16005) │ ├─&#123;mysqld&#125;(16006) │ └─&#123;mysqld&#125;(16007) ├─polkitd(5447)─┬─&#123;polkitd&#125;(5458) │ ├─&#123;polkitd&#125;(5473) │ ├─&#123;polkitd&#125;(5503) │ ├─&#123;polkitd&#125;(5504) │ ├─&#123;polkitd&#125;(5505) │ └─&#123;polkitd&#125;(5506) ├─rsyslogd(5784)─┬─&#123;rsyslogd&#125;(5892) │ └─&#123;rsyslogd&#125;(5901) ├─sshd(5777)─┬─sshd(15703)───bash(15705)───mysql(15789) │ ├─sshd(15750)───bash(15752) │ └─sshd(15977)───bash(15980)───pstree(16054) ├─systemd-journal(2780) ├─systemd-logind(5475) ├─systemd-udevd(2807) ├─tuned(5779)─┬─&#123;tuned&#125;(7331) │ ├─&#123;tuned&#125;(7332) │ ├─&#123;tuned&#125;(7376) │ └─&#123;tuned&#125;(7593) └─vmtoolsd(5454)───&#123;vmtoolsd&#125;(5511) 查看MySQL的进程 12345[root@mysql-2 ~]# ps aux|grep mysqlroot 7321 0.0 0.0 11816 1620 ? S 3月10 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 7417 0.0 9.9 1571636 185360 ? Sl 3月10 0:16 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pidroot 19744 0.0 0.0 112728 988 pts/2 S+ 10:10 0:00 grep --color=auto mysql[root@mysql-2 ~]# mysqld_safe和mysqld进程，他们之间的关系是什么？答：mysqld_safe是mysqld进程的父进程mysql数据库是一个进程里启动很多线程的程序。只要有人远程连接到mysqld进程，就会产生一个线程去接待。完成相关的数据库的操作。 进程里包含很多线程进程占用的资源多（内存、cpu等），线程占用的资源少，但是作用都差不多，都可以用来处理操作。1个进程里可以启用很多额线程。 当mysqld进程没有启动的时候，是不能连接到mysql数据库里的 1234[root@mysql-2 support-files]# mysql -uroot -p&apos;Sanchuang123#&apos;mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2)[root@mysql-2 support-files]# 连接mysql的2种方式：1.通过文件socket：同一台电脑里的不同的进程之间，可以使用文件socket来通信。 1234[root@mysql-2 support-files]# mysql -uroot -p&apos;Sanchuang123#&apos;mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2) --》说明文件socket 不存在[root@mysql-2 support-files]# -S 指定mysql的socket文件在路径 123456789101112131415[root@mysql-2 tmp]# mysql -S /tmp/mysql.sock -uroot -p&apos;Sanchuang123#&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 修改mysql的socket文件的路径my.cnf 的作用是当mysqld进程启动的时候，会读取my.cnf文件里的配置，然后加载运行，启动相应的功能。关于定制mysql的配置，有2个地方：1.在cmake编译的时候，指定配置 1234567[root@changsha-tianlong-db-2 mysql-5.7.25]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \ #mysql安装目录-DMYSQL_DATADIR=/data/mysql \ #数据库文件目录-DSYSCONFDIR=/etc \ #配置文件目录-DMYSQL_USER=mysql \ #运行mysql进行的用户，如果没有需要提前添加用户和用户组-DDEFAULT_CHARSET=utf8 \ #默认字符集-DDEFAULT_COLLATION=utf8_general_ci \ #默认校对规则-DWITH_BOOST=boost #boost库，带boost的源码包只需要这样即可，不带boost源码包需要指明boost目录 2.在配置文件my.cnf里指定 123456789101112[root@mysql-2 tmp]# vim /etc/my.cnf[mysqld_safe]log-error=/var/log/mysql/mysql.log#这是指定mysql的日志文件的路径#指定mysqld_safe进程的配置#需要在mkdir /var/log/mysql 目录，然后使用命令chown mysql:mysql /var/log/mysql#因为mysql进程需要往/var/log/mysql目录里写东西，需要权限，不然不能往目录下写日志[mysqld]socket=/data/mysql/mysql.sock#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置 授权给mysql用户 1234[root@mysql-2 log]# cd /var/log[root@mysql-2 log]# mkdir mysql[root@mysql-2 log]# chown mysql:mysql mysql[root@mysql-2 log]# 重新启动mysqld服务 123456789[root@mysql-2 tmp]# service mysqld restart 重新启动mysqld服务Shutting down MySQL. SUCCESS! Starting MySQL. SUCCESS! [root@mysql-2 tmp]# ps aux|grep mysqlroot 22682 0.6 0.0 11812 1616 pts/1 S 10:57 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 22795 6.0 9.4 1571372 176028 pts/1 Sl 10:57 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pid --socket=/data/mysql/mysql.sockroot 22831 0.0 0.0 112724 984 pts/1 S+ 10:57 0:00 grep --color=auto mysql[root@mysql-2 tmp]# 注释：–basedir=/usr/local/mysql #指定的mysql的安装路径–datadir=/data/mysql #数据存放的目录–plugin-dir=/usr/local/mysql/lib/plugin #插件的目录–user=mysql #使用mysql这个用户启动的–log-error=/var/log/mysql/mysql.log # 日志文件的路径–pid-file=/data/mysql/mysql-2.pid #mysql的进程的pid存放的文件，此文件是方便关闭mysql的时候，去kill 进程–socket=/data/mysql/mysql.sock #指定的socket文件的路径修改了socket文件的路径后，使用mysql命令连接到mysql数据库里，需要指定socket文件的路径 123456789[root@mysql-2 tmp]# ps aux|grep mysqlroot 22682 0.6 0.0 11812 1616 pts/1 S 10:57 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 22795 6.0 9.4 1571372 176028 pts/1 Sl 10:57 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pid --socket=/data/mysql/mysql.sockroot 22831 0.0 0.0 112724 984 pts/1 S+ 10:57 0:00 grep --color=auto mysql[root@mysql-2 tmp]# cat /data/mysql/mysql-2.pid 22795[root@mysql-2 tmp]# mysql -uroot -p&apos;Sanchuang123#&apos;mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2) ‘/tmp/mysql.sock’ (2) –》默认会到/tmp目录下查找使用-S 选项指定 1[root@mysql-2 tmp]# mysql -S /data/mysql/mysql.sock -uroot -p&apos;Sanchuang123#&apos; #指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。2.通过网络socketip:port 192.168.0.133:3306 –&gt;网络socket可以实现不同的计算机之间的进程之间的通信。 可以通过-h 192.168.0.133 指定访问的数据库服务器的ip地址，使用网络socket的方式访问-h host 123456789101112131415[root@mysql-2 mysql]# mysql -h 192.168.0.133 -uroot -p&apos;Sanchuang123#&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 12Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 什么是socket？网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。 socket 可以实现不同的进程之间的通信，是不同进程之间通信的一种方式。 12345678910111213141516[root@mysql-2 support-files]# yum install net-tools -y 安装net-tools工具得到netstat命令[root@mysql-2 support-files]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 12290/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6561/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 6861/master tcp 0 0 192.168.0.133:22 192.168.0.188:51832 ESTABLISHED 19720/sshd: root@pt tcp 0 0 192.168.0.133:22 192.168.0.188:51853 ESTABLISHED 19806/sshd: root@pt tcp 0 52 192.168.0.133:22 192.168.0.188:50459 ESTABLISHED 18112/sshd: root@pt tcp6 0 0 :::80 :::* LISTEN 12290/nginx: master tcp6 0 0 :::22 :::* LISTEN 6561/sshd tcp6 0 0 ::1:25 :::* LISTEN 6861/master udp 0 0 127.0.0.1:323 0.0.0.0:* 6270/chronyd udp6 0 0 ::1:323 :::* 6270/chronyd [root@mysql-2 support-files]# 注释：0.0.0.0:80 —–&gt;0.0.0.0表达这台本机上所有的IP地址 网络socket的使用 使用SQLyog远程连接到MySQL 1.授权一个用户能远程登录 1234mysql&gt; grant ALL on *.* to &apos;cali&apos;@&apos;%&apos; identified by &apos;Sanchuang123#&apos;;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; 授权cali这个用户可以从任何机器上远程连接过来，使用密码Sanchuang123# 可以对mysql数据库的所有的数据库进行操作。 使用SQLyog远程连接 MySQL里破解密码 第1步：停止MySQL进程的运行 123[root@mysql-2 mysql]# service mysqld stopShutting down MySQL.. SUCCESS! [root@mysql-2 mysql]# 第2步：修改配置文件 1234[root@mysql mysql]# vim /etc/my.cnfuser=mysql #指定启动MySQL进程的用户skip-grant-tables #跳过密码验证#validate-password=off #需要禁用密码复杂性策略 第3步：启动MySQL进程 12[root@mysql mysql]# service mysqld start 启动MySQL进程Starting MySQL. SUCCESS! 第4步：登录MySQL，不接密码 1234567891011121314151617181920212223242526[root@mysql-2 mysql]# mysql -S /data/mysql/mysql.sock -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; set password=&apos;123456&apos;; ----》会报错ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statementmysql&gt; flush privileges; ----》刷新权限（会加载原来没有加载的权限表）Query OK, 0 rows affected (0.01 sec)mysql&gt; set password=&apos;Sanchuang1234#&apos;; ----》会报错ERROR 1133 (42000): Can&apos;t find any matching row in the user tablemysql&gt; set password for &apos;root&apos;@&apos;localhost&apos; = &apos;Sanchuang1234#&apos;; ----》修改密码Query OK, 0 rows affected (0.00 sec)mysql&gt; quitBye 第5步：重新修改mysql的配置文件 1234[mysqld]socket=/data/mysql/mysql.sock#user=mysql --》注释掉#skip-grant-tables --》注释掉 *第6步：刷新服务 * 1234[root@mysql-2 mysql]# service mysqld restart #重新刷新服务Shutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS! [root@mysql-2 mysql]# 第7步：验证修改密码是否成功 1[root@mysql-2 mysql]# mysql -S /data/mysql/mysql.sock -uroot -p&apos;Sanchuang1234#&apos; my.cnf配置文件部分配置使用介绍 12345678910111213[mysqld]port = 3309 #修改端口号max_connections = 330 #最大并发连接数 ，增大该值需要相应增加允许打开的文件描述符数 max_connect_errors = 100 #如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，open_files_limit = 8192 #设置打开文件的句柄数量，在系统里面可以用ulimit –a 查看，可以使用ulimit -n 65535修改，同时添加到/etc/rc.local里innodb_buffer_pool_size = 1G #指定innodb存储引擎的缓冲池的大小。--》从内存当前拿出多少空间来做缓存使用[mysql] ----&gt;专门针对mysql这个命令的配置auto-rehash #可以在命令可以使用tab键补齐prompt=\\u@\\d \\R:\\m mysql&gt; #在Mysql命令显示用户名和数据库名字、时间[mysqld_safe]log-error=/var/log/mysql/mysql.log 基本的MySQL的操作查看MySQL数据库系统里有哪些库 123456789101112[root@mysql-2 mysql]# mysql -uroot -p&apos;Sanchuang1234#&apos; -S /data/mysql/mysql.sockmysql&gt; show databases; #查看MySQL数据库系统里有哪些库+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 创建lizengzhi数据库 1234567891011121314mysql&gt; create database lizengzhi ; #创建lizengzhi数据库Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || lizengzhi || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) 切换当前使用的数据库到lizengzhi 123456789mysql&gt; use lizengzhi; #切换当前使用的数据库到lizengzhiDatabase changedmysql&gt; select database(); #查询当前在哪个数据库里+------------+| database() |+------------+| lizengzhi |+------------+1 row in set (0.00 sec) linux内核对一个进程可以打开多少个文件进行了限制，默认情况下一个进程只能打开1024个文件 文件描述符：进程对打开的文件进行编号，这个编号就是文件描述符。 12345[root@mysql-2 mysql]# ulimit -aopen files (-n) 1024 #打开的文件数量[root@mysql-2 mysql]# ulimit -n 655350 #临时修改一个进程可以打开的文件数量[root@mysql-2 mysql]# ulimit -n 1000000[root@mysql-2 mysql]# 查看mysql里默认的最大并发数是多少 1234567root@(none) 15:37 mysql&gt;show variables like &apos;max_connections&apos;; #查看max_connections这个变量+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 151 |+-----------------+-------+1 row in set (0.01 sec) 看当前mysql里的所有的变量 1root@(none) 15:39 mysql&gt;show variables ; #查看当前mysql里的所有的变量 查看mysql的端口号 1234567root@(none) 15:39 mysql&gt;show variables like &apos;port&apos;;+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3309 |+---------------+-------+1 row in set (0.05 sec) 查看打开文件的最大数 1234567root@(none) 15:42 mysql&gt;show variables like &apos;open%&apos;;+------------------+-------+| Variable_name | Value |+------------------+-------+| open_files_limit | 5000 |+------------------+-------+1 row in set (0.00 sec) 查看内存的使用情况 1234[root@mysql-2 boot]# free -m #查看内存的使用情况（以M为单位显示大小） total used free shared buff/cache availableMem: 1819 369 210 9 1240 1210Swap: 2047 0 2047 查看mysql缓冲池大小 1234567root@(none) 15:42 mysql&gt;show variables like &apos;innodb_buffer_pool_size&apos;;+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| innodb_buffer_pool_size | 134217728 |+-------------------------+-----------+1 row in set (0.00 sec) 如何让linux系统开机执行 ulimit -n 655350 ？答案： 将这条命令写入/etc/rc.local文件 123[root@mysql-2 boot]# vim /etc/rc.local ulimit -n 655350 --》在文件的末尾添加[root@mysql-2 boot]# chmod +x /etc/rc.d/rc.local #需要授予可执行权限，不然不会生效 如果今后有需要开机执行某个命令的需求，建议将命令放到/etc/rc.local里 mysqld服务启动不起来？如何排除? 123[root@mysql-2 boot]# service mysqld restartShutting down MySQL.... SUCCESS! Starting MySQL... ERROR! The server quit without updating PID file (/data/mysql/mysql-2.pid). 排错主要看错误提醒和日志文件 1[root@mysql-2 boot]# cat /var/log/mysql/mysql.log 2019-03-11T08:18:43.399355Z 0 [ERROR] unknown option ‘–auto-rehash’ –》不知道的选项，只有配置文件里有选项–》配置文件里的配置有问题2019-03-11T08:18:43.399445Z 0 [ERROR] Aborting [ERROR] 错误信息 –》非常重视[Note] 普通的信息 1234567891011[mysqld]socket=/data/mysql/mysql.sockport = 3309open_files_limit = 8192innodb_buffer_pool_size = 256Mauto-rehash ##存放的位置不对prompt=\\u@\\d \\R:\\m mysql&gt; #存放的位置不对#user=mysql#skip-grant-tables#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置 修改配置文件 123[mysql] ---》是在mysql进程里的配置，不是mysqld进程的配置auto-rehashprompt=\\u@\\d \\R:\\m mysql&gt; 修改了配置文件，一定要刷新服务 12[root@mysql-2 boot]# service mysqld startStarting MySQL. SUCCESS! 使用SQLyog来建表建库，认识表和库是什么？库里存放表，表里存放一条一条的信息]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的各种安装方式]]></title>
    <url>%2F2019%2F05%2F28%2Fmysql%2FMySQL%E7%9A%84%E5%90%84%E7%A7%8D%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[MySQL是什么？ 123456MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是一个软件，用来存放数据。用它来存放数据，特别方便，查找和存储数据都非常方便。MySQL 是一个中小型数据库。MySQL是开源数据库。不是免费的数据库软件。有开源版本的数据库，这个是不要钱。MySQL 的开源版本不要钱。企业版都是需要购买。 哪些地方需要使用数据库？ 12银行、股市、学校、公交车、小区、游戏、网站、快递、导航、税务等只要和钱有关的地方就有数据库 安装MySQL安装linux系统centos7 1810.iso数据库服务器是公司的核心服务器–&gt;配置必须要 下载MySQL软件官方网站https://www.mysql.com/The world’s most popular open source database。世界上最流行的开源数据库。Oracle MySQL Cloud Service (commercial) 云服务器版本MySQL Enterprise Edition (commercial) 企业版MySQL Cluster CGE (commercial) 集群版本MySQL Community Edition (GPL) 社区版 –》免费 MySQL的版本：8版本–》 8.0.155版本–》 5.7MySQL Community Server 5.7.25 安装rpm包方式安装500M–》linux系统里 1[root@localhost ~]# yum install lrzsz -y #解决传输文件的问题 windows--》linux传文件 安装步骤 解压安装包1[root@localhost ~]# tar xf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar 安装1[root@localhost ~]# yum install mysql-community-* mysql-community-server 是MySQL提供服务功能的软件包mysql-community-client 客户端管理需要的工具mysql-community-libs 库文件 librarymysql-community-devel 开发工具和接口程序 developmentmysql-community-test 测试环境软件mysql-community-embedded 嵌入式相关的软件 启动MySQL程序​ 12[root@localhost ~]# service mysqld startRedirecting to /bin/systemctl start mysqld.service mysql daemon 守护进程 –》mysqld守护进程：这个程序是一直运行的，不是运行一下，马上就关闭。因为有人会随时来访问，都可以访问这个进程。 12345[root@localhost ~]# service mysqld status #参看mysql的状态[root@localhost ~]# ps aux|grep mysqld #查看mysqld的进程是否存在mysql 27129 0.3 4.8 1119708 185728 ? Sl 15:13 0:01 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidroot 27172 0.0 0.0 112724 984 pts/0 S+ 15:19 0:00 grep --color=auto mysqld[root@localhost ~]# mysql会开发3306端口 使用lsof命令查看端口号是否被占用 12345[root@localhost ~]# yum install lsof -y[root@localhost ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 27129 mysql 22u IPv6 76271 0t0 TCP *:mysql (LISTEN)[root@localhost ~]# 如何知道本机里开发了哪些端口？ 1234567891011121314[root@localhost ~]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6085/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 6307/master tcp 0 0 192.168.0.37:22 192.168.0.11:57980 ESTABLISHED 14958/sshd: root@pt tcp 0 0 192.168.0.37:22 192.168.0.11:50402 ESTABLISHED 15518/sshd: root@pt tcp 0 52 192.168.0.37:22 192.168.0.11:53222 ESTABLISHED 15890/sshd: root@pt tcp6 0 0 :::3306 :::* LISTEN 15798/mysqld tcp6 0 0 :::22 :::* LISTEN 6085/sshd tcp6 0 0 ::1:25 :::* LISTEN 6307/master udp 0 0 0.0.0.0:68 0.0.0.0:* 15443/dhclient udp 0 0 127.0.0.1:323 0.0.0.0:* 5501/chronyd udp6 0 0 ::1:323 :::* 5501/chronyd ip：端口号 –》网络socket 槽0.0.0.0 本机上任意的ip地址。127.0.0.1 本地的回环测试接口，只能本机自己访问，别的机器不能访问:::3306 本机上任意的ip地址上开启3306端口 –》ipv6 查看别的机器开启了哪些端口？扫描工具nmap 1234567891011[root@localhost ~]# yum install nmap -y #安装nmap软件[root@localhost ~]# nmap 192.168.0.37Starting Nmap 6.40 ( http://nmap.org ) at 2019-05-06 16:39 CSTNmap scan report for 192.168.0.37Host is up (0.000014s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh3306/tcp open mysqlNmap done: 1 IP address (1 host up) scanned in 0.30 seconds 登录MySQL服务器mysql命令是用来登录mysql服务器的客户端工具 1234[root@localhost ~]# mysql -u root -pEnter password:ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)[root@localhost ~]# 使用密码登录MySQL数据库 1[root@localhost log]# mysql -uroot -p&apos;Sanchuang123xl#&apos; 解释-uroot 指定登录mysql的用户是root user-p’Sanchuang123xl#’ 指定登录的密码 password需要去查看日志，得到临时密码 1234567[root@localhost log]# cd /var/logmysqld.log mysql的日志文件[root@localhost log]# cat mysqld.log |grep &quot;tem&quot;2019-05-06T07:51:53.607329Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2019-05-06T07:51:53.630880Z 1 [Note] A temporary password is generated for root@localhost: =%rIObuds8p&amp;2019-05-06T07:51:57.783188Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables[root@localhost log]# =%rIObuds8p&amp; 是MySQL的临时密码 使用临时密码登录mysql服务器 12345678910111213141516[root@localhost lianxi]# mysql -u root -p&apos;=%rIObuds8p&amp;&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3Server version: 5.7.26Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 重新设置密码第一种方法： 12mysql&gt; set password=&apos;Root123#&apos;;Query OK, 0 rows affected (0.01 sec) 第二种方法： 1mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;Root123#&apos;; 显示查看mysql里有多少个数据库 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 退出MySQL1mysql&gt; exit mysql服务安装好后，会自动设置开机启动 如何查看本机里哪些服务是开机启动的？ 123456789[root@localhost ~]# systemctl list-unit-files #查看本机开机的时候，哪些服务是启动的disabled #不启动enabled #启动[root@localhost ~]# systemctl disable firewalld #禁用firewalld服务，开机不启动[root@localhost ~]# systemctl enable firewalld #开机启动firewalld服务[root@localhost ~]# systemctl list-unit-files|grep &quot;mysqld&quot;mysqld.service enabled #表示mysql是开机启动mysqld@.service disabled[root@localhost ~]# windows的客户端远程连接linux里的mysql的软件 1.SQLyog –》第3方公司产品 2.workbench –》mysql官方自己出品关闭防火墙软件 12[root@localhost ~]# service firewalld stop Redirecting to /bin/systemctl stop firewalld.service 查看防火墙规则 12345678910[root@localhost ~]# iptables -L Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 使用SQLyog第1次远程连接的时候，会出现不允许连接，是因为mysql为了安全的考虑，不允许远程登录如果需要远程登录，就需要考虑去授权一个用户能远程登录到mysql，如何授权？ 授权root用户使用密码远程登录1234[root@localhost ~]# mysql -uroot -p&apos;Root123#&apos; mysql&gt; grant ALL on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;Sanchuang123xl#&apos;; 授权root用户可以从任何机器登录到mysql服务器上使用的密码是Sanchuang123xl#Query OK, 0 rows affected, 1 warning (0.05 sec) grant 是数据库里的授权命令ALL 是所有的权限（select、update、delete、insert等）On . 在所有的库所有的表上 mysql.user 表示mysql数据库里的user表‘root’@’%’ 这表示一个用户名是root可以从任何地方登录identified by ‘Sanchuang123#’ 指定密码为Sanchuang123# 源码编译安装—&gt;企业里使用最多方式1.可以开启很多功能2.可以指定安装路径 –》最大的好处因为MySQL需要存放数据，需要大量的磁盘空间，企业里会单独给MySQL一个存放数据的地方。 需要一台干净的linux系统修改主机名为MySQL2临时修改主机名 123[root@localhost ~]# hostname mysql-2 [root@localhost ~]# su - root 切换用户到root上一次登录：五 3月 8 09:56:29 CST 2019从 192.168.0.188pts/0 上 永久修改主机名 1234[root@mysql-2 ~]# vi /etc/hostname [root@mysql-2 ~]# vi /etc/hostname [root@mysql-2 ~]# cat /etc/hostname mysql-2 需要mysql的源码包上传源码包到linux系统mysql-boost-5.7.25.tar和mysql-5.7.25.tar.gz的差异percona-xtrabackup、json等软件需要使用boost库，如果你安装的MySQL需要对很多软件进行支持，建议安装ysql-boost-5.7.25.tar 12[root@changsha-tianlong-db-2 ~]# yum install lrzsz -y[root@changsha-tianlong-db-2 ~]# rz 查看官方的安装文档https://dev.mysql.com/doc/refman/5.7/en/source-installation.html也可以百度 mysql 5.7.25编译安装https://www.jianshu.com/p/90769a797b88 解压1[root@changsha-tianlong-db-2 ~]# tar xf mysql-boost-5.7.25.tar.gz cmake 是一个编译工具和 gcc一样 安装依赖关系包1[root@changsha-tianlong-db-2 mysql-5.7.25]# yum install cmake ncurses-devel gcc gcc-c++ -y #安装依赖关系包 创建用户和组1[root@changsha-tianlong-db-2 network-scripts]# useradd -r -s /sbin/nologin mysql -r 创建系统用户（不会创建家目录），一般会修改shell为/sbin/nologin-M 创建用户不建立家目录 123[root@changsha-tianlong-db-2 network-scripts]# id mysqluid=997(mysql) gid=995(mysql) 组=995(mysql)[root@changsha-tianlong-db-2 network-scripts]# 进入解压后的目录，开始编译前的配置12345678910[root@changsha-tianlong-db-2 ~]# cd mysql-5.7.25/[root@changsha-tianlong-db-2 mysql-5.7.25]#[root@changsha-tianlong-db-2 mysql-5.7.25]# mkdir /data/mysql -p[root@changsha-tianlong-db-2 mysql-5.7.25]#cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \-DMYSQL_DATADIR=/data/mysql \-DSYSCONFDIR=/etc \-DMYSQL_USER=mysql \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci \-DWITH_BOOST=boost 对上面的命令进行说明：[root@changsha-tianlong-db-2 mysql-5.7.25]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \ #mysql安装目录-DMYSQL_DATADIR=/data/mysql \ #数据库文件目录-DSYSCONFDIR=/etc \ #配置文件目录-DMYSQL_USER=mysql \ #运行mysql进行的用户，如果没有需要提前添加用户和用户组-DDEFAULT_CHARSET=utf8 \ #默认字符集-DDEFAULT_COLLATION=utf8_general_ci \ #默认校对规则-DWITH_BOOST=boost #boost库，带boost的源码包只需要这样即可，不带boost源码包需要指明boost目录 编译和编译安装12[root@changsha-tianlong-db-2 mysql-5.7.25]# make -j 2 #启用多进程去编译 -j 2 启用2个进程同时进行，目的是为了加快速度[root@changsha-tianlong-db-2 mysql-5.7.25]#make install #安装 启动MySQL12345[root@changsha-tianlong-db-2 mysql-5.7.25]# cd /usr/local/mysql/ 进入安装目录[root@changsha-tianlong-db-2 mysql]# lsbin COPYING-test include man README shareCOPYING docs lib mysql-test README-test support-files[root@changsha-tianlong-db-2 mysql]# 对mysql的配置文件进行备份 123[root@changsha-tianlong-db-2 mysql]# cp /etc/my.cnf /root #备份[root@changsha-tianlong-db-2 mysql]# &gt;/etc/my.cnf #清空，因为这个文件是mariadb的[root@changsha-tianlong-db-2 bin]# pwd /usr/local/mysql/bin –》存放可执行文件的目录初始化MySQL 1[root@changsha-tianlong-db-2 bin]# ./mysqld --initialize --user=mysql --basedir=/usr/local/mysql/ --datadir=/data/mysql 复制mysql客户端命令到PATH变量路径里，方便后面使用 1[root@changsha-tianlong-db-2 bin]# cp mysql /usr/bin/ 配置能使用service 方式启动mysql，因为需要一个启动脚本，这个脚本mysql官方给我们提供了，直接复制过去就ok了 12345678[root@changsha-tianlong-db-2 mysql]# cp support-files/mysql.server /etc/init.d/mysqld[root@changsha-tianlong-db-2 mysql]# service mysqld startStarting MySQL.Logging to &apos;/data/mysql/changsha-tianlong-db-2.err&apos;.SUCCESS! [root@changsha-tianlong-db-2 mysql]# service mysqld restartShutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS! [root@changsha-tianlong-db-2 mysql]# 登录mysql，使用临时密码 123456789101112131415[root@changsha-tianlong-db-2 mysql]# mysql -uroot -p&apos;drNo5dIR?OXN&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 2Server version: 5.7.25Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; 修改密码 123456mysql&gt; set password=&apos;Sanchuang123#&apos;; #修改密码Query OK, 0 rows affected (0.00 sec)mysql&gt; exitBye[root@changsha-tianlong-db-2 mysql]# 退出验证密码是否修改成功 1234567891011121314151617[root@changsha-tianlong-db-2 mysql]# mysql -uroot -p&apos;Sanchuang123#&apos;mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; mysql&gt; quit 退出Bye 安装完后的工作：数据库服务器一般不启用防火墙，主要是考虑性能的问题。会在数据库服务器的前面加一个防火墙。 关闭防火墙firewalld，并且设置开机不要启动。123456789101112131415[root@changsha-tianlong-db-2 mysql]# service firewalld stop 关闭firewalld服务Redirecting to /bin/systemctl stop firewalld.service[root@changsha-tianlong-db-2 mysql]# systemctl disable firewalld 禁止开机启动Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.[root@changsha-tianlong-db-2 mysql]# iptables -L 查看防火墙规则Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@changsha-tianlong-db-2 mysql]# 关闭selinux1234567[root@changsha-tianlong-db-2 mysql]# getenforce Enforcing[root@changsha-tianlong-db-2 mysql]# setenforce 0 #临时关闭selinux[root@changsha-tianlong-db-2 mysql]# getenforce Permissive[root@changsha-tianlong-db-2 mysql]# vi /etc/selinux/config [root@changsha-tianlong-db-2 mysql]# cat /etc/selinux/config https://wx3.sinaimg.cn/mw690/006BsDmEgy1g3mr7h2stpj30i00cvq3m.jpg 考虑设置mysql服务开机启动123456789101112131415[root@changsha-tianlong-db-2 mysql]# systemctl enable mysqld #使用新式方式设置开机启动，提醒不能使用，建议我们使用老式的chkconfig方式mysqld.service is not a native service, redirecting to /sbin/chkconfig.Executing /sbin/chkconfig mysqld on[root@changsha-tianlong-db-2 mysql]# chkconfig mysqld on 设#置mysqld服务开机启动[root@changsha-tianlong-db-2 mysql]#[root@changsha-tianlong-db-2 mysql]#[root@changsha-tianlong-db-2 mysql]# chkconfig --list 注：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。 要列出 systemd 服务，请执行 &apos;systemctl list-unit-files&apos;。查看在具体 target 启用的服务请执行&apos;systemctl list-dependencies [target]&apos;。mysqld 0:关 1:关 2:开 3:开 4:开 5:开 6:关netconsole 0:关 1:关 2:关 3:关 4:关 5:关 6:关network 0:关 1:关 2:开 3:开 4:开 5:开 6:关[root@changsha-tianlong-db-2 mysql]# 重新启动服务器reboot 重启—-init 6poweroff关机进入linux系统 12345678[root@mysql-2 ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 6788 mysql 27u IPv6 37709 0t0 TCP *:mysql (LISTEN)[root@mysql-2 ~]# ps aux|grep mysqldroot 6619 0.0 0.0 115436 1732 ? S 15:43 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 6788 1.7 9.4 1571372 176096 ? Sl 15:43 0:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=mysql-2.err --pid-file=/data/mysql/mysql-2.pidroot 7249 0.0 0.0 112724 984 pts/0 S+ 15:44 0:00 grep --color=auto mysqld[root@mysql-2 ~]# 说明mysql真得是开机启动了 使用SQLyog远程连接到MySQL授权一个用户能远程登录1234mysql&gt; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;Sanchuang123#&apos;;Query OK, 0 rows affected, 1 warning (0.02 sec)mysql&gt; 使用SQLyog远程连接注：编译安装mysql的时候，建议内存给大些，给4G，cpu给2个核就可以了服务器一般都是固定IP编译安装：1.编译前的配置（如果编译器是gcc）,主要是用来生成MakeFile文件–》就是编译的时候的配置文件例如：安装到什么位置，哪些功能开，哪些不开？yum install pcre-devel zlib-devel gcc gcc-c++./configure –prefix=/usr/local/nginx2.make 编译 ，根据MakeFile文件进行编译，将源代码编译成二进制文件3.make install 编译安装，其实就是将编译好的二进制文件复制到安装目录去。 yum安装-不建议使用1yum install MySQL -y poweroff 是关机的命令reboot 重新启动init 6 重新启动 需要2台虚拟机–》克隆 centos7里默认的数据库是Mariadb不是mysql mariadb是MySQL的分支 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 数据库排名https://db-engines.com/en/ranking 购买mysql的规矩：一台电脑只能安装一套软件。 根据电脑里的cpu的颗数，颗数越多价格越高]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>安装</tag>
      </tags>
  </entry>
</search>
