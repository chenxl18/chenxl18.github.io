{"meta":{"title":"xll的个人网站","subtitle":"得之我幸，失之我命","description":null,"author":"xll","url":"https://chenxl18.github.io","root":"/"},"pages":[{"title":"(・o・)","date":"2019-05-30T03:47:58.000Z","updated":"2019-05-30T08:05:55.843Z","comments":true,"path":"about/index.html","permalink":"https://chenxl18.github.io/about/index.html","excerpt":"","text":"“物欲无从起，心随他人平”——冯唐 联系方式： Email：1210972564@qq.com QQ：1210972564 WeChat：17873550094 博客历程： 2019-05-20 创建github 2019-05-28 成功搭建基于Hexo+Next的GitPages个人博客系统 2019-05-28 推送人生中第一篇博客 2019-05-30 博客中成功添加搜索功能"},{"title":"分类","date":"2019-05-30T05:38:31.000Z","updated":"2019-05-30T07:28:52.958Z","comments":true,"path":"categories/index.html","permalink":"https://chenxl18.github.io/categories/index.html","excerpt":"","text":""},{"title":"music","date":"2019-05-30T02:31:44.000Z","updated":"2019-05-30T03:46:43.783Z","comments":true,"path":"music/index.html","permalink":"https://chenxl18.github.io/music/index.html","excerpt":"","text":"————把最喜欢的音乐分享给你们 我最喜欢的歌手Morris赖仔 网易云地址： https://music.163.com/#/artist?id=12291727 喜欢的歌"},{"title":"标签","date":"2019-05-30T05:38:04.000Z","updated":"2019-06-14T12:12:32.278Z","comments":true,"path":"tags/index.html","permalink":"https://chenxl18.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"django初探-03返回动态页面","slug":"web开发/django初探-03返回动态页面","date":"2019-07-24T12:25:42.000Z","updated":"2019-07-24T12:53:43.978Z","comments":true,"path":"2019/07/24/web开发/django初探-03返回动态页面/","link":"","permalink":"https://chenxl18.github.io/2019/07/24/web开发/django初探-03返回动态页面/","excerpt":"","text":"Django-返回动态页面 目标：数据库交互，返回用户提交的数据 Django中可以通过自带的ORM框架操作数据库，并且自带轻量级的sqlite3数据库。 1. 配置数据库信息: 默认使用的是sqlite（它还支持很多） 12345678910111213141516171819202122232425# djangostart/settings.py# Database# https://docs.djangoproject.com/en/1.11/ref/settings/#databases# Sqlie配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', # 存放路径 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# MySQL配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'myblog02', 'USER': 'root', 'PASSWORD': '12345', 'HOST': '192.168.137.200', 'PORT': '3306', 'OPTIONS': &#123; 'init_command': \"SET sql_mode='STRICT_TRANS_TABLES'\", &#125;,&#125; 注意，遇到报MySQLdb错误，请用以下解决办法： 方法1：安装mysqlclient 方法2：安装pymysql，在项目mysite/init.py文件添加： 12import pymysqlpymysql.install_as_MySQLdb() 这里我们创建了2个字段，分别保存用户的邮箱和密码。 2. 建立数据库模型123456# 编辑app01/models.py(MTV中的M)from django.db import models# 继承models.Model类class UserInfo(models.Model): username = models.CharField(max_length=64) password = models.CharField(max_length=128) 3. 注册app01 不注册它，你的数据库就不知道该给哪个app创建表 12345678910# djangostart/settings.pyINSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'app01',] 4. 生成建表文件1234&gt; python manage.py makemigrationsMigrations for 'app1':app1\\migrations\\0001_initial.py- Create model UserInfo 5. 执行建表操作123456789101112131415161718&gt; python manage.py migrateOperations to perform:Apply all migrations: admin, app1, auth, contenttypes, sessionsRunning migrations:Applying contenttypes.0001_initial... OKApplying auth.0001_initial... OKApplying admin.0001_initial... OKApplying admin.0002_logentry_remove_auto_add... OKApplying app1.0001_initial... OKApplying contenttypes.0002_remove_content_type_name... OKApplying auth.0002_alter_permission_name_max_length... OKApplying auth.0003_alter_user_email_max_length... OKApplying auth.0004_alter_user_username_opts... OKApplying auth.0005_alter_user_last_login_null... OKApplying auth.0006_require_contenttypes_0002... OKApplying auth.0007_alter_validators_add_error_messages... OKApplying auth.0008_alter_user_username_max_length... OKApplying sessions.0001_initial... OK 6. 保存用户数据1234567891011# app01/views.pydef register(request): print(request.method) if request.method == 'POST': username = request.POST.get(\"username\", None) password = request.POST.get(\"password\", None) # 添加数据到库 UserInfo.objects.create(username=username, password=password) # 查询数据 user_list = UserInfo.objects.all() return render(request, 'register.html', &#123;'user_list': user_list&#125;) 7. 修改templates/demo01.html，添加以下数据` undefined ` 8. 访问结果 9. 小结至此，一个要素齐全，主体框架展示清晰的django项目完成了","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"django","slug":"python/django","permalink":"https://chenxl18.github.io/categories/python/django/"}],"tags":[{"name":"返回动态页面","slug":"返回动态页面","permalink":"https://chenxl18.github.io/tags/返回动态页面/"},{"name":"与数据库建立连接","slug":"与数据库建立连接","permalink":"https://chenxl18.github.io/tags/与数据库建立连接/"}]},{"title":"django初探-02返回HTML页面","slug":"web开发/django初探-02返回HTML页面","date":"2019-07-24T11:51:42.000Z","updated":"2019-07-24T12:50:26.320Z","comments":true,"path":"2019/07/24/web开发/django初探-02返回HTML页面/","link":"","permalink":"https://chenxl18.github.io/2019/07/24/web开发/django初探-02返回HTML页面/","excerpt":"","text":"通常在实际开发中，我们会将html代码与业务逻辑代码分离，这样结构更清晰 1. 编写html文件我们写这么一个templates/demo01.html文件，内容来源： http://v3.bootcss.com/getting-started/#template http://v3.bootcss.com/css/#forms css-js文件 html内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# templates/demo01.html&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;你好，世界！&lt;/h1&gt; &lt;div class=\"col-md-12\"&gt; &lt;form&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputFile\"&gt;File input&lt;/label&gt; &lt;input type=\"file\" id=\"exampleInputFile\"&gt; &lt;p class=\"help-block\"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2. 修改views文件添加具体要执行的业务内容 12345# app01/views.pyfrom django.shortcuts import renderdef demo01(request): # 参数1固定的，参数2为模块文件，具体可看render源码（最终返回一个HttpResponse对象） return render(request, 'demo01.html') 3. 配置Settings为了让django知道我们的html文件在哪里，需要修改settings文件的相应内容。 123456789101112131415161718# djangostart/settings.pyTEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', # 修改此处，让Django到这里的目录找html模板文件 'DIRS': [os.path.join(BASE_DIR, 'templates')], # APP_DIRS为True时，会自动去INSTALLED_APPS应用的templates查找html文件 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.Template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,] 4.保存()ctrl+s 5. 启动web服务查看结果：能够正确找到html文件，但是静态文件似乎没有加载（F12查看） 6. 使用静态文件（用bootstrap写一个信息录入页面）在django中，一般将静态文件放在static目录中.接下来，在mysite/app01中新建个static目录并准备好资源. 准备静态文件 Jquery为网络资源 Bootstrap相关的为本地资源 放到./static目录： 所有静态文件（css/js/imgs）都可以放到这个目录 7. settings配置：站点的配置信息都在这里12345678# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.11/howto/static-files/# 静态文件以/static/开头STATIC_URL = '/static/'# 静态文件查找路径，注意不要写错参数名STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'static')] STATIC_URL是指引用名，不是具体的目录，HTML文件中静态文件名字需要与它对应, 表示哪种文件会被识别成静态文件 STATICFILES_DIR去这里配置的目录下找静态文件(注意此处为list or tuple否则加载静态文件会报错) 8. 修改html文件中的引用123456# 修改前&lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"js/bootstrap.Min.js\"&gt;&lt;/script&gt;# 修改后&lt;link href=\"/static/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;&lt;script src=\"/static/js/bootstrap.min.js\"&gt;&lt;/script&gt; 9. 重新启动web服务刷新浏览器，查看结果. 10.修改模板文件 文件：templates/demo01.html input添加name from表单的几个要素：methodmethod=get 11.修改视图函数12345678910# app01/views.pyfrom django.shortcuts import renderdef demo01(request): print(request.method) if request.method == 'POST': username = request.POST.get(\"username\") password = request.POST.get(\"password\") user = &#123;'username':username, 'password':password&#125; return render(request, 'demo01.html', &#123;'user': user&#125;) 12. 浏览器测试输入用户名，密码 要在浏览器上可以看到提交的信息, 浏览器上要做以下渲染 django采用自己的模板语言，类似jinja2，根据提供的数据，替换掉html中的相应部分。 1234&lt;hr/&gt;用户信息：&#123;&#123;user&#125;&#125;&lt;br/&gt;用户名：&#123;&#123;user.username&#125;&#125;&lt;br/&gt;密码：&#123;&#123;user.password&#125;&#125; 13. POST方式会有一个跨站请求保护机制 可将form表单提交方式分别设置成GET、POST方式 Post方式提交时，出错，因为django有一个跨站请求保护机制，我们目前可在settings文件中将它关闭。 修改settings设置，暂时先取消使用这个中间件， 12345678910# djangostart/settings.pyMIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',] 14.登录页面 修改djangostart/urls.py 修改djangostart\\app01\\views.py 在此路径下添加一个html页面（注意要与views.py的return文件一样） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;Bootstrap 101 Template&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href=\"/static/app01/css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;简单的表单提交&lt;/h1&gt; &lt;div class=\"col-md-5\"&gt; &#123;% csrf_token %&#125; &lt;form method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;Email address&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"Email\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;Password&lt;/label&gt; &lt;input name=\"password\" type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"Password\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputFile\"&gt;File input&lt;/label&gt; &lt;input type=\"file\" id=\"exampleInputFile\"&gt; &lt;p class=\"help-block\"&gt;Example block-level help text here.&lt;/p&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; Check me out &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src=\"/static/app01/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 用户名密码正确 错误则返回登录页面","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"Django","slug":"python/Django","permalink":"https://chenxl18.github.io/categories/python/Django/"}],"tags":[{"name":"返回HTML页面","slug":"返回HTML页面","permalink":"https://chenxl18.github.io/tags/返回HTML页面/"},{"name":"登录页面","slug":"登录页面","permalink":"https://chenxl18.github.io/tags/登录页面/"}]},{"title":"django初探-01","slug":"web开发/django初探-01","date":"2019-07-24T10:55:52.000Z","updated":"2019-07-24T11:51:00.570Z","comments":true,"path":"2019/07/24/web开发/django初探-01/","link":"","permalink":"https://chenxl18.github.io/2019/07/24/web开发/django初探-01/","excerpt":"","text":"1. 常用命令 django-admin: 常用来创建项目及应用 123456789101112131415161718192021222324252627Type 'django-admin help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[django]checkcompilemessagescreatecachetabledbshelldiffsettingsdumpdataflushinspectdbloaddatamakemessagesmakemigrationsmigraterunserversendtestemailshellshowmigrationssqlflushsqlmigratesqlsequenceresetsquashmigrationsstartappstartprojecttesttestserver manage.py：常用来管理项目，如运行开发环境，数据库操作，用户操作等 12345678910111213141516171819202122232425262728293031323334353637Type 'manage.py help &lt;subcommand&gt;' for help on a specific subcommand.Available subcommands:[auth] changepassword createsuperuser[contenttypes] remove_stale_contenttypes[django] check compilemessages createcachetable dbshell diffsettings dumpdata flush inspectdb loaddata makemessages makemigrations migrate sendtestemail shell showmigrations sqlflush sqlmigrate sqlsequencereset squashmigrations startapp startproject test testserver[sessions] clearsessions[staticfiles] collectstatic findstaticrunserver 2. 创建项目 创建项目 ： django-admin startproject djangostart 创建应用：cd djangostart;django-admin startapp app01 在项目目录下djangostart下创建app01 3. 站点结构解析 将apps目录加入到全局搜索路径(mark as-source) 找到setting.py文件，添加app01 Django功能目录介绍 .git 配置、版本历史 gitignore 忽略某些文件（不检查编号，不上传git仓库） Django的APP以及目录介绍 __init__.py:初始化文件 setting.py:配置文件 urls.py:拥有强大的路由系统，做路由的（地址栏） wsgi.py:web网关服务接口,连接webserver和application的接口 manage.py：常用来管理项目，如运行开发环境，数据库操作，用户操作等 admin.py:Django有一个非常强大的后台管理系统，通过这个文件，来连接 apps.oy:对本项目做一些配置的文件 models.py:模型层，和数据库相关的东西都放在这里面 tests.py:测试用例放在里面 views.py:视图文件 4.编写一个最简单的页面 编写路由（路由都在urls文件里，它将浏览器输入的url映射到相应的业务处理逻辑。） 12345678910# mysite/urls.pyfrom django.conf.urls import urlfrom django.contrib import adminfrom app1 import viewsurlpatterns = [ # admin后台路由 url(r'^admin/', admin.site.urls), # 自定义路由 url(r'^demo01/', views.demo01),] 编写业务处理逻辑（业务处理逻辑都在views.py文件里） 12345678910# app1/views.pyfrom django.shortcuts import renderfrom django.shortcuts import HttpResponse# request 必填，名字可以修改，封装了用户请求的所有内容def demo01(request): html = '&lt;h1&gt;i am demo01&lt;/h1&gt;' print(html) # 此处不能直接return html, 必须返回一个HttpResponse对象 return HttpResponse(html) 运行web服务 命令行执行python manage.py runserver 127.0.0.1:8000 或者鼠标选中整个项目，然后点三角形 404页面 Django的错误页，非常重要的排错依据，务必仔细阅读 错误原因：地址栏应该是127.0.0.1:8000/demo01","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"Django","slug":"python/Django","permalink":"https://chenxl18.github.io/categories/python/Django/"}],"tags":[{"name":"站点解析","slug":"站点解析","permalink":"https://chenxl18.github.io/tags/站点解析/"},{"name":"简单页面","slug":"简单页面","permalink":"https://chenxl18.github.io/tags/简单页面/"}]},{"title":"请求响应流程","slug":"web开发/请求响应流程","date":"2019-07-23T03:34:58.000Z","updated":"2019-07-24T10:53:40.392Z","comments":true,"path":"2019/07/23/web开发/请求响应流程/","link":"","permalink":"https://chenxl18.github.io/2019/07/23/web开发/请求响应流程/","excerpt":"","text":"MVC模式 模型（M）:定义数据库相关的内容，负责业务对象与数据库的映射（ORM） 视图（V）:定义HTML等静态网页文件相关，负责与用户的交互（页面） 控制器（C）:定义业务逻辑相关，就是你的主要代码，负责接收用户的输入调用模型和视图完成用户的请求 Django的MTV模式 M代表模型（Model）：负责业务对象和数据库的关系映射（ORM）（如何存取，如何验证有效性，包含哪些行为以及数据之间的关系等） T代表模板（Template）：负责如何把页面展示给用户（html） V代表视图（View）：负责业务逻辑，并在适当时候调用Model和Template MVC/MVT设计模式关键的优势 开发者更改一个应用程序中的URL而不用影响到这个程序底层的实现 设计师可以改变HTML页面的样式而不用接触业务逻辑代码 数据库管理员可以重新命名数据表并且只需更改模型 请求响应流程图（简版） 请求响应流程图（复杂版） 前面的图片展示了从一个访客的浏览器到Django应用并返回的一个web请求的简单历程。如下是数字标识的路径： 浏览器发送请求（基本上是字节类型的字符串）到web服务器 web服务器（比如，Nginx）把这个请求转交到一个WSGl（比如，uWSGl），或者直接地文件系统能够取出一个文件（比如，一个CSS文件） 不像web服务器那样，WSGl服务器可以直接运行Python应用。请求生成一个被称为environ的Ptyhon字典，而且，可以选择传递过去几个中间件的层，最终，达到Diango应用 URLconf中含有属于应用的urls.py选择一个视图处理基于请求的URL的那个请求，这个请求就已经变成了 HttpRequest——一个Python字典对象 被选择的那个视图通常要做下面所列出的一件或者更多件事情： A. 通过模型与数据库对话 B. 使用模板渲染HTML或者任何格式化过的响应 C. 返回一个纯文本响应（不被显示的） D. 抛出一个异常 HttpResponse对象离开Django后，被渲染为一个字符串 在浏览器见到一个美化的，渲染后的web页面","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"Django请求响应流程","slug":"python/Django请求响应流程","permalink":"https://chenxl18.github.io/categories/python/Django请求响应流程/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://chenxl18.github.io/tags/Django/"}]},{"title":"Django介绍","slug":"Django介绍","date":"2019-07-23T03:17:07.000Z","updated":"2019-07-23T03:34:19.125Z","comments":true,"path":"2019/07/23/Django介绍/","link":"","permalink":"https://chenxl18.github.io/2019/07/23/Django介绍/","excerpt":"","text":"Django介绍1).Django历史 源自于一个在线新闻Web站点，于2005年以开源的形式被释放出来。 官网：https://www.djangoproject.com/?tdsourcetag=s_pcqq_aiomsg 2).Django特点 主要目的是简便、快速地开发数据库驱动的网站 功能丰富：自带ORM、URL分发、模板系统、表单处理、Cache系统、会话管理、国际化、后台管理 可扩展：pypi及git上有很多基于Django开发的应用 3).Django优缺点 优点 完美的文档 全套的解决方案 强大的URL路由配置 自助管理后台 缺点 系统紧耦合，灵活性差 4).关于性能 性能问题最常出现在数据库访问和文件读写上（磁盘） 没有一定的访问量前谈性能其实是没有多大意义的 人力成本才是最贵的（21世纪，人才最贵）","categories":[{"name":"Django","slug":"Django","permalink":"https://chenxl18.github.io/categories/Django/"}],"tags":[{"name":"Django基本介绍","slug":"Django基本介绍","permalink":"https://chenxl18.github.io/tags/Django基本介绍/"}]},{"title":"github创建Djanggo项目流程","slug":"web开发/github创建Djanggo项目流程","date":"2019-07-23T02:48:04.000Z","updated":"2019-07-23T03:16:30.501Z","comments":true,"path":"2019/07/23/web开发/github创建Djanggo项目流程/","link":"","permalink":"https://chenxl18.github.io/2019/07/23/web开发/github创建Djanggo项目流程/","excerpt":"","text":"Git创建Django项目及其配置 在GitHub上创建一个仓库，后期所有代码都上传到Django_learning这个仓库 克隆仓库到本地，做好相关配置 git clone https://github.com/chenxl18/Django-learning.git 初始化Git git init 基于master新建一个分支： $ git checkout -b v0.1-django-start 在v0.1分支创建虚拟环境: $ python -m venv venv 进入虚拟环境 $ source venv/Scripts/activate 在虚拟环境下安装Django pip install django==1.11.20 配置虚拟环境（将虚拟环境下的安装包写入此文件） pip freeze &gt; requirements.txt 退出虚拟环境 deactivate 修改.gitignore文件 .idea/ venv/ 把改动提交到仓库 12345678910$ git status# 查看状态$ git add requirements.txt# 标记requirements.txt$ git add .gitignore# 标记.gitignore$ git commit -m 'env init'# 提交到远程仓库的注释信息$ git push --set-upstream origin v0.1-django-start# 配置提交的远程分支 把不需要的文件提交到了远程仓库怎么办？ 改.gitignore文件 mv venv01 /tmp 提交一次（git add,git commit,git push） mv /tmp venv01 提交一次（git add,git commit,git push）","categories":[{"name":"Django","slug":"Django","permalink":"https://chenxl18.github.io/categories/Django/"}],"tags":[{"name":"Django","slug":"Django","permalink":"https://chenxl18.github.io/tags/Django/"},{"name":"git","slug":"git","permalink":"https://chenxl18.github.io/tags/git/"}]},{"title":"LAMP和LNMP","slug":"linux/LAMP和LNMP","date":"2019-07-13T01:54:08.000Z","updated":"2019-07-22T12:50:49.559Z","comments":true,"path":"2019/07/13/linux/LAMP和LNMP/","link":"","permalink":"https://chenxl18.github.io/2019/07/13/linux/LAMP和LNMP/","excerpt":"","text":"LAMP和LNMPLNMP:（一种开发环境） linux nginx MySQL php/python/perl(php是一门语言，专门写网站) zabbix (监控软件)–&gt;php–&gt;LANP LAMP: linux apache(httpd) MySQL(mariadb) php/python/perl 为什么企业非常喜欢使用LAMP/LNMP 因为免费并且开源 成本低廉（吸引人的地方） 搭建一个自己的网站​ nginx：Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 apache和nginx的差异？ 安装、软件名字 apache的提供服务的软件包名叫httpd，nginx的叫nginx 市场上的占有率 apache比nginx多 apache出来的时间早 ，nginx是后起之秀 工作原理：apache采用进程，nginx采用线程（线程更省资源，进程更稳定） 软件功能和大小 apache功能多（ 重量级），代码多 轻量级的web服务器软件（nginx） 讲讲配置项的差异 站队： taobao –》Tengine –》taobao nginx Server: BWS/1.1 安装：yum 安装可以使用epel源或者官方源 123456789101112131415[root@sanchuang ~]# yum install epel-release -y[root@sanchuang ~]# cd /etc/yum.repos.d/[root@sanchuang yum.repos.d]# lsCentOS-Base.repo CentOS-Debuginfo.repo CentOS-Media.repo CentOS-Vault.repo epel-testing.repoCentOS-CR.repo CentOS-fasttrack.repo CentOS-Sources.repo epel.repo[root@sanchuang yum.repos.d]# vim nginx.repo[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[root@sanchuang yum.repos.d]# yum install nginx -y[root@sanchuang nginx]# pwd/etc/nginx 123456789101112131415nginx.conf --》主配置文件[root@sanchuang ~]# yum install httpd -y[root@sanchuang ~]# cd /etc/httpd/ 存放配置文件的路径[root@sanchuang httpd]# lsconf conf.d conf.modules.d logs modules run[root@sanchuang httpd]# cd conf[root@sanchuang conf]# lshttpd.conf magic配置文件的路径： serverroot nginx --》/etc/nginx/nginx.conf httpd --&gt;/etc/httpd/conf/httpd.conf存放网页的路径： documentroot httpd --》DocumentRoot \"/var/www/html\" nginx --》root /usr/share/nginx/html;配置文件对比 进程和线程方式 location –》路由 对某个目录进行权限的设置 12345&lt;Directory \"/var/www\"&gt; AllowOverride None # Allow open access: Require all granted&lt;/Directory&gt; 注：将welcome.conf 删除，这样httpd的网站根目录就成了一个ftp服务器，可以下载文件 httpd.conf配置部分解释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[root@sanchuang conf]# cat httpd.conf |egrep -v \"^#|^$|\\s+#\"ServerRoot \"/etc/httpd\" --》安装的目录Listen 8080 --》监听的端口号Include conf.modules.d/*.conf --》包括其他的配置文件User apache 启动进程使用的用户Group apache 启动进程使用的组ServerAdmin root@localhost 管理员的邮箱&lt;Directory /&gt; AllowOverride none Require all denied&lt;/Directory&gt;DocumentRoot \"/var/www/html\" --》存放网页目录&lt;Directory \"/var/www\"&gt; AllowOverride None Require all granted&lt;/Directory&gt;&lt;Directory \"/var/www/html\"&gt; Options Indexes FollowSymLinks AllowOverride None Require all granted&lt;/Directory&gt;&lt;IfModule dir_module&gt; DirectoryIndex index.html --》规定网站的首页 DirectoryIndex shouye.html index.html index.php 指定多个首页文件，按从左到右的顺序，去查询&lt;/IfModule&gt;&lt;Files \".ht*\"&gt; Require all denied&lt;/Files&gt;ErrorLog \"logs/error_log\"LogLevel warn&lt;IfModule log_config_module&gt; LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b \\\"%&#123;Referer&#125;i\\\" \\\"%&#123;User-Agent&#125;i\\\"\" combined LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b\" common &lt;IfModule logio_module&gt; LogFormat \"%h %l %u %t \\\"%r\\\" %&gt;s %b \\\"%&#123;Referer&#125;i\\\" \\\"%&#123;User-Agent&#125;i\\\" %I %O\" combinedio &lt;/IfModule&gt; CustomLog \"logs/access_log\" combined&lt;/IfModule&gt;&lt;IfModule alias_module&gt; ScriptAlias /cgi-bin/ \"/var/www/cgi-bin/\" Alias /chenxianle \"/var/www/html/chenxianle\" # 访问的url 192.168.0.241:8080/chenxianle 会自动访问/var/www/html/chenxianle目录里的网页&lt;/IfModule&gt;&lt;Directory \"/var/www/cgi-bin\"&gt; AllowOverride None Options None Require all granted&lt;/Directory&gt;&lt;IfModule mime_module&gt; TypesConfig /etc/mime.types AddType application/x-compress .Z AddType application/x-gzip .gz .tgz AddType text/html .shtml AddOutputFilter INCLUDES .shtml&lt;/IfModule&gt;AddDefaultCharset UTF-8&lt;IfModule mime_magic_module&gt; MIMEMagicFile conf/magic&lt;/IfModule&gt;EnableSendfile onIncludeOptional conf.d/*.conf[root@sanchuang conf]# 搭建一个网站： 1.apache --》8080 ---》www.dinglang.com 2.nginx --》80 ---&gt;www.jack.comnginx里的配置文件/etc/hosts windows里的主配置文件C:\\Windows\\System32\\drivers\\etc\\hosts apache和nginx都是对静态页面的支持 apache如何支持php写的程序 nginx如何知道python写的程序 动静分离： 静态页面---》nginx 动态页面 --》php/python 通过url来实现识别 静态页面和动态页面的区别？ huhai.py huhai.php huhai.js 是否有后端程序去数据库里读写数据，数据的变化 12345[root@sanchuang conf.modules.d]# vim 00-mpm.conf LoadModule mpm_prefork_module modules/mod_mpm_prefork.soStartServers 50ServerLimit 256MaxSpareServers 10 核心特性与多处理模块(MPM)—》apache prefork –》预先产生进程，等着客户来访问 –》apache StartServers 200 启动多少进程数 MinSpareServers 最少备用的进程数 MaxSpareServers 20 最多备用的进程数 MaxRequestWorkers 同时最多可以有多少请求数 MaxConnectionsPerChild 一个进程可以处理多少次的请求 ServerLimit 256 最多支持256个访问量 优点是稳定缺点：消耗资源（内存、cpu） 一个用户访问3M *10000 =30G worker：多进程和多线程混合的模式 multi-threaded multi-process web server ServerLimit 16StartServers 2MaxRequestWorkers 150MinSpareThreads 25MaxSpareThreads 75ThreadsPerChild 25zabbix –》 event ：纯线程处理模式 –》nginx event MPM: A variant of the worker MPM with the goal of consumingthreads only for connections with active processing我如何验证？ 模拟同时1000人去访问 压力测试 服务器的瓶颈在哪里？ 资源的角度：cpu、内存、网络带宽、磁盘IO [root@sanchuang ~]# ab -c 10000 -n 10000 http://192.168.0.241/dinglang/index.htmlThis is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/ Benchmarking 192.168.0.241 (be patient)socket: Too many open files (24)[root@sanchuang ~]#[root@sanchuang ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 7221max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024 默认内核允许一个进程最多可以打开1024个文件 [root@sanchuang ~]# ulimit -n 100000 临时修改内核允许的一个进程可以打开多少文件数量的限制[root@sanchuang ~]# ulimit -acore file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 7221max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 100000pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 7221virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited[root@sanchuang ~]# [root@sanchuang nginx]# cat access.log |awk ‘{print $1}’|sort |uniq -c 32 192.168.0.102 38 192.168.0.104 50 192.168.0.126 17 192.168.0.13 4 192.168.0.140 8051 192.168.0.152 8 192.168.0.155 102 192.168.0.208 3577 192.168.0.241 4 192.168.0.35 72 192.168.0.41 5 192.168.0.50 6 192.168.0.61[root@sanchuang nginx]#","categories":[{"name":"linux高阶","slug":"linux高阶","permalink":"https://chenxl18.github.io/categories/linux高阶/"},{"name":"web","slug":"linux高阶/web","permalink":"https://chenxl18.github.io/categories/linux高阶/web/"}],"tags":[{"name":"LAMP","slug":"LAMP","permalink":"https://chenxl18.github.io/tags/LAMP/"},{"name":"LNMP","slug":"LNMP","permalink":"https://chenxl18.github.io/tags/LNMP/"}]},{"title":"上下文管理器","slug":"python/上下文管理器","date":"2019-07-11T11:29:18.000Z","updated":"2019-07-11T11:29:18.817Z","comments":true,"path":"2019/07/11/python/上下文管理器/","link":"","permalink":"https://chenxl18.github.io/2019/07/11/python/上下文管理器/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"闭包与装饰器","slug":"python/闭包与装饰器","date":"2019-07-10T01:40:35.000Z","updated":"2019-07-11T12:49:26.950Z","comments":true,"path":"2019/07/10/python/闭包与装饰器/","link":"","permalink":"https://chenxl18.github.io/2019/07/10/python/闭包与装饰器/","excerpt":"","text":"什么是闭包 在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。 闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。 在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 形成闭包的三个条件，缺一不可： 必须有一个内嵌函数（函数里定义的函数）——这对应函数之间的嵌套 内嵌函数必须引用一个定义在闭合范围内（外部函数里）的变量——内部函数引用外部变量 外部函数必须返回内嵌函数——必须返回那个内部函数 闭包的概念很简单：一个可以引用在函数闭合范围内变量的函数。即”内部函数”，只有那个内部函数才有所谓的__closure__属性。 Python 变量作用域的规则是 LEGB LEGB含义解释： L —— Local(function)；函数内的名字空间 通过 locals() 可以查看 Local 的所有变量 E —— Enclosing function locals；外部嵌套函数的名字空间(例如closure) G —— Global(module)；函数定义所在模块（文件）的名字空间、 通过 globals() 可以查看 globals 的所有变量。 1234import syssys.int_infoOutput:sys.int_info(bits_per_digit=30, sizeof_digit=4) - 调用模块时，就需要指定路径 - B —— Builtin(Python)；Python内置模块的名字空间 - Python 自带的 内置命名空间，主要是 内置函数，异常类 等。可以通过 ` dir(__builtins__)`来查看 - 该部分的部分一般情况不应该修改。 - 真正修改/删除 或 新增时，需要`__builtins__.****`来指定 - 可以在本地增加同名的命名，由于 Locals 和 Global 优先于 builtin，该命名的优先级就高于 Builtin 了 闭包 形成闭包之后，闭包函数会获得一个非空的__closure__属性（对比我们最后的函数test，test是一 个不具备闭包的函数，它的__closure__属性是None），这个属性是一个元组。 元组里面的对象为cell对象，而访问cell对象的cell_contents属性则可以得到闭包变量的当前值 （即上一次调用之后的值）。 而随着闭包的继续调用，变量会再次更新。 所以可见，一旦形成闭包之后，python确实会将__closure__和闭包函数绑定作为储存闭包变量的 场所 123456789101112131415#定义一个包含斜率、截距、X坐标三参数的直线方程函数f(x)=kx+bdef funx(k=3, b=4): def funy(x): y = k * x + b print(y) return funyline = funx(5,3)line(1)line(2)Output:8131823 闭包的好处 闭包不是必须的 没了闭包，python的功能一点都不会被影响 有了闭包，只是给你一种额外的解决方法 1234567891011121314151617181920212223242526#实现统计函数运行时间import timedef cost(func): def _cost(*args,**kwargs): start = time.time() ret = func(*args,**kwargs) cost = time.time() - start print(f\"&#123;func.__name__&#125;函数花费&#123;cost&#125;秒\") return ret return _cost@costdef line(x,k=1,b=-4): time.sleep(1) return k*x+b@costdef add(a,b): time.sleep(1) return a+bprint(add(1,2))print(line(2))Output:add函数花费1.000878095626831秒3line函数花费1.0009534358978271秒-2 什么是装饰器？ 装饰器是这样一种设计模式：如果一个类（函数）希望添加其他类（函数）的一些功能，而不希望 通过继承或是直接修改源代码实现，那么可以使用装饰器模式 简单来说Python中的装饰器就是指某些函数或其他可调用对象，以函数或类作为可选输入参数， 然后返回函数或类的形式。通过这个在Python2.6版本中被新加入的特性可以用来实现装饰器设计 模式。 装饰器就是一个可以接受调用也可以返回调用的函数，该函数接受被装饰的函数作为其位置参数。 装饰器通过使用该参数来执行某些操作，然后返回原始参数或一些其他的调用 函数也是对象，也可以当做参数传递 装饰器有什么用？ 你可以考虑在装饰器中置入通用功能的代码来降低程序复杂度 引入日志 增加计时逻辑来检测性能 给函数加入事务的能力 权限控制 123456789101112131415161718192021222324252627282930# 用装饰器实现权限控制# 定义一个全局变量：username，定义add函数，实现两个数相加# 实现login_required装饰器，如果username值为root，提示\"欢迎\"并计算结果，否则\"没有权限\"username = input(\"请输入你的用户名\")def login_required(func): def dec(*args,**kwargs): if username == \"root\": print(\"欢迎\") ret = func(*args,**kwargs) return ret else: raise PermissionError(\"没有权限\") return dec@login_requireddef add(a,b): return a+bprint(add(1,2))Output(true):请输入你的用户名root欢迎3Output(false):请输入你的用户名123Traceback (most recent call last): File \"E:/python/python study/python高阶/闭包与装饰器/闭包.py\", line 173, in &lt;module&gt; print(add(1,2)) File \"E:/python/python study/python高阶/闭包与装饰器/闭包.py\", line 168, in dec raise PermissionError(\"没有权限\")PermissionError: 没有权限 编写和使用装饰器 123456789101112131415161718# 应用多个装饰器# 定义两个装饰器(log, cost)# 定义一个函数(add)，将两个装饰器应用到该函数import timedef log(func): def _log(*args,**kwargs): now = time.strftime(\"%Y-%m-%d %X\",time.localtime()) ret = func(*args,**kwargs) print(f\"在&#123;now&#125;执行了&#123;func.__name__&#125;函数\") return ret return _log@logdef add(a,b): return a + bprint(add(1,10))Output:在2019-07-10 20:42:23执行了add函数11 1234567891011121314151617#上一题的另一种方法（通过调用logging模块）import loggingimport timedef log(func): logging.basicConfig(format='%(asctime)s:%(name)s:%(message)s',level=logging.DEBUG) def _log(*args,**kwargs): ret = func(*args,**kwargs) logging.info(f\"执行了&#123;func.__name__&#125;函数\") return ret return _log@logdef add(a,b): return a+bprint(add(1,6))Output:72019-07-10 20:52:28,752:root:执行了add函数 多个装饰器装饰类 调用是自上而下 封装是自下而上 在实际应用的场景中，当我们采用上面的方式写了两个装饰方法比如先验证有没有登录 @login_required ， 再验证权限够不够时 @permision_allowed 什么是元数据？ 元数据（Metadata），又称中介数据、中继数据，为描述数据的数据（data about data），主要是 描述数据属性（property）的信息 函数的重要的元信息比如名字、文档字符串、注解和参数签名等 装饰器后，为什么元数据会丢失？ 因为return执行的，是经过调用封装后的函数 保留元数据 利用@functools.wraps(fun)，将一个函数的重要内容复制到另一个函数 提醒：任何时候你定义装饰器的时候,都应该使用 functools 库中的 @wraps 装饰器来注解底层 包装函数。（需要import functolls） 用类实现装饰器 1234567891011121314151617181920212223242526#定义一个类logging实现记录日志的装饰器#装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了__call__()方法，那么这个对象就是callable的。class log(object): def __init__(self,func): print(\"封装log功能\") self.func = func def __call__(self, *args, **kwargs): print(\"记一条日志~~\") ret = self.func(*args,**kwargs) return ret@logdef add(a,b): return a+bprint(add(1,3))print(add(1,3))print(add(1,3))Output:封装log功能记一条日志~~4记一条日志~~4记一条日志~~4 用类实现装饰器(带参数) 123456789101112131415161718192021222324252627#定义一个类logging实现记录日志的装饰器（带参数同时保留了元数据）import functoolsclass log2(object): def __init__(self,level=\"DEBUG\"): self.level = level def __call__(self,func): @functools.wraps(func) def _dec(*args,**kwargs): print(f\"[&#123;self.level&#125;]记一条日志\") return func(*args,**kwargs) return _dec@log2(level=\"INFO\")def add(a,b): return a+bprint(add(1,3))print(add(1,3))print(add(1,3))Output:[INFO]记一条日志4[INFO]记一条日志4[INFO]记一条日志4 1234567891011121314151617181920212223242526272829303132333435#定义一个装饰器sorted_by_create_time实现装饰类的装饰器#装饰器的功能：按创建时间将实例进行排序import timedef sorted_by_createtime(cls): origin_init = cls.__init__ def new_init(self, *args, **kwargs): self.create_time = time.time() origin_init(self,*args, **kwargs) cls.__init__ = new_init cls.__lt__ = lambda self, other: self.create_time &lt; other.create_time return cls@sorted_by_createtimeclass Sortable(object): def __init__(self, id): self.id = id def __str__(self): return f\"str:&#123;self.id&#125;\" def __repr__(self): return f\"repr:&#123;self.id&#125;\"a = Sortable(1)time.sleep(1)b = Sortable(2)time.sleep(1)c = Sortable(3)li = [c, b, a]print(sorted(li))Output:[repr:3, repr:2, repr:1] 内置的装饰器 Python还提供了类装饰器与@staticmethod，@classmethod，@property和这三个在面向对象编程中常用的装饰器 staticmethod：把类中定义的实例方法变成静态方法 classmethod：把类中定义的实例方法变成类方法 property：把类中定义的实例方法变成类属性。 为什么使用装饰器？ 模块化且清晰明确 代码重用 装饰器是显式的，增强可读性 装饰器的应用：Python标准库中包括很多包含装饰器的模块，并且很多常用工具和框架利用它们实现常功能 要使用一个类上的方法不需要这个类的实例(@classmethod或@staticmethod) mock模块（单元测试python3.3后加入标准库-@mock.patch或@mock.patch.object） Django(@login_required, @permission_reqired) Flask(@app.route) 充当url与函数之间的注册表 Celery(@task) 返回Task类实例 插入日志、性能测试、事务处理、缓存、权限校验等场景 记录结果、增加计时逻辑来检测性能等 小练习 实现函数注册表：所有被装饰的函数都放到registry列表中 12345678910111213141516register = []def register1(func): def _dec(*args,**kwargs): register.append(func.__name__) ret = func(*args,**kwargs) print(register) return ret return _dec@register1def add(a,b): return a+bprint(add(1,8))Output:['add']9 将被装饰函数的结果转json格式：默认返回列表/字典格式 12345678910111213141516import jsondef json1(func): def _dec(*args,**kwargs): ret = func(*args,**kwargs) r = json.dumps(ret) print(type(r)) return r return _dec@json1def add(a,b): return a+bprint(add(1,8))Output：&lt;class 'str'&gt;9 一个简单的日志管理功能：记录所有函数名，执行时间，执行耗时等 12345678910111213141516171819import timedef log(func): def _log(*args,**kwargs): start = time.strftime('%Y-%m-%d %H:%M:%S',time.localtime()) start_now = time.time() ret = func(*args,**kwargs) cost = time.time() - start_now print(f\"&#123;start&#125;执行&#123;func.__name__&#125;函数,执行耗时：&#123;cost&#125;\\n执行结果：&#123;json.dumps(ret)&#125;\") return json.dumps(ret) return _log@logdef add(a,b): time.sleep(1) return a+badd(1,7)Output:2019-07-11 20:46:29执行add函数,执行耗时：1.000678539276123执行结果：8 补充知识（模块）time模块 time模块中时间表现的格式主要有三种： timestamp时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量 struct_time时间元组，共有九个元素组。 format time 格式化时间，已格式化的结构使时间更具可读性。包括自定义格式和固定格式。 主要time生成方法和time格式转换方法实例： 123456789101112131415161718192021222324252627282930313233import time# 生成timestamptime.time()# 1477471508.05#struct_time to timestamptime.mktime(time.localtime())#生成struct_time# timestamp to struct_time 本地时间time.localtime()time.localtime(time.time())# time.struct_time(tm_year=2016, tm_mon=10, tm_mday=26, tm_hour=16, tm_min=45, tm_sec=8, tm_wday=2, tm_yday=300, tm_isdst=0)# timestamp to struct_time 格林威治时间time.gmtime()time.gmtime(time.time())# time.struct_time(tm_year=2016, tm_mon=10, tm_mday=26, tm_hour=8, tm_min=45, tm_sec=8, tm_wday=2, tm_yday=300, tm_isdst=0)#format_time to struct_timetime.strptime('2011-05-05 16:37:06', '%Y-%m-%d %X')# time.struct_time(tm_year=2011, tm_mon=5, tm_mday=5, tm_hour=16, tm_min=37, tm_sec=6, tm_wday=3, tm_yday=125, tm_isdst=-1)#生成format_time#struct_time to format_timetime.strftime(\"%Y-%m-%d %X\")time.strftime(\"%Y-%m-%d %X\",time.localtime())# 2016-10-26 16:48:41#生成固定格式的时间表示格式time.asctime(time.localtime())time.ctime(time.time())# Wed Oct 26 16:45:08 2016 struct_time元组元素结构 属性 值 tm_year（年） 比如2011 tm_mon（月） 1 - 12 tm_mday（日） 1 - 31 tm_hour（时） 0 - 23 tm_min（分） 0 - 59 tm_sec（秒） 0 - 61 tm_wday（weekday） 0 - 6（0表示周日） tm_yday（一年中的第几天） 1 - 366 tm_isdst（是否是夏令时） 默认为-1 format time结构化表示 格式 含义 %a 本地（locale）简化星期名称 %A 本地完整星期名称 %b 本地简化月份名称 %B 本地完整月份名称 %c 本地相应的日期和时间表示 %d 一个月中的第几天（01 - 31） %H 一天中的第几个小时（24小时制，00 - 23） %I 第几个小时（12小时制，01 - 12） %j 一年中的第几天（001 - 366） %m 月份（01 - 12） %M 分钟数（00 - 59） %p 本地am或者pm的相应符 %S 秒（01 - 61） %U 一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。 %w 一个星期中的第几天（0 - 6，0是星期天） %W 和%U基本相同，不同的是%W以星期一为一个星期的开始。 %x 本地相应日期 %X 本地相应时间 %y 去掉世纪的年份（00 - 99） %Y 完整的年份 %Z 时区的名字（如果不存在为空字符） %% %字符 常见结构化时间组合： 12print time.strftime(\"%Y-%m-%d %X\")#2016-10-26 20:50:13 time加减 1234567#timestamp加减单位以秒为单位import timet1 = time.time()t2=t1+10print time.ctime(t1)#Wed Oct 26 21:15:30 2016print time.ctime(t2)#Wed Oct 26 21:15:40 2016 datetime模块：datatime模块重新封装了time模块，提供更多接口，提供的类有：date,time,datetime,timedelta,tzinfo。 date类 datetime.date(year, month, day) 静态方法和字段 date.max、date.min：date对象所能表示的最大、最小日期； date.resolution：date对象表示日期的最小单位。这里是天。 date.today()：返回一个表示当前本地日期的date对象； date.fromtimestamp(timestamp)：根据给定的时间戮，返回一个date对象； 12345678910111213from datetime import *import timeprint 'date.max:', date.maxprint 'date.min:', date.minprint 'date.today():', date.today()print 'date.fromtimestamp():', date.fromtimestamp(time.time())#Output======================# date.max: 9999-12-31# date.min: 0001-01-01# date.today(): 2016-10-26# date.fromtimestamp(): 2016-10-26 方法和属性 d1 = date(2011,06,03)#date对象 d1.year、date.month、date.day：年、月、日； d1.replace(year, month, day)：生成一个新的日期对象，用参数指定的年，月，日代替原有对象中的属性。（原有对象仍保持不变） d1.timetuple()：返回日期对应的time.struct_time对象； d1.weekday()：返回weekday，如果是星期一，返回0；如果是星期2，返回1，以此类推； d1.isoweekday()：返回weekday，如果是星期一，返回1；如果是星期2，返回2，以此类推； d1.isocalendar()：返回格式如(year，month，day)的元组； d1.isoformat()：返回格式如’YYYY-MM-DD’的字符串； d1.strftime(fmt)：和time模块format相同。 1234567891011121314151617181920from datetime import *now = date(2016, 10, 26)tomorrow = now.replace(day = 27)print 'now:', now, ', tomorrow:', tomorrowprint 'timetuple():', now.timetuple()print 'weekday():', now.weekday()print 'isoweekday():', now.isoweekday()print 'isocalendar():', now.isocalendar()print 'isoformat():', now.isoformat()print 'strftime():', now.strftime(\"%Y-%m-%d\")#Output========================# now: 2016-10-26 , tomorrow: 2016-10-27# timetuple(): time.struct_time(tm_year=2016, tm_mon=10, tm_mday=26, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=2, tm_yday=300, tm_isdst=-1)# weekday(): 2# isoweekday(): 3# isocalendar(): (2016, 43, 3)# isoformat(): 2016-10-26# strftime(): 2016-10-26 time类 datetime.time(hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ) 静态方法和字段 time.min、time.max：time类所能表示的最小、最大时间。其中，time.min = time(0, 0, 0, 0)， time.max = time(23, 59, 59, 999999)； time.resolution：时间的最小单位，这里是1微秒； 方法和属性 t1 = datetime.time(10,23,15)#time对象 t1.hour、t1.minute、t1.second、t1.microsecond：时、分、秒、微秒； t1.tzinfo：时区信息； t1.replace([ hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] )：创建一个新的时间对象，用参数指定的时、分、秒、微秒代替原有对象中的属性（原有对象仍保持不变）； t1.isoformat()：返回型如”HH:MM:SS”格式的字符串表示； t1.strftime(fmt)：同time模块中的format； 12345678910111213141516from datetime import *tm = time(23, 46, 10)print 'tm:', tmprint 'hour: %d, minute: %d, second: %d, microsecond: %d' % (tm.hour, tm.minute, tm.second, tm.microsecond)tm1 = tm.replace(hour=20)print 'tm1:', tm1print 'isoformat():', tm.isoformat()print 'strftime()', tm.strftime(\"%X\")#Output==============================================# tm: 23:46:10# hour: 23, minute: 46, second: 10, microsecond: 0# tm1: 20:46:10# isoformat(): 23:46:10# strftime() 23:46:10 datetime类 datetime相当于date和time结合起来。datetime.datetime (year, month, day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ) 静态方法和字段 datetime.today()：返回一个表示当前本地时间的datetime对象； datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间； datetime.utcnow()：返回一个当前utc时间的datetime对象；#格林威治时间 datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息； datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象； datetime.combine(date, time)：根据date和time，创建一个datetime对象； datetime.strptime(date_string, format)：将格式字符串转换为datetime对象； 123456789101112131415161718192021from datetime import *import timeprint 'datetime.max:', datetime.maxprint 'datetime.min:', datetime.minprint 'datetime.resolution:', datetime.resolutionprint 'today():', datetime.today()print 'now():', datetime.now()print 'utcnow():', datetime.utcnow()print 'fromtimestamp(tmstmp):', datetime.fromtimestamp(time.time())print 'utcfromtimestamp(tmstmp):', datetime.utcfromtimestamp(time.time())#output======================# datetime.max: 9999-12-31 23:59:59.999999# datetime.min: 0001-01-01 00:00:00# datetime.resolution: 0:00:00.000001# today(): 2016-10-26 23:12:51.307000# now(): 2016-10-26 23:12:51.307000# utcnow(): 2016-10-26 15:12:51.307000# fromtimestamp(tmstmp): 2016-10-26 23:12:51.307000# utcfromtimestamp(tmstmp): 2016-10-26 15:12:51.307000 方法和属性 12345678910111213dt=datetime.now()#datetime对象dt.year、month、day、hour、minute、second、microsecond、tzinfo：dt.date()：获取date对象；dt.time()：获取time对象；dt. replace ([ year[ , month[ , day[ , hour[ , minute[ , second[ , microsecond[ , tzinfo] ] ] ] ] ] ] ])：dt. timetuple ()dt. utctimetuple ()dt. toordinal ()dt. weekday ()dt. isocalendar ()dt. isoformat ([ sep] )dt. ctime ()：返回一个日期时间的C格式字符串，等效于time.ctime(time.mktime(dt.timetuple()))；dt. strftime (format) 参考资料:https://www.cnblogs.com/tkqasn/p/6001134.html","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"}],"tags":[{"name":"logging模块","slug":"logging模块","permalink":"https://chenxl18.github.io/tags/logging模块/"},{"name":"闭包与装饰器","slug":"闭包与装饰器","permalink":"https://chenxl18.github.io/tags/闭包与装饰器/"},{"name":"time模块","slug":"time模块","permalink":"https://chenxl18.github.io/tags/time模块/"},{"name":"datetime模块","slug":"datetime模块","permalink":"https://chenxl18.github.io/tags/datetime模块/"}]},{"title":"python笔试面试题","slug":"python/python笔试面试题","date":"2019-07-09T01:33:46.000Z","updated":"2019-07-12T08:06:21.479Z","comments":true,"path":"2019/07/09/python/python笔试面试题/","link":"","permalink":"https://chenxl18.github.io/2019/07/09/python/python笔试面试题/","excerpt":"","text":"python面试笔试题 1.metaclass作用？以及引用场景？ metaclass是元类，创建类的类 foo=&gt;阻止 FOO=&gt;foo 定制创建类的过程=&gt;添加一些自定义的逻辑 默认元类是type 2.魔法方法__call__怎么使用？ 12345class A(): passa = A()a(1,2,3) =&gt;调用a =&gt; a.__call__(self,*args,**kwargs)#如果没有__call__()会报错，不可调用 3.staticmethod、classmethod、property用法及功能? 装饰器：@名称 staticmethod：把类的一个方法封装成静态方法（） classmethod：把类的一个方法封装成类态方法（cls） property：把类的一个方法封装属性 4.__new__和__init__方法？ __init__：初始化实例=&gt;实例方法 __new__：创建并返回一个实例=&gt;必须与自己类相同类型的一个实例 5.python经典类与新式类的继承顺序？ 新式类：python3或由内置类型派生出来的类。 C3算法，A.mro() =&gt;方法解析顺序 1234class A(object): passclass B(A): pass 经典类：不是由内置类型派生出来的类（Python2） 深度优先方式 1234class A(): passclass B(A)： pass 注：广度优先：子节点顺序：从左到右 ​ 深度优先：子节点顺序：从左到右 6.面向对象中的一些特殊方法有哪些？如__call __str__：友好显示实例信息 1&lt;__main__.A object at 0x00000244EC33F940&gt; __eq__：判读两个对象是否相等,== __add__：两个对象相加,+ 12(self, other)a + b=&gt;a.__add__(b)=&gt;A.__add__(a,b) 7.python类中的self的具体含义是？ self代表类的实例，而非类。 self不必非写成self，但最好还是用self self总是指调用时的类的实例 在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。 8.写一个类，并让它尽可能多的支持操作符（+ - * / //% ** == &gt; &lt;） 123456789101112+:__add__-:__sub__*:__mul__/:__truediv__ 1/2 = 0.5(python3) 1/2 = 0(python2) 1.0/2 = 0.5(python2)//:__floordiv__ 1//2 = 0(python3)%:__mod__**:__pow__==:__eq__&gt;:__gt__&lt;:__lt__&gt;=:__ge__&lt;=:__le__ 9.类属性与实例属性是什么？区别和应用场景？ 类属性：写在类下面（不是方法中） 所有的实例共享类属性 实例属性：写在方法中（__init__） 每个实例拥有自己的实例属性 对象有类属性又有实例属性：先访问实例属性 10.什么情况下需要重载类的方法？ __init__没有参数，初始化对象要传参数 参数变化的时候 功能有变化 11.如何判断一个对象是函数还是方法？函数与方法的区别 type 和类绑定的是方法，和类没有绑定关系的就是函数 1234567891011121314151617181920212223242526272829303132In [1]: def fun():passIn [2]: type(fun)Out[2]: functionIn [4]: class A(object): ...: def a(self):pass ...: @staticmethod ...: def b():pass ...: @classmethod ...: def c(cls):pass ...:In [5]: type(A.a)Out[5]: functionIn [6]: type(A.b)Out[6]: functionIn [7]: type(A.c)Out[7]: methodIn [8]: a = A()In [9]: type(a.a)Out[9]: methodIn [10]: type(a.b)Out[10]: functionIn [11]: type(a.c)Out[11]: method 12.了解Documentation String吗？ py的最开始&quot;&quot;&quot;&quot;&quot;&quot; 函数、类、方法 注释 代码即文档 13.了解函数类型注解？ 类型的形式指定函数的参数类型 用 -&gt; 类型 的形式指定函数的返回值类型。Python 解释器并不会因为这些注解而提供额外的校验，没有任何的类型检查工作。也就是说，这些类型注解加不加，对你的代码来说没有任何影响。 14.是否可以在一句import中导入多个库？ 推荐使用 12import osimport sys 15.在给python模块命令的时候需要注意什么？ 不要跟内置的模块重名 不能以数字开头 字母和下划线 16.怎么规范代码？ PEP8 google python style 工具：PEP8，flake8,pycharm 17.python中的注释有几种？ #，注释单独写一行 &quot;&quot;&quot; &quot;&quot;&quot;函数写注释（多行注释） 18.请简述对python闭包和装饰器的理解 是一种设计模式 如果一个类（函数）希望添加其他类（函数）的一些功能，而不希望 通过继承或是直接修改源代码实现，那么可以使用装饰器模式。 19.装饰器可以干什么？有什么优缺点？ 模块化且清晰明确 代码重用 装饰器是显式的，增强可读性 缺点：不太容易理解 20.POST和GET的区别 POST的参数在http请求体中，GET的参数显示在地址栏 POST可以传很大的参数，GET长度2048 GET幂等操作-&gt;查询 POST插入数据-&gt; 参考资料 【1】https://www.python.org/dev/peps/pep-3107/","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"}],"tags":[{"name":"python面试笔试题","slug":"python面试笔试题","permalink":"https://chenxl18.github.io/tags/python面试笔试题/"}]},{"title":"shell种类及bash的产生","slug":"linux/shell种类及bash的产生","date":"2019-07-05T11:20:11.000Z","updated":"2019-07-24T10:38:30.655Z","comments":true,"path":"2019/07/05/linux/shell种类及bash的产生/","link":"","permalink":"https://chenxl18.github.io/2019/07/05/linux/shell种类及bash的产生/","excerpt":"","text":"shell脚本的基本组成 声明和注释（注释以#开头） 1#! /bin/bash #是声明这个脚本是使用bash来执行的 系统命令 文本处理工具（grep、cut、sed、awk） 各种变量 各种条件判断 循环结构语句 各种函数 shell的作用：命令解释器，介于系统内核与用户之间，负责解释命令行 用户进程和系统进程 用户进程：用来实现具体的某个功能应用的程序，为用户提供服务的程序。mysq1、lkdir等 系统进程：其实就是操作系统本身内部的代码运行的进程。 0.0%us：用户进程所消耗的cpu资源 0.3%sy：系统进程所消耗的cpu资源 10.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st 用户态：一般都是普通的应用程序的状态 内核态：就是操作系统内核代码运行的程序的状态 编译型语言：编写-编译-链接-运行（edit-complie-link-run） C\\C++、Ada、Java、C# 脚本语言：解释器读入脚本程序代码，将其装换成内部的形式，解释器本身则是编译型程序 Shell脚本编程的优势 语法和结构通常比较简单 学习和使用通常比较简单 通常以容易修改程序的“解释”作为运行方式，而不要“编译” 登录Shell：指用户每次登录系统后自动加载的Shell程序，大多数Linux系统采用/bin/bash作为默认登录Shell /etc/shells 文件记录了系统支持的有效登录Shell 1234567[root@chenxl ~]# cat /etc/shells/bin/sh/bin/bash/sbin/nologin/usr/bin/sh/usr/bin/bash/usr/sbin/nologin 如何切换Shell环境 临时切换：直接执行其他shell程序 返回到原来的shell环境时可以执行“exit”命令或者按ctrl+D快捷键 更换用户登录Shell： 需要修改/etc/passwd文件中用户记录的最后一个字段 或执行：usermod -s Shell程序路径 用户名 bash初始化：用户登录后到linux系统里，linux系统就会启动一个进程叫bash，然后我们在bash里输入命令，让bash帮我们去查找并执行 直接登录 远程登录：xshell软件、secureCRT bash初始化：启动bash这个程序的时候，需要去执行一些操作，加载某些参数或者函数 w命令 show who is logged on and what they are doing. 123456[root@chenxl ~]# w 20:12:22 up 2:49, 3 users, load average: 0.15, 0.05, 0.06USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 256月19 25:18 0.11s 0.11s -bashroot pts/0 192.168.0.48 276月19 8days 0.01s 0.01s -bashroot pts/1 192.168.0.58 19:48 6.00s 0.04s 0.00s w ps aux静态的查看进程 pstree 查看进程树 top命令 动态的查看进程的信息每隔2秒刷新一次 大写的P：根据cpu的使用率来排序 processor 大写M：根据内存的使用率来排序 memory 按q：退出quit shift+&gt;：下一页的进程信息 shift+&lt;：上一页的进程信息 Shell启动配置文件的区别 /etc/profile：配置全局环境变量，影响所有用户 ~/.bash_profile：配置个人环境，影响一个用户 /etc/bashrc：配置全局的别名或者shell选项，影响所有用户 ~/.bashrc：配置个人别名或者shell选项，影响一个用户 在用户家目录下，每个目录都有的配置文件，只对单独的用户有效。 .bash_profile:用户每次登录时执行—&gt;.bashrc .bashrc：每次进入新的Bash环境时执行（打开终端），定义别名，—&gt;/etc/bashrc .bash_logout：用户每次退出登录时执行 .bash_history：保存上次用户注销前使用的命令 环境变量：全局变量，所有人都可以使用的变量 命令历史 保存用户曾经执行过的命令操作 存放位置：~/.bash_history文件 history:查看历史命令 使用上下箭头按键逐条翻看，允许编辑并重复执行 清除历史命令：history -c(只是将加载到内存的历史命令清除) 最有效的全部清除（磁盘里的历史记录也一起清空） 先rm -rf ~/.bash_history 在history -c exit 调用历史命令 !n：执行历史记录中的的第n条命令 !str：执行历史记录中最近以”str”开头的命令 设置记录历史命令的条数 修改HISTSIZE参数（默认为1000条） alias:Bash的命令别名 命令别名：为使用频率较高的复杂命令行设置简短的调用名称 存放位置：~/.bashrc 查看命令别名：格式：alias [别名] 设置命令别名alias 别名=&#39;实际执行的命令&#39; 取消已设置的命令别名：unalias 别名或者unalias -a","categories":[{"name":"linux","slug":"linux","permalink":"https://chenxl18.github.io/categories/linux/"},{"name":"shell脚本","slug":"linux/shell脚本","permalink":"https://chenxl18.github.io/categories/linux/shell脚本/"}],"tags":[{"name":"shell种类","slug":"shell种类","permalink":"https://chenxl18.github.io/tags/shell种类/"},{"name":"bash的产生","slug":"bash的产生","permalink":"https://chenxl18.github.io/tags/bash的产生/"},{"name":"w命令","slug":"w命令","permalink":"https://chenxl18.github.io/tags/w命令/"}]},{"title":"函数式编程练习题","slug":"python/函数式编程练习题","date":"2019-07-04T12:40:56.000Z","updated":"2019-07-04T13:07:22.783Z","comments":true,"path":"2019/07/04/python/函数式编程练习题/","link":"","permalink":"https://chenxl18.github.io/2019/07/04/python/函数式编程练习题/","excerpt":"","text":"1234567891011121314151617181920\"\"\"@file:homework.py@date:2019/07/04\"\"\"# list1 = [7,-8,5,4,0,-2,-5]# 正数在前负数在后# 整数从小到大# 负数从大到小list1 = [7, -8, 5, 4, 0, -2, -5]def sort1(x): if x &lt; 0: return x ** 4 else: return xret = sorted(list1, key=sort1)print(ret) 12345678910111213141516171819202122# 这是一个字符串排序，排序规则：小写&lt;大写&lt;奇数&lt;偶数# s='asdf234GDSdsf23'# 排序：小写-大写-奇数-偶数# 原理：先比较元组的第一个值，FALSEimport strings = 'asdf234GDSdsf23'def sort2(x): if x.isdigit(): if int(x) % 1 == 1: return ord(x) + 100 else: return ord(x) + 1000 elif x.islower(): return ord(x) - 100 else: return ord(x)print(\"\".join(sorted(s, key=sort2))) 通过上面的题目 我又了解到python中sorted()方法和列表的sort方法使用详解 sorted基本用法 列表有自己的sort方法，其对列表进行原址排序，既然是原址排序，那显然元组不可能拥有这种方法，因为元组是不可修改的。 排序，数字、字符串按照ASCII，中文按照unicode从小到大排序 123x = [4, 6, 2, 1, 7, 9]x.sort()print (x) # [1, 2, 4, 6, 7, 9] 如果需要一个排序好的副本，同时保持原有列表不变，怎么实现呢？ 12345x = [4, 6, 2, 1, 7, 9]y = x[:]y.sort()print(y) # [1, 2, 4, 6, 7, 9]print(x) # [4, 6, 2, 1, 7, 9] 注意：y = x[:] 通过分片操作将列表x的元素全部拷贝给y，如果简单的把x赋值给y：y = x，y和x还是指向同一个列表，并没有产生新的副本。 另一种获取已排序的列表副本的方法是使用sorted函数： 1234x =[4, 6, 2, 1, 7, 9]y = sorted(x)print (y) #[1, 2, 4, 6, 7, 9]print (x) #[4, 6, 2, 1, 7, 9] sorted返回一个有序的副本，并且类型总是列表，如下： 1print (sorted('Python')) #['P', 'h', 'n', 'o', 't', 'y'] 可选参数 sort方法还有两个可选参数：key和reverse 1、key在使用时必须提供一个排序过程总调用的函数： 123x = ['mmm', 'mm', 'mm', 'm' ]x.sort(key = len)print (x) # ['m', 'mm', 'mm', 'mmm'] 2、reverse实现降序排序，需要提供一个布尔值： 123y = [3, 2, 8 ,0 , 1]y.sort(reverse = True)print (y) #[8, 3, 2, 1, 0] True为倒序排列，False为正序排列 sort和sorted的不同 有无返回值 list.sort() ：对原列表进行排序，无返回值 sorted(list)：有返回值 是否影响本身结构 sorted(list) ：不影响本身结构 sorted(list,reverse = True)：不影响本身结构 list.sort()：影响本身结构 list.sort(reverse = True)：影响本身结构 拓展文档https://www.cnblogs.com/huchong/p/8296025.html","categories":[{"name":"python高阶","slug":"python高阶","permalink":"https://chenxl18.github.io/categories/python高阶/"},{"name":"函数式编程","slug":"python高阶/函数式编程","permalink":"https://chenxl18.github.io/categories/python高阶/函数式编程/"}],"tags":[{"name":"函数式编程","slug":"函数式编程","permalink":"https://chenxl18.github.io/tags/函数式编程/"},{"name":"练习题","slug":"练习题","permalink":"https://chenxl18.github.io/tags/练习题/"}]},{"title":"OOP","slug":"python/面向对象编程","date":"2019-07-04T01:51:40.000Z","updated":"2019-07-08T01:39:15.818Z","comments":true,"path":"2019/07/04/python/面向对象编程/","link":"","permalink":"https://chenxl18.github.io/2019/07/04/python/面向对象编程/","excerpt":"","text":"面向对象编程（OOP）","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"面向对象编程","slug":"python/面向对象编程","permalink":"https://chenxl18.github.io/categories/python/面向对象编程/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://chenxl18.github.io/tags/OOP/"},{"name":"面向对象","slug":"面向对象","permalink":"https://chenxl18.github.io/tags/面向对象/"},{"name":"类","slug":"类","permalink":"https://chenxl18.github.io/tags/类/"}]},{"title":"日志","slug":"linux/日志","date":"2019-07-03T07:11:54.000Z","updated":"2019-07-03T09:21:28.735Z","comments":true,"path":"2019/07/03/linux/日志/","link":"","permalink":"https://chenxl18.github.io/2019/07/03/linux/日志/","excerpt":"","text":"日志（log）： 1.什么是日志？ 其实就是我们的linux系统或者某个应用程序，将发生的事情记录下来的文本信息就是日志—》log 2.有什么作用？ 用于记录系统、程序运行中发生的各种事件 通过阅读日志，有助于诊断和解决系统故障 大数据：比较重要的日志 web服务器 —&gt;nginx—&gt; ssh服务器 – 》/var/log/secure 数据库服务器 12345[root@localhost log]# yum install epel-release -y[root@localhost log]# yum install nginx -y #安装nginx[root@localhost log]# service nginx restartRedirecting to /bin/systemctl restart nginx.service[root@localhost log]# 如何知道nginx服务是否起来？ 1.查看进程 123456[root@localhost log]# ps aux|grep nginxroot 5769 0.0 0.2 125096 2112 ? Ss 14:58 0:00 nginx: master process /usr/sbin/nginxnginx 5770 0.0 0.3 125484 3148 ? S 14:58 0:00 nginx: worker processroot 5772 0.0 0.0 112724 984 pts/2 S+ 14:58 0:00 grep --color=auto nginx[root@localhost log]# man psps - report a snapshot of the current processes. ps -ef 和ps aux的区别？ 答案：2个命令都是查看进程，只是显示的字段不一样。 ps -ef 主要是用来看看ppid号 2.查看端口 查看某个端口 1234567[root@localhost log]# yum install lsof -y[root@localhost log]# lsof -i:80COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 5769 root 6u IPv4 84832 0t0 TCP *:http (LISTEN)nginx 5769 root 7u IPv6 84833 0t0 TCP *:http (LISTEN)nginx 5770 nginx 6u IPv4 84832 0t0 TCP *:http (LISTEN)nginx 5770 nginx 7u IPv6 84833 0t0 TCP *:http (LISTEN) 查看所有端口号的进程 123456[root@localhost yum.repos.d]# yum provides netstat#先查看这个命令来自哪个包[root@localhost yum.repos.d]# yum install net-tools -y[root@localhost yum.repos.d]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 5769/nginx: master 访问nginx服务的前期准备 1234[root@localhost yum.repos.d]# service firewalld stop #停止firewalld服务Redirecting to /bin/systemctl stop firewalld.service[root@localhost yum.repos.d]# iptables -F #清除防火墙规则firewalld底层使用的是iptable工具 通过浏览器去访问你的nginx服务 12345678910111213[root@localhost yum.repos.d]# ip add1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether 00:0c:29:2d:ef:f1 brd ff:ff:ff:ff:ff:ff inet 192.168.0.101/24 brd 192.168.0.255 scope global noprefixroute dynamic ens33 valid_lft 6959sec preferred_lft 6959sec inet6 fe80::20c:29ff:fe2d:eff1/64 scope link valid_lft forever preferred_lft forever 12345678[root@localhost nginx]# pwd/var/log/nginx[root@localhost nginx]# lsaccess.log 记录正常的访问error.log 记录异常的访问[root@localhost nginx]#[root@localhost nginx]# cat access.log 192.168.0.100 - - [30/Jun/2019:15:24:49 +0800] \"GET / HTTP/1.1\" 200 3700 \"-\" \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36\" \"-\" 知识： 日志级别 设备类型 常见的日志文件有哪些？ 日志的作用 用于记录系统、程序运行中发生的各种事件 通过阅读日志，有助于诊断和解决系统故障 日志文件的分类 内核及系统日志 由系统服务rsyslogd统一进行管理，日志格式基本相似 用户日志 记录系统用户登录及退出系统的相关信息 程序日志 由各种应用程序独立管理的日志文件，记录格式不统一 日志承包商—》rsyslogd —&gt;专供系统使用，也可以帮助用户进程记录日志 123[root@localhost nginx]# ps aux|grep rsyslogdroot 988 0.0 0.4 220776 4656 ? Ssl 08:02 0:05 /usr/sbin/rsyslogd -nroot 6311 0.0 0.0 112728 984 pts/2 S+ 15:58 0:00 grep --color=auto syslog 截取登陆失败的ip地址（安全问题） 123456[root@localhost cron]# cat /var/log/secure|grep \"Failed\"Jun 30 16:06:54 localhost sshd[6445]: Failed password for root from 192.168.0.101 port 60200 ssh2Jun 30 16:07:00 localhost sshd[6445]: Failed password for root from 192.168.0.101 port 60200 ssh2[root@localhost cron]# cat /var/log/secure|grep \"Failed\"|awk '&#123;print $11&#125;'192.168.0.101192.168.0.101 日志的格式： 时间、地点、人物（进程）、事件 1234567891011[root@califeng ~]# vim /etc/rsyslog.conf # Log anything (except mail) of level info or higher.# Don't log private authentication messages!*.info;mail.none;authpriv.none;cron.none /var/log/messages# The authpriv file has restricted access.authpriv.* /var/log/secure# Log all the mail messages in one place.mail.* -/var/log/maillog# Log cron stuffcron.* /var/log/cron log level python中日志级别：日志记录级别的数值在下表中给出。如果你想要定义自己的级别，并且需要它们具有相对于预定义级别的特定值。如果你定义具有相同数值的级别，它将覆盖预定义的值；预定义的名称丢失。 级别 数值 CRITICAL 50 ERROR 40 WARNING 30 INFO 20 DEBUG 10 NOTSET 0 Linux中日志消息的级别 0 EMERG（紧急）：会导致主机系统不可用的情况 1 ALERT（警告）：必须马上采取措施解决的问题 2 CRIT（严重）：比较严重的情况 3 ERR（错误）：运行出现错误 —》异常里最多–》程序不能运行 4 WARNING（提醒）：可能会影响系统功能的事件 5 NOTICE（注意）：不会影响系统但值得注意 6 INFO（信息）：一般信息 7 DEBUG（调试）：程序或系统调试信息等 8 none 不记录 设备类型 AUTHPRIV 与认证有关的设备 —》sshd 服务需要登录，登录需要验证 cron 与计划任务相关 mail 与邮件相关 kern 与linux内核相关 local1~7 自定义的设备类型 rsyslogd 记录日志的时候需要确定3个东西： 1.设备类型 2.消息级别 3.记录到哪里 sshd进程—》rsyslog 1.authpriv 2.INFO 解释 123456789101112131415cron.* /var/log/croncron.info /var/log/croncron这种类型的info以上级别的日志都记录到/var/log/cron文件设备类别[连接符]日志级别 . ：记录大于等于后面的级别日志 .=：只记录等于后面的级别日志.!=：只记录不等于后面的级别日志# The authpriv file has restricted access.authpriv.* /var/log/secure记录authpriv这种设备类型所有级别的日志到/var/log/secure* 代表所有的日志级别*.info;mail.none;authpriv.none;cron.none /var/log/messages所有的设备类型的info以上消息级别都记录到/var/log/messages,但是mail、authpriv、cron设备类型的不记录/var/log/messages 会记录几乎常见的日志信息，特别是你不知道到某个程序到哪里去看日志的时候，可以到此一游，看看有没有日志信息 12345#Logging#SyslogFacility AUTHSyslogFacility AUTHPRIV#LogLevel INFO 记录INFO以上级别 1234[root@califeng ~]# vim /etc/rsyslog.conf authpriv.* /var/log/leizhengjie.log #自己修改下[root@califeng ~]# service rsyslog restart #刷新服务Redirecting to /bin/systemctl restart rsyslog.service 看效果 1234567[root@califeng log]# cat leizhengjie.log Jun 30 16:38:51 califeng polkitd[601]: Unregistered Authentication Agent for unix-process:7038:3101537 (system bus name :1.952, object path /org/freedesktop/PolicyKit1/AuthenticationAgent, locale zh_CN.UTF-8) (disconnected from bus)Jun 30 16:39:54 califeng unix_chkpwd[7079]: password check failed for user (root)Jun 30 16:39:54 califeng sshd[7077]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=califeng user=rootJun 30 16:39:54 califeng sshd[7077]: pam_succeed_if(sshd:auth): requirement \"uid &gt;= 1000\" not met by user \"root\"Jun 30 16:39:57 califeng sshd[7077]: Failed password for root from 192.168.0.101 port 60202 ssh2Jun 30 16:41:24 califeng sshd[7077]: Connection closed by 192.168.0.101 port 60202 [preauth] 修改设备类型 1234[root@localhost ~]# vim /etc/ssh/sshd_config SyslogFacility local6[root@localhost ~]# vim /etc/rsyslog.conf local6.* /var/log/dinglang.log 刷新2个服务 123456[root@localhost ~]# service sshd restartRedirecting to /bin/systemctl restart sshd.service[root@localhost ~]# service rsyslog restartRedirecting to /bin/systemctl restart rsyslog.service[root@califeng log]# cat dinglang.log Jun 30 16:45:23 califeng sshd[7226]: Failed password for root from 192.168.0.101 port 60204 ssh2 sshd的日志 /var/log/secure /var/log/messages /var/log/cron nginx的日志 /var/log/nginx 安装mariadb(数据库) 123[root@califeng ~]# yum install mariadb mariadb-server -y #安装[root@califeng ~]# service mariadb start #启动Redirecting to /bin/systemctl start mariadb.service 登陆数据库 12345678910111213[root@califeng ~]# mysql -uroot -p #登录Enter password: #直接回车，没有密码Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 2Server version: 5.5.60-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; MariaDB [(none)]&gt; quit #退出Bye 查看数据库的日志 123456[root@califeng ~]# cd /var/log[root@califeng log]# lsmariadb[root@califeng log]# cd mariadb/[root@califeng mariadb]# lsmariadb.log 修改配置文件 12345678910[root@califeng ~]# vim /etc/my.cnf[mysqld]datadir=/var/lib/mysqlcalifeng i love you #自己随意输入，会导致服务起不来socket=/var/lib/mysql/mysql.sock[root@califeng ~]# tailf /var/log/mariadb/mariadb.log 190630 17:03:50 Percona XtraDB (http://www.percona.com) 5.5.59-MariaDB-38.11 started; log sequence number 1597945190630 17:03:50 [Note] Plugin 'FEEDBACK' is disabled.190630 17:03:50 [ERROR] /usr/libexec/mysqld: unknown option '--califeng i love you'190630 17:03:50 [ERROR] Aborting 系统日志保存位置： 默认位于：/var/log 目录下 主要日志文件介绍 内核及公共消息日志：/var/log/messages 计划任务日志：/var/log/cron 系统引导日志：/var/log/dmesg 邮件系统日志：/var/log/maillog yum.log yum安装过的软件的日志 boot.log linux系统启动时候的日志，哪些服务启动了，哪些没有启动 secure 与安全相关的日志，特别是sshd服务默认的日志文件 日志文件非常重要，需要备份 需要定时备份，所有需要计划任务去执行脚本备份 mariadb 程序启动不了，怎么办？1.百度2.Google3.查看日志 —》第1位4.重启5.selinux 需要关闭","categories":[{"name":"linux","slug":"linux","permalink":"https://chenxl18.github.io/categories/linux/"},{"name":"日志","slug":"linux/日志","permalink":"https://chenxl18.github.io/categories/linux/日志/"}],"tags":[{"name":"shell脚本","slug":"shell脚本","permalink":"https://chenxl18.github.io/tags/shell脚本/"},{"name":"日志","slug":"日志","permalink":"https://chenxl18.github.io/tags/日志/"}]},{"title":"计划任务","slug":"linux/计划任务","date":"2019-06-30T01:24:46.000Z","updated":"2019-07-03T07:12:50.744Z","comments":true,"path":"2019/06/30/linux/计划任务/","link":"","permalink":"https://chenxl18.github.io/2019/06/30/linux/计划任务/","excerpt":"","text":"计划任务： 按时去做某件事情，不需要人手工的去操作。 首先写一个脚本 需求：备份/var/log目录下的所有的日志文件，备份整个目录，每天的3点30和22点都进行备份，备份到/backup目录下，文件名里需要有当天的日志，日期精确到秒。 12345678910111213vim backup_log.sh#!/bin/bash#获得当前的时间，精确到秒ctime=$(date +%F%H%M%S)#建立备份目录mkdir -p /backup#进行备份tar -czf /backup/log_$&#123;ctime&#125;.tar.gz /var/log &amp;&gt;/dev/nullecho \"backup log ok\" 计划任务：计划任务的背后其实是一个程序在每隔一段时间帮我们去查看是否有任务需要执行，如果有就立马执行。 如何查看linux的所有进程 12345ps aux|grep crond #crond进程就是专门盯着计划任务的[root@mysql-2 ~]# ps aux|grep crondroot 5444 0.0 0.0 126284 1628 ? Ss 06:13 0:00 /usr/sbin/crond -nroot 11605 0.0 0.0 112728 984 pts/1 S+ 09:55 0:00 grep --color=auto crond crond这个进程会每隔一分钟去检查用户的计划任务，最短时间间隔为1分钟 如果需要每隔1秒钟做一件事情，建议自己写脚本或者程序来完成 1234567#!/bin/bashwhile :do echo \"$RANDOM\" sleep 1done crond服务：是linux系统自带的不需要安装，而且开机自动运行。不要kim这个进程，不然linux系统的计划任务都不会运行。 服务： 干什么用的？ 需要安装哪些软件 配置文件在哪里 配置文件：作用其实就往程序传递参数，指导程序安装人的意思去运行，从而达到我们想要的效果。 去改配置文件 调试 看效果 排错–》日志 计划任务 1234567891011121314151617[root@localhost ~]# vim /etc/crontab SHELL=/bin/bash #计划任务使用的shell是bashPATH=/sbin:/bin:/usr/sbin:/usr/bin #计划任务执行的时候会到PATH变量的目录下查找命令，如果没有找到就不执行，建议大家在写脚本的时候，使用绝对路径，避免不被执行MAILTO=root #计划任务出问题或者正常的信息给谁发邮件# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed30 3 * * * bash /root/6_30/backup_log.sh# * 表示任意 使用任务计划 1.创建计划任务：编辑一个计划任务 1234567[root@localhost ~]# crontab -e #编辑计划任务30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh[root@localhost ~]# crontab -l #查看计划任务30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh 如何知道计划任务是否执行？ 直接看效果 查看日志 12[root@localhost log]# cat /var/log/cronJun 30 10:55:01 localhost CROND[3253]: (root) CMD (bash /root/6_30/backup_log.sh) 如何删除计划任务？ 编辑计划任务，注释或者dd删除相关行就可以了 1234[root@localhost log]# crontab -l30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh 存放计划任务的文件：存放在/var/spool/cron 123456789101112[root@localhost log]# cd /var/spool/cron/[root@localhost cron]# lsroot[root@localhost cron]# cat root 30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh[root@localhost cron]# crontab -l30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh dinglang创建的计划任务，所有的人都可以创建计划任务，每个用户对应一个文件，文件名和用户名同名 1234567[root@localhost 6_30]# cd /var/spool/cron/[root@localhost cron]# lsdinglang root[root@localhost cron]# cat dinglang */1 * * * * date &amp;&gt;&gt;~/ding.txt[root@localhost cron]#[root@localhost cron]# 操作系统本身背后也会有很多事情需要计划任务来执行的 12345[root@localhost cron]# cd /etc/cron. 紧接着按两下tab键 cron.monthly/ 每月执行的任务cron.daily/ 每天执行的任务cron.hourly/ 每小时执行的任务cron.weekly/ 每周执行的任务 以上是4个文件夹，只要把脚本放到文件夹里，crond进程就是自动去执行 利用脚本搭顺风车 123456789101112[root@localhost cron.daily]# pwd/etc/cron.daily[root@localhost cron.daily]# lslogrotate man-db.cron[root@localhost cron.daily]# [root@localhost cron.daily]# cd /etc/cron.hourly/[root@localhost cron.hourly]# ls0anacron[root@localhost cron.hourly]# cd /etc/cron.monthly/[root@localhost cron.monthly]# ls[root@localhost cron.monthly]# cd /etc/cron.weekly/[root@localhost cron.weekly]# ls 用户如何不登录linux系统，他的计划任务是否会执行？ 答案：不需要登录，计划任务还是会执行 目的：自动化 查看丁浪用户的计划任务 12345678910111213141516第一种：[root@localhost dinglang]# crontab -l30 3 * * * bash /root/6_30/backup_log.sh0 22 * * * bash /root/6_30/backup_log.sh#55 10 * * * bash /root/6_30/backup_log.sh第二种：[root@localhost dinglang]# crontab -l -u dinglang*/5 * * * * date &amp;&gt;&gt;~/ding.txt[root@localhost dinglang]# cd /var/spool/cron/ [root@localhost cron]# ls dinglang root #一个用户对应一个文件[root@localhost cron]# */5 * * * * date &amp;&gt;&gt;~/ding.txt* */1 * * * date &amp;&gt;&gt;~/ding.txt* * */2 * * date &amp;&gt;&gt;~/ding.txt 练习题目 示例1（root用户）： 每天早上7:50自动开启sshd服务，22点50时关闭 1250 7 * * * service sshd start50 22 * * * service sshd stop 每隔5天的12点整清空一次FTP服务器公共目录/var/ftp/pub 10 12 */5 * * rm -rf /var/ftp/pub/* 每周六的7:30时，重新启动httpd服务 130 7 * * 6 service httpd restart - 每周一、三、五的17:30时，打包备份/etc/httpd目录 130 17 * * 1,3,5 tar czf /backup/httpd.tar.gz /etc/httpd - 每天晚上的2点30执行/mysql/backup_mysql.sh脚本（脚本暂时可以不去写） 130 2 * * * bash /mysql/backup_mysql.sh 示例2（dinglang用户）： 每周日晚上23:55时将“/etc/passwd”文件的内容复制到宿主目录中，保存为pwd.txt文件 12[root@localhost 6_30]# crontab -e -u dinglang55 23 * * 7 cp /etc/passwd ~/pwd.txt 时间数值的特殊表示方法 * 表示该范围内的任意时间 ， 表示间隔的多个不连续时间点 - 表示一个连续的时间范围 /n 指定间隔的时间频率 应用实例 0 17 * * 1-5 周一到周五每天17:00 30 8 * * 1,3,5 每周一、三、五的8点30分 0 8-18 * * * 8点到18点整 0 12 */3 * * 每隔3天的12点整","categories":[{"name":"linux","slug":"linux","permalink":"https://chenxl18.github.io/categories/linux/"},{"name":"计划任务","slug":"linux/计划任务","permalink":"https://chenxl18.github.io/categories/linux/计划任务/"}],"tags":[{"name":"shell脚本","slug":"shell脚本","permalink":"https://chenxl18.github.io/tags/shell脚本/"},{"name":"计划任务","slug":"计划任务","permalink":"https://chenxl18.github.io/tags/计划任务/"}]},{"title":"代码的调试与测试","slug":"python/代码的调试与测试","date":"2019-06-29T07:15:19.000Z","updated":"2019-07-04T11:32:31.530Z","comments":true,"path":"2019/06/29/python/代码的调试与测试/","link":"","permalink":"https://chenxl18.github.io/2019/06/29/python/代码的调试与测试/","excerpt":"","text":"代码调试与测试 什么是代码调试与测试？ 测试是为了发现错误而执行程序的过程。 调试是定位错误，修改程序以修正错误，为了程序可运行。 测试从一个已知的条件开始,有预知的结局。 调试从未知的条件开始,其结局不可预知。 为什么要做代码调试与测试？ 代码测试是为了增强代码的健杜倒 代码调试是为了解决已知问题 代码调试方法 print 简单直接粗暴有效 适合开发中 IDE Debuger Pycharm 开发中出错了 pdb 交互的源代码调试功能 命令行中使用 Logging 日志定位问题济记录程序运行情况 发布上线后，记日志 代码测试 assert：断言方便开关 单元测试 什么是单元测试： 1.单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作 2.把上面这些测试用例放到一个测试模块里，就是一个完整的单元测试 测试需要一定时间，而我们完全可以用这些时间去编写代码，为什么要测试而不是去做那些最有生产效率的事？ 1.测试可以保证你的代码在一系列给定条件下正常工作 2.测试允许人们确保对代码的改动不会破坏现有的功能 3.测试自使人们在不寻常条件的情况下思考代码，这可能会揭示出逻辑错误 4.良好的测试要求模块化，解耦代码，这是一个良好的系统设计的标志 unittest单元测试：unittest是Python自带的单元测试框，可以用来作自动化测试框架的用例组织执行框架 优点：提供用例组织与执行方法提供比较方法 提供丰富的日志、清晰的报告 方法： assertEqual(a,b)a == b assertNotEqual(a,b)a != b assertTrue(x)bool(x) is True assertFalse(x)bool(x) is False assertIs(a,b)a is b assertIsNot(a,b)a is not b assertIn(a,b)a in b assertNotIn(a,b)a not in b 单元测试注意事项 在写测试用例的时候尽量代码简单 如果测试用例逻辑比较复杂，那么也可能会出现错误 单元测试即使通过了，也不代表程序本身一点问题都没有 如果单元测试没有通过那程序本身肯定是存在bug的 常用调试方法 print函数 优点：使用简单，直接锁定定位的变量查看结果 缺点：如果程序代码很大，会出现大量的print，运行结果也会包括很多不必要的垃圾信息，等到项目正式发布的时候对于这些print代码还要都删除掉 12345678def fun(): r = input('请输入一个数字') print(type(r)) n = int(r) print('s的值为：%s' % n) result = 100/n return resultprint(fun()) assert断言 在没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行时渍，不如在出现错误条件时就崩渍，这时候就需要assert断言的帮助。 断言可以简简单单的想象为raise-if 语句（更准确的说是raise-if-not 语句）。 测试一个表达式，如果返回值是假，触发异常。 文档：https://docs.python.org/3/reference/simple_stmts.html#assert 格式 12assert expression[, arguments]assert 表达式[, 参数] 等价语句 12if __debug__: if not expression1:raise AssertionError(expression2) 断言需要开启dubug模式 查看：debug 的值 查看：help(“assert”) 开启非Debug模式：python -O 小案例 检查列表长度必须大于2 1assertlen(mylist) &gt;= 1 ​ 检查成绩必须在0~100之间 12score = 101assert score &gt;= 0 and score &lt;=100, 'score is error' - 应用情况 - 防御性的编程：子程序应该不因传入错误数据而被破坏，哪怕是由其他子程序产生的错误数据。 - 合约性检查 比如前置条件，后置条件 如成绩方位、数据类型等 - 运行时对程序逻辑的检测 logging模块 介绍： logging模块是Python内置的标准模块，主要用于输出运行日志，可以设百输出日志的等级、日志保存路径、日志文件轮转 logging模块是标准库之一 优点 可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大呈的调试信息； print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出； logging.basicConfig函数各参数 filename：指定日志文件名 filemode：和file函数意义相同，指定日志文件的打开模式，’w’或者’a’ stream：指定将日志的输出流可以指定输出到sys.stderr，sys.stdout或者文件 默认输出到sys.stderr 当stream和filename同时指定时，stream被忽 level：设置日志级别，默认为logging.WARNNINGFATAL：致命错误 CRITICAL：特别糟糕的事情，如内存耗尽、磁盘空间为空，一般很少使用 ERROR：发生错误时，如IO操作失败或者连接问题 WARNING：发生很重要的事件，但是并不是错误时，如用户登录密码错误 INFO：处理请求或者状态变化等日常事务 DEBUG：调试过程中使用DEBUG等级，如算法中每个循环的中间状态 format：指定输出的格式和内容，format可以输出很多有用的信息%（levelno）s：打印日志级别的数值 %（levelname）s：打印日志级别的名称 %（pathname）s：打印当前执行程序的路径，其实就是sys.argv[0] %（filename）s：打印当前执行程序名 %（funcName）s：打印日志的当前函数 %（lineno）d：打印日志的当前行号 %（asctime）s：打印日志的时间 %（thread）d：打印线程ID %（threadName）s：打印线程名称 %（process）d：打印进程ID%（message）s：打印日志信息 datefmt：指定时间格式，同time.strftime）； handler名称：位置；作用 StreamHandler:logging.StreamHandler 日志输出到流，可以是sys.stderr，sys.stdout或者文件FileHandler:logging.FileHandler 日志输出到文件SysLogHandler:logging.handlers.SysLogHandler 日志输出到syslog BaseRotatingHandler:logging.handlers.BaseRotatingHandler 基本的日志回滚方式RotatingHandler:logging.handlers.RotatingFileHandler 日志回滚方式，支持日志文件最大数量和日志文件回滚TimeRotatingHandler:logging.handlers.TimeRotatingHandler 日志回滚方式，在一定时间区域内回滚日志文件SocketHandler:logging.handlers.SocketHandler 远程输出日志到TCP/IP sockets DatagramHandler:logging.handlers.DatagramHandler 远程输出日志到UDP sockets SMTPHandler:logging，.handlers.SMTPHandler 远程输出日志到邮件地址NTEventLogHandler:logging，.handlers.NTEventLogHandler 远程输出日志到Windows NT/2000/XP的事件日志MemoryHandler:logging.handlers.MemoryHandler 日志输出到内存中的指定buffer HTTPHandler:logging.handlers.HTTPHandler 通过”GET”或者”POST”远程输出到HTTP服务器 日志级别l ogging中可以选择很多消息级别 debug：看不到 info warning error critical：程序要崩溃了 logging是线程安全不是进程安全 线程安全： 多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。 官方logging线程安全 https://docs.python.org/3/library/logging.html#thread-safety pdb-python调试器 使用pdb在代码中设置断点（硬编码） 创建模块mypdb_base.py 123456789import pdba = 2b = a * 2c = a + b# 设置断点pdb.set_trace()print(a)print(b)print(c) 启动调试器 python mypdb_base.py pdb指令 下一条语句：n，next 打印变量信息：p变量名 打印脚本信息：l 退出pdb:q 查看帮助：h 单步调试：每次执行一行 适合场景：短小的脚本 创建模块mypdb_base.py 1234i = 0while True: print(i) i += 1 启动调试器 注意： 远程调试、多线程，pdb搞不定 pdb指令 完整命令 简写命令 描述 args a 打印当前函数的参数 break b 设置断点 clear d 清除断点 condition 无 设置条件断点 continue c或者cont 继续运行，知道遇到断点或者脚本结束 disable 无 禁用断点 enable 无 启用断点 help h 查看pdb帮助 ignore 无 忽略断点 jump j 跳转到指定行数运行 list l 列出脚本清单 next n 执行下条语句，遇到函数不进入其内部 p p 打印变量值，也可以用print quit q 退出pdb return r 一直运行到函数返回 tbreak 无 设置临时断点，断点只中断一次 step s 执行下一条语句，遇到函数进入其内部 where w 查看所在的位置 ！ 无 在pdb中执行语句 IDE Debuger Pycharm 断点设置：遇到断点，程序会停下来，保留所有当前状态数据 启动调试器 常用快捷键 搜索变量：Alt +F8 /Debug行的最后一个按钮（小方形） 下一个断点：F9 下一条语句：F8 进入当前语句的执行：F7 拓展文档： https://blog.csdn.net/u013088062/article/details/50216015 单元测试：单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。 12345比如对于函数abs0，我们可以编写的测试用例为：①输入正数，比如1、1.2、0.99，期待返回值与输入相同②输入复数，比如-1、-1.2、-0.99，期待返回值与输入相反③输入0，期待返回0④输入非数值类型，比如None、、0、期待抛出TypeError 把上面这些测试用例放到一个测试模块里，就是一个完整的单元测试 测试的目的（测试需要一定的时间，而我们完全可以用这些时间去编代码，为什么要测试而不是去做那些最有生产效率的事？） 测试可以保证你的代码在一系列给定条件下正常工作 测试允许人们确保对代码的改动不会破坏现有的功能 测试迫使人们在不寻常条件的情况下思考代码，这可能会揭示出逻辑错误 良好的测试要求模块化，解耦代码，这是一个良好的系统设计的标志 unittest单元测试：unittest是Python自带的单元测试框，可以用来作自动化测试框架的用例组织执行框架。 优点： 提供用例组织与执行方法； 提供比较方法； 提供丰富的日志、清晰的报告。 unittest单元测试方法 方法 检查 assertEqual（a，b） a==b assertNotEqual（a，b） a!=b assertTrue（x） bool（x）is True assertFalse（x） bool（x）is False assertls（a，b） a is b assertlsNot（a，b） a is not b assertin（a，b） a in b assertNotiln（a，b） a not in b 注意事项 在写测试用例的时候尽量代码简单。 如果测试用例逻辑比较复杂，那么也可能会出现错误。 单元测试即使通过了，也不代表程序本身一点问题都没有 如果单元测试没有通过那程序本身肯定是存在bug的","categories":[{"name":"python高阶","slug":"python高阶","permalink":"https://chenxl18.github.io/categories/python高阶/"},{"name":"python代码的调试和测试","slug":"python高阶/python代码的调试和测试","permalink":"https://chenxl18.github.io/categories/python高阶/python代码的调试和测试/"}],"tags":[{"name":"logging模块","slug":"logging模块","permalink":"https://chenxl18.github.io/tags/logging模块/"},{"name":"pdb模块","slug":"pdb模块","permalink":"https://chenxl18.github.io/tags/pdb模块/"},{"name":"单元测试","slug":"单元测试","permalink":"https://chenxl18.github.io/tags/单元测试/"},{"name":"unittest模块","slug":"unittest模块","permalink":"https://chenxl18.github.io/tags/unittest模块/"}]},{"title":"HTML的学习","slug":"web开发/HTML的学习","date":"2019-06-26T03:25:32.000Z","updated":"2019-07-23T03:07:44.985Z","comments":true,"path":"2019/06/26/web开发/HTML的学习/","link":"","permalink":"https://chenxl18.github.io/2019/06/26/web开发/HTML的学习/","excerpt":"","text":"网页前端三剑客 HTML 超文本标记语言 标记页面中有哪些元素 CSS 层叠样式表 我不生产元素，我只让元素变个样子 JavaScript 动态脚本语言 我来决定什么时候使用CSS，更重要的是，我可以创建和修改元素 HTML：要展现的信息 CSS：美化要展示的信息 JS：技能(更好的实现交互) 一个标准的HTML的格式 12345678910&lt;!DOCTYPE html&gt; #声明文档类型&lt;html lang=\"en\"&gt; #页面的根元素，html的语言，en-&gt;英语&lt;head&gt; #头部信息，head标签包含了文档的元(meta)数据 &lt;meta charset=\"UTF-8\"&gt; #编码为utf-8 &lt;title&gt;Title&lt;/title&gt; #标题：浏览器上看到的标题栏&lt;/head&gt;&lt;body&gt; #文档的主体：网页可见的内容&lt;/body&gt;&lt;/html&gt; 例图 HTML学习教程 [1.标题与段落](http://localhost:50766/python/python study/django框架及前端知识/HTML20190626/标题与段落.html) HTML的标签 HTML的标签是由尖括号包围的关键词，比如&lt;html&gt;&lt;/html&gt; HTML的标签通常是成对出现的，比如&lt;b&gt;和&lt;/b&gt; 标签对中的的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签 HTML的属性 HTML标签可以拥有属性。属性提供了有关HTML元素的更多的信息。 属性总是以名称/值对的形式出现，比如：name=”value”. 属性总是在HTML元素的开始标签中规定。 属性 值 描述 class classname 规定元素的类名（classname） id id 规定元素的唯一id style style_definition 规定元素的行内样式（inline style） title text 规定元素的额外信息（可在工具提示中显示） HTML元素 HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。 开始标签 元素内容 结束标签 &lt;p&gt; This is a paragraph &lt;/p&gt; &lt;a href=”default.html”&gt; This is a link &lt;/a&gt; &lt;br/&gt; hr标签：水平线 p标签：段落 &lt;h1&gt; to &lt;h6&gt;：定义HTML标题 标签:这是一个注释 &lt;br&gt;标签：换行 &lt;body&gt;：定义文档的主体 列表：无序和有序 &lt;ol&gt;：定义有序列表 &lt;ul&gt;：定义无序列表 &lt;li&gt;：定义列表项 &lt;dl&gt;：定义自定义列表 &lt;dt&gt;：定义自定义项目 &lt;dd&gt;：定义自定义的描述 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;列表&lt;/h1&gt;&lt;h2&gt;无序列表&lt;/h2&gt;&lt;ul&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt; &lt;li&gt;第三项&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;有序列表&lt;/h2&gt;&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt; &lt;li&gt;第三项&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;自定义列表&lt;/h2&gt;&lt;dl&gt; &lt;dt&gt;Tag部分&lt;/dt&gt; &lt;dd&gt;数据部分&lt;/dd&gt;&lt;/dl&gt;&lt;dl&gt; &lt;dt&gt;Tag部分&lt;/dt&gt; &lt;dd&gt;数据部分&lt;/dd&gt;&lt;/dl&gt;&lt;/body&gt;&lt;/html&gt; 例图 列表无序列表 第一项 第二项 第三项 有序列表 第一项 第二项 第三项 自定义列表Tag部分 ​ 数据部分 Tag部分 ​ 数据部分 文本格式化标签 &lt;b&gt;：定义粗体文本 &lt;big&gt;：定义大号字 &lt;em&gt;：定义着重文字 &lt;i&gt;：定义斜体字 &lt;small&gt;：定义小号字 &lt;strong&gt;：定义加重语气 &lt;sub&gt;：定义下标字 &lt;sup&gt;：定义上标字 &lt;ins&gt;：定义插入字 &lt;del&gt;：定义删除字 CSS 什么是CSS？ CSS指层叠样式表（Cascading Style Sheets） 样式定义如何显示HTML元素 样式通常存储在样式表中 把样式添加到HTML4.0中，是为了解决内容与表现分离的问题 外部样式表可以极大提高工作效率 外部样式表通常存储在CSS文件中 多个样式定义可层叠为一 样式对网页中元素位置的排版进行像素级精确控制 CSS语法 CSS规则由两个主要的部分构成：选择器，以及一条或多条声明； 属性（property）是您希望设置的样式属性（style attribute）。每个属性有一个值。属性和值被冒号分开。 id选择器（#id） id 选择器可以为标有特定id的HTML元素指定特定的样式。 ID属性不要以数字开头，数字开头的ID在Mozilla/Firefox浏览器中不起作用。 Remark ID属性只能在每个HTML文档中出现一次。具体的解释，请参阅XHTML：网站重构。 class选择器(.id) class 选择器用于描述一组元素的样式，class选择器有别于id选择器，class可以在多个元素中使用。 class 选择器在HTML中以class属性表示，在CSS中，类选择器以一个点”：“号显示 所有的p元素使用class=”center”让该元素的文本居中： p.center{text-align:center} 样式层叠次序 当同一个HTML元素定义了多个样式时，应该使用哪个样式？(就近原则) 浏览器缺省设置 外部样式表 内部样式表（位于&lt;head&gt;标签内部）&lt;style&gt;&lt;/style&gt; 内联样式（在HTML元素内部）&lt;p style=&quot;color:red&quot;&gt;xx&lt;/p&gt; JS 基本语法 浏览器属性和DOM属性","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"HTML","slug":"python/HTML","permalink":"https://chenxl18.github.io/categories/python/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://chenxl18.github.io/tags/HTML/"}]},{"title":"Web的学习","slug":"web开发/Web的学习","date":"2019-06-26T01:47:21.000Z","updated":"2019-07-23T03:07:53.095Z","comments":true,"path":"2019/06/26/web开发/Web的学习/","link":"","permalink":"https://chenxl18.github.io/2019/06/26/web开发/Web的学习/","excerpt":"","text":"什么是web开发？ 基于Web技术开发的使用浏览器访问的项目 web开发技术栈 前端 浏览器：Chrome、firefox、IE、Opera、Linux命令客户端、python-request/urllib 网页三剑客：html、css、js 后端 开发语言：Python、java、GO、PHP、Node.js Web框架：接受请求、生成响应、框架的特性、针对业务进行扩展 Django Flask Tornado 服务器操作系统： Linux：CentOS、RedHat、Ubuntu windows server 中间件 负载均衡 WAF(web应用防护) 缓存 运维监控 全文搜索 数据库(备份、容灾、调优) 关系型数据库：MySQL、Sqlite、SqlServer、Oracle 非关系型数据库：NoSQL、MongoDB（key:value） 技术方案 Nginx Restful API OAuth2.0 Docker 消息队列 单面应用与多页应用 单页面应用（SinglePage Web Application，SPA） 多页面应用（MultiPage Application，MPA） 组成 一个外壳页面和多个页面片段组成 多个完整页面构成 资源共用(css.js) 共用，只需在外壳部分加载 不共用，每个页面都需要加载 刷新方式 页面局部刷新或更改 整页刷新 url模式 a.com/#/pageone；a.com/#/pagetwo a.com/pageone.html；a.com/pagetwo.html 拓展： 从MVC到前后端分离 https://blog.csdn.net/shaobingj126/article/details/49420145 前端：你要懂的单页面应用和多页面应用 https://juejin.im/post/5a0ea4ec6fb9a0450407725c 17素材网 http://www.17sucai.com/","categories":[{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/categories/python/"},{"name":"web开发","slug":"python/web开发","permalink":"https://chenxl18.github.io/categories/python/web开发/"}],"tags":[{"name":"web简介","slug":"web简介","permalink":"https://chenxl18.github.io/tags/web简介/"}]},{"title":"迭代器和生成器","slug":"python/迭代器和生成器","date":"2019-06-24T03:07:29.000Z","updated":"2019-06-24T03:09:51.365Z","comments":true,"path":"2019/06/24/python/迭代器和生成器/","link":"","permalink":"https://chenxl18.github.io/2019/06/24/python/迭代器和生成器/","excerpt":"","text":"如何判断一个对象是可迭代对象，迭代器对象或生成器 如何确认一个对象是不是可迭代对象 用Iterable判断 123456789101112131415161718&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt;&gt;&gt;&gt; b = [1,2,3]&gt;&gt;&gt; c = (4,5,6)&gt;&gt;&gt; d = &#123;\"name\":\"tom\",\"age\":22&#125;&gt;&gt;&gt; if isinstance(a,Iterable):... print(\"a是可迭代对象\")...a是可迭代对象&gt;&gt;&gt; if isinstance(b,Iterable):... print(\"b是可迭代对象\")...b是可迭代对象&gt;&gt;&gt; if isinstance(c,Iterable):... print(\"c是可迭代对象\")...c是可迭代 判断迭代器 Iterator判断 12345678from collections import Iterable, Iteratorran = range(3)if isinstance(ran,Iterator): print(\"ran是迭代器\")else: print(\"ran不是迭代器“)输出：ran不是迭代器 ------ - 1234567891011121314是否实现了__iter__和__next__方法from collections import Iterable, Iteratorran = range(3)if isinstance(ran,Iterator): print(\"ran是迭代器\")else: print(\"ran不是迭代器\")print(ran,dir(ran))ran = iter(ran)print(ran,dir(ran))输出：ran不是迭代器range(0, 3) ['__bool__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'count', 'index', 'start', 'step', 'stop']&lt;range_iterator object at 0x000001AF8A8585F0&gt; [__iter__', '__next__', ] 如何判断迭代器 12345678可以使用 isinstance 函数来判断def _(): yield Nonegenerator=type(_())x =( k for k in range(10))print(isinstance(x,generator))输出：true 迭代器与生成器的区别 迭代器 通过iter()方法获得了list的迭代器对象，然后就可以通过next()方法来访问list中的元素了。当容器中没有可访问的元素后，next()方法将会抛出一个StopIteration异常终止迭代器。 生成器 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator） 生成器属于一种特殊的迭代器，而且因为自动创建了iter()和next()，生成器显得特别简洁，而且生成器也是高效的，使用生成器表达式取代列表解析可以同时节省内存。 yield 通常和生成器一起使用 异同 通过实现迭代器协议对应的iter()和next()方法，可以自定义迭代器类型。对于可迭代对象，for语句可以通过iter()方法获取迭代器，并且通过next()方法获得容器的下一个元素。 生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义iter()和next()方法。 生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果。 如何获取可迭代对象、迭代器与生成器中的数据 可迭代对象 用for循环 迭代器 用next()方法 生成器 用next()方法 用yield from 扩展阅读https://docs.python.org/3/library/stdtypes.html#iterator-typeshttps://anandology.com/python-practice-book/iterators.htmlhttps://docs.python.org/3/reference/expressions.html#yieldexpryield from ： http://blog.theerrorlog.com/yield-from-in-python-3.htmlhttp://blog.csdn.net/mingc0758/article/details/53783001Python中生成器和迭代器的区别 http://blog.csdn.net/u014745194/article/details/70176117","categories":[{"name":"python高阶","slug":"python高阶","permalink":"https://chenxl18.github.io/categories/python高阶/"},{"name":"迭代器和生成器","slug":"python高阶/迭代器和生成器","permalink":"https://chenxl18.github.io/categories/python高阶/迭代器和生成器/"}],"tags":[{"name":"集合、元组、列表推导式","slug":"集合、元组、列表推导式","permalink":"https://chenxl18.github.io/tags/集合、元组、列表推导式/"},{"name":"可迭代对象","slug":"可迭代对象","permalink":"https://chenxl18.github.io/tags/可迭代对象/"},{"name":"迭代器","slug":"迭代器","permalink":"https://chenxl18.github.io/tags/迭代器/"},{"name":"生成器","slug":"生成器","permalink":"https://chenxl18.github.io/tags/生成器/"}]},{"title":"raid-廉价磁盘冗余阵列","slug":"linux/raid-廉价磁盘冗余阵列","date":"2019-06-23T06:56:42.000Z","updated":"2019-06-23T07:36:21.805Z","comments":true,"path":"2019/06/23/linux/raid-廉价磁盘冗余阵列/","link":"","permalink":"https://chenxl18.github.io/2019/06/23/linux/raid-廉价磁盘冗余阵列/","excerpt":"","text":"raid-廉价磁盘冗余阵列 raid 磁盘阵列（独立冗余磁盘阵列） 硬raid（推荐）：会有一个raid卡，用来控制这个raid，是正raid的大脑 容错功能 专门有数据处理的芯片 软raid：通过软件来实现raid控制功能，不需要需要硬件。 需要使用电脑的cpu里来处理数据 磁盘阵列（Redundant Arrays of Independent Drives，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个磁盘上 磁盘会坏，坏了就意味着数据丢失 RAID0、RAID1、RAID5、RAID6、RAID10、RAID01 功能： 1.数据冗余 2.容错 3.存取数据速度快 raid0：读写速度快，但是没有容错功能。2块以上磁盘组成。磁盘利用率100%–》条带卷 raid1：镜像卷：2块磁盘组成，有容错功能。磁盘利用率50% raid5：背后的原理是分布校验+条带：可以容错，至少3块磁盘，最多坏一块。 磁盘利用率：（n-1）/n raid6：背后的原理是分布校验+分布校验+条带：可以容错，至少4块磁盘，最多坏2块。 磁盘利用率：（n-2）/n RAID配置总结 级别 RAID0 RAID1 RAID5 RAID6 磁盘数 &gt;=2 2 &gt;=3 &gt;=4 容错功能 无 有 有 较强 读写速度 最快 写入慢 较快较快 较快 磁盘空间利用 100% 50% n-1 n-2 如何知道磁盘坏了？ 1.看磁盘的灯是否亮–》需要人去现场看–》很傻 2.查看raid的数据，里面有显示那些是好的，那些是坏的。–》监控脚本或者程序 软件raid：只能通过Linux系统本身来查看 1cat /proc/mdstat #可以看到raid级别，状态等信息。 硬件raid：最佳的办法是通过已安装的raid厂商的管理工具来查看，有cmdline，也有图形界面 如Adaptec公司的硬件卡就可以通过下面的命令进行查看： 1/usr/dpt/raidutil-L all #可以看到非常详细的信息。 raid的配置是在安装系统之前就配置好了的 裸机–》系统做raid1，数据磁盘做raid5–》安装系统—》存放数据 能自己购买服务器的公司—》有钱的行为 只有真实的服务器需要做raid 购买云服务器的公司不做raid 云服务产商会提供数据不丢失的保障 99.9999% LVM(Logical Volume Manager),逻辑卷管理 动态扩容 分区结构不需要修改","categories":[{"name":"linux高级","slug":"linux高级","permalink":"https://chenxl18.github.io/categories/linux高级/"},{"name":"文件系统","slug":"linux高级/文件系统","permalink":"https://chenxl18.github.io/categories/linux高级/文件系统/"},{"name":"raid","slug":"linux高级/文件系统/raid","permalink":"https://chenxl18.github.io/categories/linux高级/文件系统/raid/"}],"tags":[{"name":"raid廉价磁盘冗余阵列","slug":"raid廉价磁盘冗余阵列","permalink":"https://chenxl18.github.io/tags/raid廉价磁盘冗余阵列/"}]},{"title":"网络层","slug":"计算机网络/网络层","date":"2019-06-21T11:42:12.000Z","updated":"2019-06-27T11:11:43.889Z","comments":true,"path":"2019/06/21/计算机网络/网络层/","link":"","permalink":"https://chenxl18.github.io/2019/06/21/计算机网络/网络层/","excerpt":"","text":"计算机网络之网络层 TCP/IP五层协议： 应用层、传输层、网络层、数据链路层、物理层 网络层：ip、arp、icmp3个协议 传输层：tcp、udp ip协议—-internet protocol互联网协议 现在的互联网协议：ipv4 下一代互联网协议：ipv6 IP数据包格式（只记住重点） TTL–&gt;time to live=生命周期 广播与广播域 广播：将广播地址做为目的地址的数据帧 广播域：网络中能接收到同一个广播所有节点的集合 MAC ARP协议：Address Resolution Protocol 地址解析协议 1.request 请求包 源ip：自己的 目的ip：别人的 源mac：自己的 目的mac：000000000000 2.response 响应包 数据链路层里的帧的封装格式 源mac：自己的 目的mac：ffffffffffff 为什么交换机收到arp包会转发？ 为什么叫arp广播？ 如果是arp request包会转发到所有的接口 arp缓存表里的内容是可以更新的。 arp缓存表是在内存里存放的. linux系统中的ARP命令 arp-a：查看ARP缓存表·arp-n 查看ARP缓存表 arp-d：清除ARP缓存 arp-s：绑定ip地址和mac地址。 ICMP协议：是一个“错误侦测与回馈机制”，是通过IP数据包封装的，用来发送错误和控制消息 三层交换","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenxl18.github.io/categories/计算机网络/"},{"name":"网络层笔记","slug":"计算机网络/网络层笔记","permalink":"https://chenxl18.github.io/categories/计算机网络/网络层笔记/"}],"tags":[{"name":"网络层","slug":"网络层","permalink":"https://chenxl18.github.io/tags/网络层/"}]},{"title":"python的多进程和多线程","slug":"python/python的多进程和多线程","date":"2019-06-18T11:27:26.000Z","updated":"2019-06-26T13:17:40.616Z","comments":true,"path":"2019/06/18/python/python的多进程和多线程/","link":"","permalink":"https://chenxl18.github.io/2019/06/18/python/python的多进程和多线程/","excerpt":"","text":"python的多进程和多线程 进程和进程之间通信，有哪些方式？ 管道 共享内存 信号 kill 是linux中杀死进程的命令 9) SIGKILL 信号类型 –&gt;被强制杀死（都来不及保存数据） 为什么kill进程的时候需要接-9？ 强制杀死，因为-9的信号类型是不能被屏蔽的，所以可以达到强制杀死进程的目的 15) SIGTERM 告诉进程自我终结 signal terminate—&gt;15这种信号是可以被屏蔽的 1) SIGHUP signal HUP—-&gt; 挂起 父进程开启了一堆的子进程，如果把父进程杀死，父会给子进程发HUP信号，操作系统会将所有收到HUP信号的子进程全部杀死 2) SIGINT 中断信号 signal inerrupt—-&gt;按ctrl+c其实就是发中断信号 队列 信号量 socket（槽） 网络socket = ip : port 文件socket 12345678910111213141516from multiprocessing import Processimport timedef foo(i): print('chlid , arg i is &#123;&#125;'.format(i)) time.sleep(1) print('child , arg i is &#123;&#125;'.format(i))if __name__ == '__main__': p_lst = [] for i in range(4): p = Process(target=foo, args=(i,)) p.start() p_lst.append(p) p.join() #[p.join() for p in p_lst] 进程里包含线程，一个进程里可以包含很多线程 进程 ：pcb（process控制块） + 代码 + 数据 线程 ：tcb （thread控制块） + 代码 + 数据 进程消耗资源多（cpu、内存、磁盘、网络等） 线程可以共享进程里的一些公共资源，更加节约系统的资源。 为什么线程在cpu里运行会比进程快？ 线程在上下文切换的时候，因为有公共部分，所以节约很多的时间，有很多的数据不需要切换，直接使用。 为什么线程更加节省资源（cpu、内存）？ 内存空间上：因为线程有公共部分，所以更加节约空间。 多进程更加稳定、但消耗资源多 多线程速度快，但是一个进程被杀死，进程里的线程都杀死，不够稳定—-nginx\\mysql等 进程和线程的差异？ 进程里包含线程 线程更加节省资源 为啥节省资源？ 1.一个进程里起的线程可以共享部分内存空间–》节省内存 2.在上下文切换的时候，速度会更加快 进程稳定 杀死一个进程，会杀死这个进程里的所有的线程 为什么nginx起的进程的数量需要和cpu的核心的数量一样？ 井行，同时处理 同一个进程里的线程不需要在不同的cpu里切换，速度更加快 cpu在处理数据的时候，linux对待进程，和对待线程是一样的 进程与线程 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 真正在cpu上运行的是线程 线程在执行过程中，需要协作同步 多进程与多线程 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复余，需要用IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机稻比较简单 适应于多核分布式 进程占优 GIL锁是什么？有什么用？为什么需要这个锁？为什么有这个锁？Python GIL与多线程 GIL全称Global Interpreter Lock（全局解释器锁） GIL和Python语言没有任何关系，只是因为历史原因导致在官方推荐的解释器Cpython中遗留的问题（Jpython无此类问题） 每个线程在执行的过程中都需要先获取GIL，保证同一时刻只有一个线程可以执行代码，控制线程的执行顺序 cpython作者这样写，历史遗留原因；1991年的硬件非常差，根本没有多核的概念 GIL锁的坏处就是不能同时使用多个cpu核心。–》不能同时使用cpu去运行，意味着多线程不能同时工作，速度起不来。 python里的多进程与多线程的选择 io密集型计算用多线程–》读写数据非常多 cpu密集型计算用多进程—》计算非常多–》需要大量使用cpu c语言里的多进程与多线程的选择(个人看法) io密集型计算用多线程 cpu密集型计算用多进程 多线程：（） Gil全局解释锁和线程互斥锁的关系 https://www.cnblogs.com/Keep-Ambition/p/7596098.html 协程和线程的区别？协程是否有上下文切换的概念？多线程是否上下文切换？ 总结： 不一致读 互斥锁：控制多线程执行的顺序 GIL锁 threading线程模块 创建线程的类—-&gt;Thread 创建锁的类—-&gt;Lock","categories":[{"name":"python高阶","slug":"python高阶","permalink":"https://chenxl18.github.io/categories/python高阶/"},{"name":"多进程和多线程","slug":"python高阶/多进程和多线程","permalink":"https://chenxl18.github.io/categories/python高阶/多进程和多线程/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://chenxl18.github.io/tags/笔记/"},{"name":"进程间通信方式","slug":"进程间通信方式","permalink":"https://chenxl18.github.io/tags/进程间通信方式/"},{"name":"操作系统","slug":"操作系统","permalink":"https://chenxl18.github.io/tags/操作系统/"}]},{"title":"git的20个面试题","slug":"git的20个面试题","date":"2019-06-18T06:29:56.000Z","updated":"2019-06-24T08:19:36.702Z","comments":true,"path":"2019/06/18/git的20个面试题/","link":"","permalink":"https://chenxl18.github.io/2019/06/18/git的20个面试题/","excerpt":"","text":"GIT和SVN有什么区别？ Git SVN 1. Git是一个分布式的版本控制工具 1. SVN 是集中版本控制工具 2.它属于第3代版本控制工具 2.它属于第2代版本控制工具 3.客户端可以在其本地系统上克隆整个存储库 3.版本历史记录存储在服务器端存储库中 4.即使离线也可以提交 4.只允许在线提交 5.Push/pull 操作更快 5.Push/pull 操作较慢 6.工程可以用 commit 自动共享 6.没有任何东西自动共享 什么是GIT? Git 是分布式版本控制系统（DVCS）。它可以跟踪文件的更改，并允许你恢复到任何特定版本的更改。 与 SVN 等其他版本控制系统（VCS）相比，其分布式架构具有许多优势，一个主要优点是它不依赖于中央服务器来存储项目文件的所有版本。 每个开发人员都可以“克隆”我在图中用“Local repository”标注的存储库的副本，并且在他的硬盘驱动器上具有项目的完整历史记录，因此当服务器中断时，你需要的所有恢复数据都在你队友的本地 Git 存储库中。 还有一个中央云存储库，开发人员可以向其提交更改，并与其他团队成员进行共享，如图所示，所有协作者都在提交更改“远程存储库”。 在GIT中提交的命令是什么？ git commit -a/-m -a：是指git提交已修改的所有被跟踪文件的新内容。 -m：指备注信息 什么是GIT中的“裸存储库”？ Git 中的 “裸” 存储库只包含版本控制信息而没有工作文件（没有工作树），并且它不包含特殊的 .git 子目录。相反，它直接在主目录本身包含 .git 子目录中的所有内容，其中工作目录包括： 一个 .git 子目录，其中包含你的仓库所有相关的 Git 修订历史记录。 工作树，或签出的项目文件的副本。 GIT是用什么语言编写的？ Git使用 C 语言编写。 GIT 很快，C 语言通过减少运行时的开销来做到这一点。 在GIT中，你如何还原已经push并公开的提交？ 删除或修复新提交中的错误文件，并将其推送到远程存储库。这是修复错误的最自然方式。对文件进行必要的修改后，将其提交到我将使用的远程存储库 1git commit -m \"commit message\" 创建一个新的提交，撤消在错误提交中所做的所有更改。可以使用命令 1git revert &lt;name of bad commit&gt; git pull 和git fetch 有什么区别？ git pull 命令从中央存储库中提取特定分支的新更改或提交，并更新本地存储库中的目标分支。 git fetch 也用于相同的目的，但它的工作方式略有不同。当你执行 git fetch 时，它会从所需的分支中提取所有新提交，并将其存储在本地存储库中的新分支中。如果要在目标分支中反映这些更改，必须在 git fetch 之后执行git merge。只有在对目标分支和获取的分支进行合并后才会更新目标分支。为了方便起见，请记住以下等式： git pull = git fetch + git merge git 中的“staging area” 或“index”是什么？ 在完成提交之前，可以在称为“staging area”或“index”的中间区域中对其进行格式化和审查；从图中可以看出，每个更改首先在暂存区域中进行验证，称为“stage file”，然后将更改提交到存储库。 https://segmentfault.com/img/bVbtc0c?w=655&amp;h=645 什么是git stash? 通常情况下，一直在处理项目的某一部分时，如果想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，不想把完成了一半的工作的提交，以便以后就可以回到当前的工作。解决这个问题的答案是 git stash。 stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，可以随时重新应用这些更改。 什么是git stash drop? git stash drop命令用于删除隐藏的项目。 默认情况下，它将删除最后添加的存储项，如果提供参数的话，它还可以删除特定项。 如何找到特定提交中已更改的文件列表？ 要获取特定提交中已更改的列表文件，请使用以下命令： git diff-tree -r {hash} 给定提交哈希，这将列出在该提交中更改或添加的所有文件。 -r 标志使命令列出单个文件，而不是仅将它们折叠到根目录名称中。 你还可以包括下面提到的内容，虽然它是可选的，但有助于给面试官留下深刻印象。 输出还将包含一些额外信息，可以通过包含两个标志把它们轻松的屏蔽掉： git diff-tree –no-commit-id –name-only -r {hash} 这里 -no-commit-id 将禁止提交哈希值出现在输出中，而 -name-only 只会打印文件名而不是它们的路径。 git config 的功能是什么？ 用来查看或修改你的git配置，包括用户名 提交对象包含什么？ 一组文件，表示给定时间点的项目状态 引用父提交对象 SHAI 名称，一个40个字符的字符串，提交对象的唯一标识。 如何在GIT中创建存储库？ 要创建存储库，先为项目创建一个目录（如果该目录不存在），然后运行命令 git init。通过运行此命令，将在项目的目录中创建 .git 目录。 怎样将N次提交压缩成一次提交? 如果要从头开始编写新的提交消息，请使用以下命令： 12git reset –soft HEAD~N &amp;&amp;git commit 如果你想在新的提交消息中串联现有的提交消息，那么需要提取这些消息并将它们传给 git commit，可以这样： 12git reset –soft HEAD~N &amp;&amp;git commit –edit -m\"$(git log –format=%B –reverse .HEAD@&#123;N&#125;)\" 什么是GIT bisect?如何使用它来确定（回归）错误的来源？ Git bisect 用于查找使用二进制搜索引入错误的提交。 1git bisect &lt;subcommand&gt; &lt;options&gt; 此命令用了二进制搜索算法来查找项目历史记录中的哪个提交引入了错误。你可以通过告诉它已知包含该错误的“错误”提交以及在引入错误之前已知的“良好”提交来使用它。然后 git bisect 在这两个端点之间选择一个提交，并询问你所选的提交是“好”还是“坏”。它继续缩小范围，直到找到引入更改的确切提交。 如果想要在提交之前运行代码性检查工具，并在测试失败时阻止提交，该怎么配置GIT存储库？ 这可以通过与存储库的 pre-commit hook 相关的简单脚本来完成。git 会在提交之前触发 pre-commit hook。你可以在这个脚本中运行其他工具，例如 linters，并对提交到存储库中的更改执行完整性检查。 描述一下你所使用的分支策略？ 功能分支（Feature branching） 要素分支模型将特定要素的所有更改保留在分支内。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。 任务分支（Task branching） 在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。 发布分支（Release branching） 一旦开发分支获得了足够的发布功能，你就可以克隆该分支来形成发布分支。创建该分支将会启动下一个发布周期，所以在此之后不能再添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该包含在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它还应该再将自发布以来已经取得的进展合并回开发分支。 如果分支是否已合并为master，你可以通过什么手段知道？ git branch –merged 它列出了已合并到当前分支的分支。 git branch –no-merged 它列出了尚未合并的分支。 什么是SubGit？ SubGit 是将 SVN 到 Git迁移的工具。它创建了一个可写的本地或远程 Subversion 存储库的 Git 镜像，并且只要你愿意，可以随意使用 Subversion 和 Git。 这样做有很多优点，比如你可以从 Subversion 快速一次性导入到 Git 或者在 Atlassian Bitbucket Server 中使用SubGit。我们可以用 SubGit 创建现有 Subversion 存储库的双向 Git-SVN 镜像。你可以在方便时 push 到 Git 或提交 Subversion。同步由 SubGit 完成。 https://segmentfault.com/a/1190000019315509","categories":[{"name":"git","slug":"git","permalink":"https://chenxl18.github.io/categories/git/"}],"tags":[{"name":"分布式版本控制系统","slug":"分布式版本控制系统","permalink":"https://chenxl18.github.io/tags/分布式版本控制系统/"},{"name":"面试题","slug":"面试题","permalink":"https://chenxl18.github.io/tags/面试题/"}]},{"title":"Git","slug":"Git","date":"2019-06-16T02:35:54.000Z","updated":"2019-06-24T08:19:50.722Z","comments":true,"path":"2019/06/16/Git/","link":"","permalink":"https://chenxl18.github.io/2019/06/16/Git/","excerpt":"","text":"Git .gitignore仓库log目录，不希望同步到仓库中去，写到.gitignore文件 /log/ 凡是写到这个文件中了，那么git add.的时候就不会被添加到仓库中去 .pyc 常用命令 git log：查看历史 git add：标记文件添加到仓库 git add . =&gt;标记当前目录及子目录文件（.gitignore文件指定的内容是不添加的） 不能同步空目录 git clone：克隆仓库 12git clone https://github.com/chenxl18/chenxl18.github.io.git#=&gt; 当前目录 12/d/hexo/myblog/source/_posts (master)# master =&gt;master 分支 web页面（服务器）修改-&gt;同步-&gt;本地 1.在web页面修改 2.在本地仓库中执行：git pull origin master 3.git pull [&lt;远程仓库名&gt; &lt;分支名&gt;] 本地修改-&gt;同步-&gt;web页面（服务器） 1.本地修改：vim，右击创建 2.标记待添加到仓库： 1git add liu.txt 配置邮箱、用户名(必须配置此项才能提交数据到仓库) 1(master)$ git config user.name 'yourname' (master)$ git config user.email 'youremail@163.com' 提交文件到本地仓库： 1git commit #一定要写备注信息，否则此次提交会被忽略 提交到远程仓库： 1git push origin master 注意：当进行push/commit之前，最好先pull一下 注意： 不要在仓库下进行克隆 当web页面有更新，本地也有更新的时候，注意可能会产生冲突 如果能自动合并的，它会自动合并，不能自动合并的，需要手动合并 Web页面上修改 本地修改、add、commit 提交到远程仓库 本地在push的时候，跟服务器版本有不一致的地方，所以有以上提示，需要先pull pull时，因为本地和远程都修改了同一个文件，无法自动合并，所以进入了merge模式 pull的时候，如果能自动合并的，它会自动合并，不能自动合并的，手动合并 MERGING模式 12345&lt;&lt;&lt;&lt;HEAD 你的修改 ====== 远程仓库的修改 &gt;&gt;&gt;&gt;&gt; 版本号 把自己需要的部分保留，不需要的删除。修改完成后再次add/commit即可退出merge模式 （&gt;&gt;&gt;&gt; ==== &lt;&lt;&lt;&lt;&lt;这些行一定删除） 再次git push到远程仓库 可查看git log日志 在仓库中把califeng文件删除，是否能找回 可以找回 注意： 不要仓库下进行克隆 gitee_python_study (master) master =&gt; master分支 遇到的问题 第一次 push时都需要输入密码 .git/conﬁg [remote “origin”] url = http://git.sanchuangedu.cn:3000/chenxl/python_study.git fetch = +refs/heads/:refs/remotes/origin/ .gitignore 本地-&gt; Web commit 修改文件: vim, touch, mkdir。。。。 标记为暂存状态: git add 提交到本地仓库：git commit 提交到远程仓库：git push 为开源的项目提交代码、只读的项目 写权限=&gt; 删除修改文件 =&gt; push 克隆项目：你自己帐户下的python_study 写代码：根目录下创建以自己名字命名的文件 配置：git config 同步到远程仓库 添加远程仓库 git remote add 名字 仓库地址 git remote add source http://git.sanchuangedu.cn:3000/cali/python_study.git 从远程仓库拉取最新的信息 git pull source master 测试：尝试向source push一点东西 403错误 bigbusiness =》 开发者权限 （读、写）读 fork -&gt; 可以 pull -&gt; 可以 clone -&gt; 可以 开发者 push -&gt; 可以 git clone 克隆 git add 标记 git commit 提交 git pull 拉文件 git push 推文件 git log 查看日志 git status 查看当前状态 git remote (add / remove / -v) 查看远程源 git rm 删除 git mv ﬁle newﬁle 更改文件名 git branch -a 查看所有分支 git checkout 切换分支 git reset git conﬁg 配置 git branch dev 创建新分支 基于当前分支来创建git branch init ca752793c1b6e957636b192777da3ba72da8e35c 基于某一个提交点创建分支 git checkout -b init02 创建init02并切换到分支 git branch -d init 删除分支 注：git的官方文档 https://git-scm.com/book/zh/v2/","categories":[{"name":"git","slug":"git","permalink":"https://chenxl18.github.io/categories/git/"}],"tags":[{"name":"git的使用","slug":"git的使用","permalink":"https://chenxl18.github.io/tags/git的使用/"}]},{"title":"linux中IP地址的配置","slug":"计算机网络/linux中IP地址的配置","date":"2019-06-14T11:43:00.000Z","updated":"2019-06-14T12:20:48.723Z","comments":true,"path":"2019/06/14/计算机网络/linux中IP地址的配置/","link":"","permalink":"https://chenxl18.github.io/2019/06/14/计算机网络/linux中IP地址的配置/","excerpt":"","text":"进入ip地址配置目录1cd /etc/sysconfig/network-scripts 打开配置文件1vim ifcfg-ens33 修改配置文件12345678BOOTPROTO=noneNAME=ens33DEVICE=ens33ONBOOT=yesIPADDR=192.168.0.156NETMASK=255.255.255.0GATEWAY=192.168.0.1DNS1=114.114.114.114 重启网络服务1service network restart 测试配置ip地址1ping www.baidu.com 如下面的差不多就代表配置成功12345[root@chenxianle ~]# ping www.baidu.comPING www.a.shifen.com (14.215.177.38) 56(84) bytes of data.64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=1 ttl=55 time=29.6 ms64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=2 ttl=55 time=30.4 ms64 bytes from 14.215.177.38 (14.215.177.38): icmp_seq=3 ttl=55 time=30.2 ms","categories":[{"name":"linux","slug":"linux","permalink":"https://chenxl18.github.io/categories/linux/"},{"name":"IP地址配置","slug":"linux/IP地址配置","permalink":"https://chenxl18.github.io/categories/linux/IP地址配置/"}],"tags":[{"name":"ip基本配置","slug":"ip基本配置","permalink":"https://chenxl18.github.io/tags/ip基本配置/"}]},{"title":"tmux的基本操作","slug":"linux/tmux的基本操作","date":"2019-06-12T13:08:46.000Z","updated":"2019-06-13T05:27:14.806Z","comments":true,"path":"2019/06/12/linux/tmux的基本操作/","link":"","permalink":"https://chenxl18.github.io/2019/06/12/linux/tmux的基本操作/","excerpt":"","text":"如何在linux机器中使用tmux(分屏工具)tmux（介绍）tmux（terminal multiplexer）是Linux上的终端复用神器，可从一个屏幕上管理多个终端（准确说是伪终端）。使用该工具，用户可以连接或断开会话，而保持终端在后台运行。类似的工具还有screen，个人对这二者的使用感受是，用过tmux就再也不想用screen了 更新epel源1yum install epel-release -y 下载tmux工具1yum install tmux -y 开启tmux终端1tmux tmux基本操作打开一个新窗口1ctrl b + \" 光标上下切换1ctrl b + 上下方向键 退出tmux1ctrl b + d 删除光标所在一个tmux窗口1ctrl b + x 列出所有命令1tmux list-command Tmux的快捷键使用说明： Ctrl+b 激活控制台；此时以下按键生效 系统操作 ? 列出所有快捷键；按q返回 d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话 D 选择要脱离的会话；在同时开启了多个会话时使用 Ctrl+z 挂起当前会话 r 强制重绘未脱离的会话 s 选择并切换会话；在同时开启了多个会话时使用 : 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器 [ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出 ~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息 窗口操作 c 创建新窗口 &amp; 关闭当前窗口 数字键 切换至指定窗口 p 切换至上一窗口 n 切换至下一窗口 l 在前后两个窗口间互相切换 w 通过窗口列表切换窗口 , 重命名当前窗口；这样便于识别 . 修改当前窗口编号；相当于窗口重新排序 f 在所有窗口中查找指定文本 面板操作 ” 将当前面板平分为上下两块 % 将当前面板平分为左右两块 x 关闭当前面板 ! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板 Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小 Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小 Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled q 显示面板编号 o 在当前窗口中选择下一面板 方向键 移动光标以选择面板 { 向前置换当前面板 } 向后置换当前面板 Alt+o 逆时针旋转当前窗口的面板 Ctrl+o 顺时针旋转当前窗口的面板 注：详细的请查看参考资料 参考资料https://www.cnblogs.com/kevingrace/p/6496899.html","categories":[{"name":"linux","slug":"linux","permalink":"https://chenxl18.github.io/categories/linux/"},{"name":"linux分屏工具","slug":"linux/linux分屏工具","permalink":"https://chenxl18.github.io/categories/linux/linux分屏工具/"}],"tags":[{"name":"linux分屏工具","slug":"linux分屏工具","permalink":"https://chenxl18.github.io/tags/linux分屏工具/"},{"name":"tmux的基本操作","slug":"tmux的基本操作","permalink":"https://chenxl18.github.io/tags/tmux的基本操作/"}]},{"title":"python面试题31-45","slug":"python/python面试题31-45","date":"2019-06-11T07:25:01.000Z","updated":"2019-06-11T07:40:43.609Z","comments":true,"path":"2019/06/11/python/python面试题31-45/","link":"","permalink":"https://chenxl18.github.io/2019/06/11/python/python面试题31-45/","excerpt":"","text":"31. filter、map、reduce的作用？filter：对sequence中的item依次执行function(item)，将执行结果为True的item组成一个List/String/Tuple（取决于sequence的类型）。 filter(function or None, sequence) -&gt; list, tuple, or string：入参为函数和列表/元组/字符串，返回值为item列表/元组/字符串。 map:对sequence中的item依次执行function(item)，将执行结果function(item)组成一个List返回。 map(function, sequence[, sequence, …]) -&gt; list：入参是为函数和列表/元组/字符串，返回值为function(item)列表。 reduce:对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用。function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。 reduce(function, sequence[, initial]) -&gt; value：入参是为函数和列表/元组/字符串和初始值，返回值为数值。32. 常用的 Python 标准库都有哪些?​ os、time、random、pymysql、threading、multiprocess、queue33. 至少列举8个常用模块都有那些?​ requests、re、md5、hashlib、django、sys、math、random、time 34. re的match和search区别？​ match:只匹配一个，从字符串开头进行匹配，如果字符串开始不符合正则表达式，则匹配失败，函数返回None search:只匹配一次，在字符串中进行匹配，直到找到一个匹配，否则也返回None35. 什么是正则的贪婪匹配？重复运算符在默认条件下是贪婪的，匹配尽可能多的字符36. 介绍一下 except 的作用和用法?Python的except用来捕获所有异常， 因为Python里面的每次错误都会抛出 一个异常，所以每个程序的错误都被当作一个运行时错误。37. 在 except 中 return 后还会不会执行 finally 中的代码?怎么抛出自定义异常?（1）不管有木有出现异常，finally块中代码都会执行； （2）当try和catch中有return时，finally仍然会执行； （3）finally是在return语句执行之后，返回之前执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前就已经确定了； （4）finally中如果包含return，那么程序将在这里返回，而不是try或catch中的return返回，返回值就不是try或catch中保存的返回值了38. Python 的魔法方法?​ __init__：通过此方法我们可以定义一个对象的初始操作 __new__：是用来创建类并返回这个类的实例 __del__ ：在对象生命周期调用结束时，__del__ 方法会被调用，39. init和new的区别? __init__: __init__方法通常用在初始化一个类实例的时候 __new__:__new__方法接受的参数虽然也是和 __init__一样，但 __init__是在类实例创建之后调用，而 __new__方法正是创建这个类实例的方法。 __init__和__new__最主要的区别在于：__init__通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。__new__通常用于控制生成一个新实例的过程。它是类级别的方法。 40. 说明一下 os.path 和 sys.path 分别代表什么?(1)os.path 主要是用于对系统路径文件的操作。 (2)sys.path 主要是对Python解释器的系统环境参数的操作（动态的改变Python解释器搜索路径）。41. Python 的 sys 模块常用方法?sys.argv#命令行参数List，第一个元素是程序本身路径 sys.path#返回模块的搜索路径，初始化时使用PYTHONPATH环境变里的值 sys.modules.keys（）#返回所有已经导入的模块列表 sys.modules#返回系统导入的模块字段，key是模块名，value是模块 sys.exc_info（）#获取当前正在处理的异常类，exc_type、exc_value、exc_traceback当前处理的异常详细信息 sys.exit（n）#退出程序，正常退出时exit（e) sys.hexversion#获取Python解释程序的版本值，16进制格式如：0x020403F0 sys.version#获取Python解释程序的版本信息 sys.platform#返回操作系统平台名称 sys.maxint#最大的Int值 sys.stdout#标准输出 sys.stdout.write（“aaa&apos;）#标准输出内容 sys.stdout.writelines（）#无换行输出 sys.stdin#标准输入 sys.stdin.read（）#输入一行 sys.stderr#错误输出 sys.exc_clear（）#用来清除当前线程所出现的当前的或最近的错误信息 sys.exec_prefix#返回平台独立的python文件安装的位置 sys.byteorder#本地字节规则的指示器，big-endian平台的值是‘big’，little-endian平台的值是little sys.copyright#记录python版权相关的东西 sys.api_version#解释器的c的API版本 sys.version_info#’final表示最终，也有‘candidate’表示候选，表示版本级别，是否有后继的发行 sys.getdefaultencoding（）#返回当前你所用的默认的字符编码格式 sys.getfilesystemencoding（）#返回将Unicode文件名转换成系统文件名的编码的名字 sys.builtin_module_names#Python解释器导入的内建模块列表 sys.executable#Python解释程序路径 sys.getwindowsversion（）#获取indows的版本 sys.stdin.readline（）#从标准输入读一行， sys.stdout.write（a）屏幕输出a sys.setdefaultencoding（name）#用来设置当前默认的字符编码（详细使用参考文档） sys.displayhook（value）#如果value非空，这个函数会把他输出到sys.stdout（详细使用参考文档）42. os和sys模块的作用？​ os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。43. 读取文件的几种方法的区别?（1）直接打开就读：虽然f是一个文件实例，但可以通过以上方式对每一行进行循环处理了，处理时每一行是一个字符串str,而且这个是速度最快最简洁的方法 （2）用read（）打开：这个函数把文件全部内容一次性读到一个字符串中。就是一坨的那种，如果把ff用循环读取的方式输出，会是一个一个字符，因为ff是字符串，本质上是tuple （3）用readlines():这个函数将文件所用内容以行为区分读到一个列表中 ，列表中的每一个元素是一行；lines是list，line 是str （4）用readline():这种方式是一行一行的读，非常的省内存，当文件巨大的情况下是有好处的44. 谈谈你对面向对象的理解？​ 面向对象编程是种具有对象概念的程序编程范型，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的可重用性、灵活性和可扩展性，对象里的程序可以访问及修改对象相关联的数据。在面向对象编程里，计算机程序会被设计成彼此相关的对象。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对计算机下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个小型的“机器”，即对象45. Python面向对象中的继承有什么特点？继承更多了是为了多态，也可提升代码的复用程度。 特点： 在继承中基类的构造（init()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用； Python总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）；","categories":[{"name":"python面试题","slug":"python面试题","permalink":"https://chenxl18.github.io/categories/python面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://chenxl18.github.io/tags/面试题/"},{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/tags/python/"},{"name":"31-45","slug":"31-45","permalink":"https://chenxl18.github.io/tags/31-45/"}]},{"title":"python面试题16-30","slug":"python/python面试题16-30","date":"2019-06-11T07:16:02.000Z","updated":"2019-06-11T07:40:12.842Z","comments":true,"path":"2019/06/11/python/python面试题16-30/","link":"","permalink":"https://chenxl18.github.io/2019/06/11/python/python面试题16-30/","excerpt":"","text":"16. Python3和Python2中 int 和 long的区别？​ Python 2有为非浮点数准备的int和long类型。int类型的最大值不能超过sys.maxint，而且这个最大值是平台相关的。可以通过在数字的末尾附上一个L来定义长整型，显然，它比int类型表示的数字范围更大。 Python 3里，只有一种整数类型int，大多数情况下，它很像Python 2里的长整型。由于已经不存在两种类型的整数，所以就没有必要使用特殊的语法去区别他们。17. 4G 内存怎么读取一个 5G 的数据?​ (1)可以通过生成器，分多次读取，每次读取数量相对少的数据（比如 500MB）进行处理，处理结束后在读取后面的 500MB 的数据 (2)可以通过 linux 命令 split 切割成小文件，然后再对数据进行处理，此方法效率比较高。可以按照行数切割，可以按照文件大小切割。18. read、readline 和 readlines 的区别?​ read() ： 一次性读取整个文件内容。推荐使用read(size)方法，size越大运行时间越长 readline() ：每次读取一行内容。内存不够时使用，一般不太用 readlines() ：一次性读取整个文件内容，并按行返回到list，方便我们遍历19. 文件操作时：xreadlines和readlines的区别？在Python 2里，文件对象有一个xreadlines()方法，它返回一个迭代器，一次读取文件的一行。这在for循环中尤其有用。 在Python 3里，xreadlines()方法不再可用了，可改为for line in a_file。20. 列举布尔值为False的常见值？0，空字符串，空元组，空列表，空字典21. 字符串、列表、元组、字典每个常用的5个方法？​ 字符串： find() replace() split() join() strip() 列表： append() remove() pop() reverse() sort() 元组： sort() tuple + index() count() 字典： items() keys() values() del() pop()22. lambda表达式格式及应用场景? 用lambda函数的好处?格式：lambda x: x+1 场景：配合map、reduce等高阶函数使用，或作为列表元素排序的key23. pass的作用？continue的作用? break的作用?pass的作用：空语句，什么也不做，占坑；保证结构的完整性，可以以后实现 continue的作用：跳出本次循环 break的作用：结束循环24. arg 和*kwarg作用？实现了不定长传参 其中args为可变长参数，允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple； *kw为关键字参数，允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。25. is和==的区别is对比内存地址是否一致； == 对比值是否相等26. 简述Python的深浅拷贝以及应用场景？浅拷贝指仅仅拷贝数据集合的第一层数据 深拷贝指拷贝数据集合的所有层 对于只有一层的数据集合来说深浅拷贝的意义是一样的，比如字符串，数字，还有仅仅一层的字典、列表、元祖等。 对于 数字和字符串 而言，赋值、浅拷贝和深拷贝无意义，因为其永远指向同一个内存地址。场景: 数据完整备份（隔离）27. 拷贝的注意点?(1)拷贝的对象是可变类型还是不可变类型 (2)拷贝后是否允许两个变量同时操控同一内存空间28. Python垃圾回收机制？Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。29. Python的可变类型和不可变类型？​ 不可变类型:数值类型（int和float）、字符串str、元组tuple 可变类型:列表list、字典dict、集合set30. 列举常见的内置函数？sum：对元素类型是数值的可迭代对象中的每个元素求和 int：根据传入的参数创建一个新的整数 range：根据传入的参数创建一个新的range对象 sorted：对可迭代对象进行排序，返回一个新的列表 help：返回对象的帮助信息 dir：返回对象或者当前作用域内的属性列表 type：返回对象的类型，或者根据传入的参数创建一个新的类型 len：返回对象的长度 format：格式化显示值","categories":[{"name":"python面试题","slug":"python面试题","permalink":"https://chenxl18.github.io/categories/python面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://chenxl18.github.io/tags/面试题/"},{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/tags/python/"},{"name":"16-30","slug":"16-30","permalink":"https://chenxl18.github.io/tags/16-30/"}]},{"title":"python面试题1-15","slug":"python/python面试题1-15","date":"2019-06-11T07:10:44.000Z","updated":"2019-06-11T07:15:36.829Z","comments":true,"path":"2019/06/11/python/python面试题1-15/","link":"","permalink":"https://chenxl18.github.io/2019/06/11/python/python面试题1-15/","excerpt":"","text":"Python和Java、PHP、C、C#、C++等其他语言的对比？​ （1）Java:优点----简单性、面向对象性、健壮性、跨品台性、高性能（自动垃圾回收机制）、多线程、动态性、安全性。 缺点----运行速度相对于C/C++有些缓慢了，这是机制原因导致的。 适用于----网页、企业级开发、普通应用软件、游戏后台。 （2）PHP:优点----跨平台，性能优越；语法简单，入门快；目前主流技术都支持；有比较完整的支持；有很多成熟的框架；PHP 5已经有成熟的面向对象体系，能够适应基本的面向对象要求；有成熟的社区来支持PHP的开发；目前已经很多大型应用都是使用PHP；有很多开源的框架或开源的系统可以使用；配置及部署相对简单一些。 缺点----多线程支持不太好，大多数时候我们只能简单的模拟去实现的；对语法不太严谨；PHP的解释运行机制繁琐。 适用于----主要是网络前端，用于生成网页。也可以整个web服务器都用php，比如很多论坛引擎。 （3）C:优点----简洁紧凑、灵活方便;运算符丰富;数据结构丰富;C是结构式语言;C语法限制不太严格，程序设计自由度大;C语言允许直接访问物理地址，可以直接对硬件进行操作;C语言程序生成代码质量高，程序执行效率高;C语言适用范围大，可移植性好;C语言有一个突出的优点就是适合于多种操作系统;有效地将一个较复杂的程序系统设计任务分解成许多易于控制和处理的子任务，便于开发和维护. 缺点----运算符和运算优先级过多，不便于记忆，语法定义不严格，编程自由度大，对新手不友好。 适用于----系统底层, 驱动, 嵌入式开发。 （4）C#:优点----相比java，有更先进的语法体系、强大的周边。 缺点----没有考虑代码量 （5）C++:优点----可扩展性、高效简洁快速、可移植性、面向对象的特性、强大而灵活的表达能力和不输于C的效率、支持硬件开发、程序模块间的关系更为简单，程序模块的独立性、数据的安全性就有了良好的保障、通过继承与多态性，可以大大提高程序的可重用性，使得软件的开发和维护都更为方便 适用于----游戏开发, 大规模, 高性能, 分布式要求的程序开发。 （6）Python:优点----简单、易学、免费开源、高层语言、可移植性、解释性、面向对象、可扩展性、可嵌入性、丰富的库、 缺点----运行速度慢，架构选择台繁琐 适用于----信息安全，大数据处理，数据可视化机器学习，物联网开发，各大软件的api，桌面应用，都需要python简述解释型和编译型编程语言？​ (1)编译型语言: 把源程序的每一条语句都编译成机器语言，并保存为二进制文件，运行时计算机就可以直接以机器语言来运行此程序 (2)解释型语言: 只是在程序执行时，才会一条一条的解释成机器语言给计算机执行​ 代码中要修改不可变数据会出现什么问题? 抛出什么异常？​ 代码会报错，抛出TypeError异常 可变数据类型：列表list和字典dict，集合set 不可变数据类型：基本数据类型（int, float, string）元组tupleprint 调用 Python 中底层的什么方法?​ print方法调用sys.stdout.write方法。就是往控制台打印字符串。简述你对 input()函数的理解?​ 在Python3中，input（）获取用户输入，不论用户输入什么，获取到的都是字符串类型。 在Python2中有raw_input() input(),raw_input()在Python3中的input()作用一样，input()输入什么数据类型，获取到的就是什么数据类型。Python解释器种类以及特点？​ Cpython:默认Cpython解释器，c语言实现 Ipython:基于Cpython之上的一个交互式解释器 Jpython:java实现，python代码会先转化成Java字节码 IronPython:C#实现 PyPy:python实现的python解释器pypy运行效率高Python2 中 range 和 xrange 的区别?​ 两者用法大致相同，不同的是range返回的结果是一个列表，而xrange的结果是一个生成器，前者是直接开辟一块内存空间来保持列表，后者是边循环边使用，只有在使用的时候才会开辟内存空间，所以当列表很长时，使用xrange性能比range好。位和字节的关系？​ 1 字节 = 8 位 1 Byte = 8 bit 1 B = 8 bb、B、KB、MB、GB 的关系？​ 1 GB = 1024 MB 1 MB = 1024 KB 1 KB = 1024 B 1 B = 8 bit请至少列举5个 PEP8 规范（越多越好）。​ （注：在python3中） 1.缩进: 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。 2.变量: 常量--大写加下划线 私有变量--小写和一个前导下划线--_value 内置变量--小写,两个前导下划线和两个后置下划线--__init__ 3.空行：顶级定义之间空2行, 方法定义之间空1行，顶级定义之间空两行, 比如函数或者类定义. 方法定义, 类定义与第一个方法之间, 都应该空一行. 函数或方法中, 某些地方要是你觉得合适, 就空一行. 4.空格：按照标准的排版规范来使用标点两边的空格，括号内不要有空格，按照标准的排版规范来使用标点两边的空格 5.导入格式：每个导入应该独占一行，导入总应该放在文件顶部, 位于模块注释和文档字符串之后, 模块全局变量和常量之前. 导入应该按照从最通用到最不通用的顺序分组: 标准库导入 第三方库导入 应用程序指定导入 每种分组中, 应该根据每个模块的完整包路径按字典序排序, 忽略大小写.python递归的最大层数？递归函数停止的条件?​ python递归的最大层数为：3221（根据查的百度：得到的最大数字在3925-3929之间浮动，这个是和计算机有关系的，不然也不会是一个浮动的数字了） 停止的条件： （1）判断递归的次数是否达到某一个限定值 （2）判断运算的结果是否达到某个范围等，根据设计的目的来选择ascii、unicode、utf-8、gbk 区别？​ 常见字符集：ASCII字符集、GB2312、Uniclde字符集 常见字符编码：UTF ASCII码:在计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit），有0和1两种状态，因此，8个二进制位可以组合出256种状态，这被称为字节（byte)。 GBK码:GBK编码是对GB2312的扩展，完全兼容GB2312。采用双字节编码方案，剔出xx7F码位，共23940个码位，共收录汉字和图形符号21886个。 Unicode码：有一种编码，将世界上所有的符号都纳入其中，每一种符号都给予独一无二的编码，那么乱码问题就不会存在了。因此，产生了Unicode编码，这是一种所有符号的编码。 UTF8字符编码：UTF8就是在互联网中使用最多的对Unicode的实现方式。字节码和机三元运算规则以及应用场景？器码的区别？​ 机器码是电脑CPU直接读取运行的机器指令，是电脑的CPU可直接解读的数据，运行速度最快，但是非常晦涩难懂，也比较难编写，一般从业人员接触不到； 字节码（Bytecode）是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。三元运算规则以及应用场景？i = A if condition else B，主要运用与结构简单的条件语句，这样可以节省代码列举 Python2和Python3的区别？​ *核心类区别：* 1.Python3对Unicode字符的原生支持。 Python2中使用ASCII码作为默认编码方式导致string有两种类型str和Unicode，Python3中只支Unicode类型的string。 2.Python3中采用的是绝对路径的方式进行import。 Python2中相对路径的import会导致标准库导入变得困难（同一目录下有file.py，如何同时导入这个文件和标准库文件file）。Python3中这一点被修改了，如果还需要导入同一目录的文件必须使用绝对路径，否则只能使用相关导入的方式来进行导入。 3.Python2中存在老式类和新式类，Python3中统一采用新式类。 新式类申明要求继承object，必须使用新式类应用多重继承。 4.Python3使用更加严格的缩进。 Python2的缩进机制中，一个tab和8个space是等价的，所以在缩进中同时允许tab和space在代码中共存。这种等价机制会导致部分IDE使用存在问题。Python3中1个tab只能找另一个tab代替，因此tab和space共存会导致报错：TabError：inconsistent use of tabs and spaces in indentaion. *废弃类差别：* 1. print 语句被 Python3 废弃，统一使用 print 函数 2. exec 语句被 python3 废弃，统一使用 exec 函数 3. execfile 语句被 Python3 废弃，推荐使用 exec(open(&quot;./filename&quot;).read()) 4. 不相等操作符&quot;&lt;&gt;&quot;被 Python3 废弃，统一使用&quot;!=&quot; 5. long 整数类型被 Python3 废弃，统一使用 int 6. xrange 函数被 Python3 废弃，统一使用 range,Python3 中 range 的机制也进行修改并提高了大数据集生成效率 7. Python3 中这些方法再不再返回 list 对象：dictionary 关联的 keys()、values()、items()，zip()，map()，filter()，但是可以通过 list 强行转换： mydict={&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3} mydict.keys() #&lt;built-in method keys of dict object at 0x000000000040B4C8&gt; list(mydict.keys()) #[&apos;a&apos;, &apos;c&apos;, &apos;b&apos;] 8. 迭代器 iterator 的 next()函数被 Python3 废弃，统一使用 next(iterator) 9. raw_input 函数被 Python3 废弃，统一使用 input 函数 10. 字典变量的 has_key 函数被 Python 废弃，统一使用 in 关键词 11. file 函数被 Python3 废弃，统一使用 open 来处理文件，可以通过 io.IOBase 检查文件类型 12. apply 函数被 Python3 废弃 13. 异常 StandardError 被 Python3 废弃，统一使用 Exception *修改类差异：* 1. 浮点数除法操作符“/”和“//”的区别： &quot;/&quot;： Python2 中若两个整形进行运算，结果为整形，但若其中有一个浮点数类型，则结果为浮点数。 python3为真除法，运算结果为float类型。 “//”： Python2 中返回小于除法运算结果的最大整数，从类型上讲，与&quot;/&quot;运算符返回类型逻辑一致。 Python3中与python2作用相同。 2. 异常抛出和捕捉机制的区别。 Python2 1. raise IOError, &quot;file error&quot; #抛出异常 2. except NameError, err: #捕捉异常 Python3 1. raise IOError(&quot;file error&quot;) #抛出异常 2. except NameError as err: #捕捉异常 3. for循环中变量值区别。 Python2 中，for循环会修改外部相同名称变量的值。 i=1 print(&apos;comprehension: &apos;, [i for i in range(5)]) print(&apos;after: i=.&apos;,i) #i=4 Python3中，for循环不会修改外部相同名称变量的值。 i=1 print(&apos;comprehension: &apos;, [i for i in range(5)]) print(&apos;after: i=.&apos;,i) #i=1 4. round函数返回值区别 Python2中，round函数返回float类型值。 isinstance(round(15.5),float) #True Python3中，round函数返回int类型值。 isinstance(round(15.5),int) #True 5. 比较操作符的区别。 Python2中任意两个对象都可以比较。 Python3中只有同一类型数据的对象才可以进行比较。","categories":[{"name":"python面试题","slug":"python面试题","permalink":"https://chenxl18.github.io/categories/python面试题/"}],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://chenxl18.github.io/tags/面试题/"},{"name":"python","slug":"python","permalink":"https://chenxl18.github.io/tags/python/"},{"name":"1-15","slug":"1-15","permalink":"https://chenxl18.github.io/tags/1-15/"}]},{"title":"HTTP协议","slug":"计算机网络/http协议","date":"2019-06-11T06:42:18.000Z","updated":"2019-07-06T09:42:08.767Z","comments":true,"path":"2019/06/11/计算机网络/http协议/","link":"","permalink":"https://chenxl18.github.io/2019/06/11/计算机网络/http协议/","excerpt":"","text":"HTTP协议-应用层问题在浏览器里输入https://www.baidu.com 一个回车后，浏览器里会显示百度的首页，请详细说下背后发送什么事情，越细致越好？ DNS域名解析：浏览器缓存、系统缓存、路由器、ISP的DNS服务器、根域名服务器。把域名转化成IP地址。 与IP地址对应的服务器建立TCP连接，经历三次握手：SYN，ACK、SYN，ACK 以get，post方式发送HTTP请求，get方式发送主机，用户代理，connection属性，cookie等 获得服务器的响应，显示页面 如果打开https://www.baidu.com网站，会有哪些问题，你如果排除？https协议的实现原理–》加密的原理http协议：超文本传输协议 特点：明文 Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 ​ site–&gt;站点–&gt;网站 website–&gt;网站 ​ page–&gt;页面 ​ URL：例如： http://hn.qq.com/a/20190118/002018.html ​ URL即统一资源定位符(Uniform Resource Locator)，用来唯一地标识万维网中的某一个文档。URL由协议、主机和端口(默认为80)以及文件名三部分构成。 https协议：加密的超文本传输协议 特点：密文 html语言 最常见的超文本格式是超文本标记语言 搭建一个属于自己的网站1.准备一个linux系统，确保可以上网123ifup ens33 #激活网卡ip add #查看ip地址ping www.baidu.com #测试你的linux机器是否可以和baidu通信 2.安装httpd 和 epel-release软件 httpd 提供web服务器的软件 ​ 命令：yum install httpd epel-release -y epel-release —&gt;这是一个软件源头的软件—》提供很多的软件可以下载 安装nginx web服务器软件 ​ 命令： yum install nginx -y ​ nginx是一个俄罗斯人开发的web服务器软件 补充 ​ mirror：镜像 另外一个地方和原来的服务器里的内容，一模一样。 源码下载，编译安装 1curl -O http://nginx.org/download/nginx-1.17.1.tar.gz 3.启动nginx软件 yum 安装的nginx启动 1234命令： service nginx start #开启nginx服务Redirecting to /bin/systemctl start nginx.service #表示成功启动命令： service nginx stop #停止nginx服务Redirecting to /bin/systemctl stop nginx.service #表示成功关闭 编译安装nginx启动 12cd /usr/local/nginx/sbin #进入安装目录./nginx #启动nginx 补充yum install lsof -y #安装lsof命令 lsof 软件是用来查看服务器里那个端口被那个程序使用了 1lsof -i:80 #查看80端口被那个程序使用了 端口号和程序之间的关系？ ​ 只有对外提供服务的程序会占用端口。 ​ 端口号—》窗口 ​ 1-1024 系统内置的端口–》很经典的使用端口 ​ 基本上都会被占了 ​ 1-65535 一共有这么多可以用的端口号 架构 ​ b/s架构 —》browser server –&gt;方便—》流行 ​ c/s架构 —-》client server —》socket 编程 启动和关闭httpd服务器 ​ service httpd start 开启httpd服务 ​ service httpd stop关闭httpd服务 4.关闭防火墙​ iptables -F 5.查看ip地址​ ip add 6.在windows系统里打开浏览器7.修改网站的首页12cd /usr/share/nginx/html/ #存放网页的目录ls #查看当前目录的文件及文件夹 ​ 访问window机器下的index.html ​ index.html 首页：网站访问的第一个页面 –》入口 ​ vim index.html ​ 编辑index.html页面 web服务器软件 nginx httpd ​ apache是httpd软件的名字 tomcat 修改nginx web服务的80端口—-改为8080端口 cd /etc/nginx/ ​ 进入文件修改配置文件 vim nginx.conf ​ 编辑配置文件 service nginx restart ​ Redirecting to /bin/systemctl restart nginx.service ​ 表示成功 修改配置文件后一定要重启一下服务 URL 域名： domain name ​ www.baidu.com –》ip ​ 域名：baidu.com ​ 主机名：www ​ www只是baidu.com这个域里的一个主机的名字 http协议 请求报文 —》request：即从客产端（浏览器）向Web服务器发送的请求报文。 GET 方法：去索取内容 POST 方法： 提交 GET和POST区别 GET POST 后退按钮/刷新 无害 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 书签 可收藏为书签 不可收藏为书签 缓存 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded或multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中。 参数不会保存在浏览器历史中。 对数据长度的限制 是的。当发送数据时，GET方法向URL 添加数据；URL的长度是受限制的（URL的最大长度是2048个字符）。 无限制。 对数据类型的限制 只允许ASCII字符。 没有限制。也允许二进制数据。 安全性 与POST相比，GET的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用GET！ POST比GET更安全，因为参数不会被保存在浏览器历史或web服务器日志中。 可见性 数据在URL中对所有人都是可见的。 数据不会显示在URL中。 重点的首部字段 host:访问的网址 accept： 接受的内容 accept-language：语言 user-agent： 客户机的浏览器和系统的信息 accept-encoding： 编码 connection: 是否是长连接 响应报文 –》response：从Web服务器到客户机（浏览器）的应答。 状态码 Connection: keep-alive Date: Fri, 18 Jan 2019 08:31:31 GMT Server: nginx/1.12.2（web服务器的软件名） type: set-cookie 版本 最新2.0版本 现在http协议的版本： ​ HTTP/1.1版本 长连接 keepalive_timeout 65； 持久性连接：在一个连接中，可以进行多次文档的请求和响应。 服务器在发送完响应后，并不立即释放连接，浏览 器可以使用该连接继续请求其他文档。连接保持的 时间可以由双方进行协商。 Connection: keep-alive 短连接 非持久性连接：即浏览器每请求一个Web文档，就创建一个新的连接，当文档传输完毕后，连接就立刻被释放 无状态性：是指同一个客户端（浏览器）第二次访问同个Web服务器上的页面时，服务器无法知道这个客户曾经访问过。HTTP的无状态性简化了服务器的设计，使其更容易支持大量并发的HTTP请求。（主要为了支持大并发） 状态码 200：访问成功，服务器正常响应请求 301：网页位置发生变化 304：Not Modified —》按CTRL+F5 强制刷新网页内容，不从缓存里读取网页内容 403：服务器里的网页设置了权限不让用户访问 Forbidden 404：网页不存在 5**：服务器的内部问题 HTTP 500：服务器遇到错误，无法完成请求 HTTP 502：网关错误 Error 501：未实现 cookie和session 用来保存客户的信息（用户名，密码、购物车的信息） cookie：数据存储在浏览器端（客户端） https://baijiahao.baidu.com/s?id=1612804856429135825&amp;wfr=spider&amp;for=pc 方便与JavaScript交换数据 方便获取用户信息 session：（会话）数据存储在服务器 高效、安全、不依赖浏览器端环境、服务器端会为每一个用户用一个ID来标识 一次连接就会产生一个session 代理 http 代理 proxy server 代理服务器：中间的一个服务器，代理大家去上网 http://http.taiyangruanjian.com/newrecharge/ user-agent：用户代理–》浏览器 浏览器代人去访问了服务器 http2.0和http1.1的差异 Http和Https的区别（面试常考题） https://blog.csdn.net/qq_38289815/article/details/80969419?tdsourcetag=s_pctim_aiomsg CDN CDN的全称是Content Delivery Network，即内容分发网络 CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 精准调度 秒级加速 降低访问 协议 应用层：ftp、http、https、rsync http:80端口 https:443端口 提供web服务的软件都能读懂http协议： 常见web服务器软件：nginx、Apache、Tomcat、IIS、Django、flask 常见浏览器：chrome、Firefox、curl 编译安装nginx的配置文件各项配置详细解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#user nobody; #以哪个用户身份后动nginx进程--》worker进程worker_processes 1; #启动动1个工作进程，这个参数和CPU核心数量一致#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024; #启动1024个线程去接待用户的请求&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #超时时间65s #gzip on; server &#123; listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125;&#125; minme.types：规定哪些程序对应哪些文件类型—&gt;后缀名 nginx可以调用对应的程序去打开 1/usr/local/nginx/conf/minme.types","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://chenxl18.github.io/categories/计算机网络/"}],"tags":[{"name":"http协议","slug":"http协议","permalink":"https://chenxl18.github.io/tags/http协议/"},{"name":"nginx配置","slug":"nginx配置","permalink":"https://chenxl18.github.io/tags/nginx配置/"},{"name":"抓包工具的使用","slug":"抓包工具的使用","permalink":"https://chenxl18.github.io/tags/抓包工具的使用/"}]},{"title":"blog添加搜索功能","slug":"blog添加搜索功能","date":"2019-05-30T06:19:33.000Z","updated":"2019-07-08T10:28:08.439Z","comments":true,"path":"2019/05/30/blog添加搜索功能/","link":"","permalink":"https://chenxl18.github.io/2019/05/30/blog添加搜索功能/","excerpt":"添加搜索功能插件安装直接在自己的博客文件夹下（我的是blog）点击鼠标右键选择Git Bash Here 1npm install hexo-generator-searchdb --save","text":"添加搜索功能插件安装直接在自己的博客文件夹下（我的是blog）点击鼠标右键选择Git Bash Here 1npm install hexo-generator-searchdb --save 修改站点配置文件 路径：blog/_config.yml，找到Extensions，在下面插入如下代码 12345search: path: search.xml field: post format: html limit: 10000 注：每个冒号后面都有一个空格 修改主题配置文件 路径：blog/themes/next/_config.yml，找到local_search，把false改为ture 12local_search: enable: false 改为： 12local_search: enable: true","categories":[{"name":"Hexo+Next GitPages个人博客","slug":"Hexo-Next-GitPages个人博客","permalink":"https://chenxl18.github.io/categories/Hexo-Next-GitPages个人博客/"}],"tags":[{"name":"搜索功能","slug":"搜索功能","permalink":"https://chenxl18.github.io/tags/搜索功能/"},{"name":"hexo","slug":"hexo","permalink":"https://chenxl18.github.io/tags/hexo/"}]},{"title":"MySQL的使用","slug":"mysql/MySQL的使用","date":"2019-05-28T13:16:29.000Z","updated":"2019-06-02T05:39:33.067Z","comments":true,"path":"2019/05/28/mysql/MySQL的使用/","link":"","permalink":"https://chenxl18.github.io/2019/05/28/mysql/MySQL的使用/","excerpt":"","text":"MySQL的使用技巧如果不知道pstree命令可以使用 yum provides pstree 12[root@mysql-2 ~]# yum provides pstree[root@mysql-2 ~]# yum install psmisc -y https://wx4.sinaimg.cn/mw690/006BsDmEgy1g3mr7gz0pij30jf09a3yq.jpg pstree命令：用来查看进程树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[root@mysql-2 ~]# pstree -p # 查看进程树结构，并且显示pid号systemd(1)─┬─NetworkManager(5474)─┬─&#123;NetworkManager&#125;(5518) │ └─&#123;NetworkManager&#125;(5521) ├─VGAuthService(5444) ├─auditd(5422)───&#123;auditd&#125;(5423) ├─chronyd(5457) ├─crond(5478) ├─dbus-daemon(5455) ├─irqbalance(5449) ├─login(5481)───bash(8235) ├─lvmetad(2799) ├─master(6082)─┬─pickup(15979) │ └─qmgr(6099) ├─mysqld_safe(5943)───mysqld(6034)─┬─&#123;mysqld&#125;(6848) │ ├─&#123;mysqld&#125;(6962) │ ├─&#123;mysqld&#125;(6963) │ ├─&#123;mysqld&#125;(6964) │ ├─&#123;mysqld&#125;(6965) │ ├─&#123;mysqld&#125;(6966) │ ├─&#123;mysqld&#125;(6967) │ ├─&#123;mysqld&#125;(6968) │ ├─&#123;mysqld&#125;(6969) │ ├─&#123;mysqld&#125;(6970) │ ├─&#123;mysqld&#125;(6971) │ ├─&#123;mysqld&#125;(6973) │ ├─&#123;mysqld&#125;(7453) │ ├─&#123;mysqld&#125;(7454) │ ├─&#123;mysqld&#125;(7455) │ ├─&#123;mysqld&#125;(7456) │ ├─&#123;mysqld&#125;(7457) │ ├─&#123;mysqld&#125;(7464) │ ├─&#123;mysqld&#125;(7465) │ ├─&#123;mysqld&#125;(7466) │ ├─&#123;mysqld&#125;(7467) │ ├─&#123;mysqld&#125;(7468) │ ├─&#123;mysqld&#125;(7469) │ ├─&#123;mysqld&#125;(7470) │ ├─&#123;mysqld&#125;(7690) │ ├─&#123;mysqld&#125;(7691) │ ├─&#123;mysqld&#125;(15744) │ ├─&#123;mysqld&#125;(15790) │ ├─&#123;mysqld&#125;(16005) │ ├─&#123;mysqld&#125;(16006) │ └─&#123;mysqld&#125;(16007) ├─polkitd(5447)─┬─&#123;polkitd&#125;(5458) │ ├─&#123;polkitd&#125;(5473) │ ├─&#123;polkitd&#125;(5503) │ ├─&#123;polkitd&#125;(5504) │ ├─&#123;polkitd&#125;(5505) │ └─&#123;polkitd&#125;(5506) ├─rsyslogd(5784)─┬─&#123;rsyslogd&#125;(5892) │ └─&#123;rsyslogd&#125;(5901) ├─sshd(5777)─┬─sshd(15703)───bash(15705)───mysql(15789) │ ├─sshd(15750)───bash(15752) │ └─sshd(15977)───bash(15980)───pstree(16054) ├─systemd-journal(2780) ├─systemd-logind(5475) ├─systemd-udevd(2807) ├─tuned(5779)─┬─&#123;tuned&#125;(7331) │ ├─&#123;tuned&#125;(7332) │ ├─&#123;tuned&#125;(7376) │ └─&#123;tuned&#125;(7593) └─vmtoolsd(5454)───&#123;vmtoolsd&#125;(5511) 查看MySQL的进程 12345[root@mysql-2 ~]# ps aux|grep mysqlroot 7321 0.0 0.0 11816 1620 ? S 3月10 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 7417 0.0 9.9 1571636 185360 ? Sl 3月10 0:16 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pidroot 19744 0.0 0.0 112728 988 pts/2 S+ 10:10 0:00 grep --color=auto mysql[root@mysql-2 ~]# mysqld_safe和mysqld进程，他们之间的关系是什么？答：mysqld_safe是mysqld进程的父进程mysql数据库是一个进程里启动很多线程的程序。只要有人远程连接到mysqld进程，就会产生一个线程去接待。完成相关的数据库的操作。 进程里包含很多线程进程占用的资源多（内存、cpu等），线程占用的资源少，但是作用都差不多，都可以用来处理操作。1个进程里可以启用很多额线程。 当mysqld进程没有启动的时候，是不能连接到mysql数据库里的 1234[root@mysql-2 support-files]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)[root@mysql-2 support-files]# 连接mysql的2种方式：1.通过文件socket：同一台电脑里的不同的进程之间，可以使用文件socket来通信。 1234[root@mysql-2 support-files]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2) --》说明文件socket 不存在[root@mysql-2 support-files]# -S 指定mysql的socket文件在路径 123456789101112131415[root@mysql-2 tmp]# mysql -S /tmp/mysql.sock -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 4Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 修改mysql的socket文件的路径my.cnf 的作用是当mysqld进程启动的时候，会读取my.cnf文件里的配置，然后加载运行，启动相应的功能。关于定制mysql的配置，有2个地方：1.在cmake编译的时候，指定配置 1234567[root@changsha-tianlong-db-2 mysql-5.7.25]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ #mysql安装目录-DMYSQL_DATADIR=/data/mysql \\ #数据库文件目录-DSYSCONFDIR=/etc \\ #配置文件目录-DMYSQL_USER=mysql \\ #运行mysql进行的用户，如果没有需要提前添加用户和用户组-DDEFAULT_CHARSET=utf8 \\ #默认字符集-DDEFAULT_COLLATION=utf8_general_ci \\ #默认校对规则-DWITH_BOOST=boost #boost库，带boost的源码包只需要这样即可，不带boost源码包需要指明boost目录 2.在配置文件my.cnf里指定 123456789101112[root@mysql-2 tmp]# vim /etc/my.cnf[mysqld_safe]log-error=/var/log/mysql/mysql.log#这是指定mysql的日志文件的路径#指定mysqld_safe进程的配置#需要在mkdir /var/log/mysql 目录，然后使用命令chown mysql:mysql /var/log/mysql#因为mysql进程需要往/var/log/mysql目录里写东西，需要权限，不然不能往目录下写日志[mysqld]socket=/data/mysql/mysql.sock#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置 授权给mysql用户 1234[root@mysql-2 log]# cd /var/log[root@mysql-2 log]# mkdir mysql[root@mysql-2 log]# chown mysql:mysql mysql[root@mysql-2 log]# 重新启动mysqld服务 123456789[root@mysql-2 tmp]# service mysqld restart 重新启动mysqld服务Shutting down MySQL. SUCCESS! Starting MySQL. SUCCESS! [root@mysql-2 tmp]# ps aux|grep mysqlroot 22682 0.6 0.0 11812 1616 pts/1 S 10:57 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 22795 6.0 9.4 1571372 176028 pts/1 Sl 10:57 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pid --socket=/data/mysql/mysql.sockroot 22831 0.0 0.0 112724 984 pts/1 S+ 10:57 0:00 grep --color=auto mysql[root@mysql-2 tmp]# 注释：–basedir=/usr/local/mysql #指定的mysql的安装路径–datadir=/data/mysql #数据存放的目录–plugin-dir=/usr/local/mysql/lib/plugin #插件的目录–user=mysql #使用mysql这个用户启动的–log-error=/var/log/mysql/mysql.log # 日志文件的路径–pid-file=/data/mysql/mysql-2.pid #mysql的进程的pid存放的文件，此文件是方便关闭mysql的时候，去kill 进程–socket=/data/mysql/mysql.sock #指定的socket文件的路径修改了socket文件的路径后，使用mysql命令连接到mysql数据库里，需要指定socket文件的路径 123456789[root@mysql-2 tmp]# ps aux|grep mysqlroot 22682 0.6 0.0 11812 1616 pts/1 S 10:57 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 22795 6.0 9.4 1571372 176028 pts/1 Sl 10:57 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/var/log/mysql/mysql.log --pid-file=/data/mysql/mysql-2.pid --socket=/data/mysql/mysql.sockroot 22831 0.0 0.0 112724 984 pts/1 S+ 10:57 0:00 grep --color=auto mysql[root@mysql-2 tmp]# cat /data/mysql/mysql-2.pid 22795[root@mysql-2 tmp]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2) ‘/tmp/mysql.sock’ (2) –》默认会到/tmp目录下查找使用-S 选项指定 1[root@mysql-2 tmp]# mysql -S /data/mysql/mysql.sock -uroot -p'Sanchuang123#' #指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。2.通过网络socketip:port 192.168.0.133:3306 –&gt;网络socket可以实现不同的计算机之间的进程之间的通信。 可以通过-h 192.168.0.133 指定访问的数据库服务器的ip地址，使用网络socket的方式访问-h host 123456789101112131415[root@mysql-2 mysql]# mysql -h 192.168.0.133 -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 12Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 什么是socket？网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。 socket 可以实现不同的进程之间的通信，是不同进程之间通信的一种方式。 12345678910111213141516[root@mysql-2 support-files]# yum install net-tools -y 安装net-tools工具得到netstat命令[root@mysql-2 support-files]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 12290/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6561/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 6861/master tcp 0 0 192.168.0.133:22 192.168.0.188:51832 ESTABLISHED 19720/sshd: root@pt tcp 0 0 192.168.0.133:22 192.168.0.188:51853 ESTABLISHED 19806/sshd: root@pt tcp 0 52 192.168.0.133:22 192.168.0.188:50459 ESTABLISHED 18112/sshd: root@pt tcp6 0 0 :::80 :::* LISTEN 12290/nginx: master tcp6 0 0 :::22 :::* LISTEN 6561/sshd tcp6 0 0 ::1:25 :::* LISTEN 6861/master udp 0 0 127.0.0.1:323 0.0.0.0:* 6270/chronyd udp6 0 0 ::1:323 :::* 6270/chronyd [root@mysql-2 support-files]# 注释：0.0.0.0:80 —–&gt;0.0.0.0表达这台本机上所有的IP地址 网络socket的使用 使用SQLyog远程连接到MySQL 1.授权一个用户能远程登录 1234mysql&gt; grant ALL on *.* to 'cali'@'%' identified by 'Sanchuang123#';Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; 授权cali这个用户可以从任何机器上远程连接过来，使用密码Sanchuang123# 可以对mysql数据库的所有的数据库进行操作。 使用SQLyog远程连接 MySQL里破解密码 第1步：停止MySQL进程的运行 123[root@mysql-2 mysql]# service mysqld stopShutting down MySQL.. SUCCESS! [root@mysql-2 mysql]# 第2步：修改配置文件 1234[root@mysql mysql]# vim /etc/my.cnfuser=mysql #指定启动MySQL进程的用户skip-grant-tables #跳过密码验证#validate-password=off #需要禁用密码复杂性策略 第3步：启动MySQL进程 12[root@mysql mysql]# service mysqld start 启动MySQL进程Starting MySQL. SUCCESS! 第4步：登录MySQL，不接密码 1234567891011121314151617181920212223242526[root@mysql-2 mysql]# mysql -S /data/mysql/mysql.sock -uroot -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; set password='123456'; ----》会报错ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statementmysql&gt; flush privileges; ----》刷新权限（会加载原来没有加载的权限表）Query OK, 0 rows affected (0.01 sec)mysql&gt; set password='Sanchuang1234#'; ----》会报错ERROR 1133 (42000): Can't find any matching row in the user tablemysql&gt; set password for 'root'@'localhost' = 'Sanchuang1234#'; ----》修改密码Query OK, 0 rows affected (0.00 sec)mysql&gt; quitBye 第5步：重新修改mysql的配置文件 1234[mysqld]socket=/data/mysql/mysql.sock#user=mysql --》注释掉#skip-grant-tables --》注释掉 *第6步：刷新服务 * 1234[root@mysql-2 mysql]# service mysqld restart #重新刷新服务Shutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS! [root@mysql-2 mysql]# 第7步：验证修改密码是否成功 1[root@mysql-2 mysql]# mysql -S /data/mysql/mysql.sock -uroot -p'Sanchuang1234#' my.cnf配置文件部分配置使用介绍 12345678910111213[mysqld]port = 3309 #修改端口号max_connections = 330 #最大并发连接数 ，增大该值需要相应增加允许打开的文件描述符数 max_connect_errors = 100 #如果某个用户发起的连接error超过该数值，则该用户的下次连接将被阻塞，open_files_limit = 8192 #设置打开文件的句柄数量，在系统里面可以用ulimit –a 查看，可以使用ulimit -n 65535修改，同时添加到/etc/rc.local里innodb_buffer_pool_size = 1G #指定innodb存储引擎的缓冲池的大小。--》从内存当前拿出多少空间来做缓存使用[mysql] ----&gt;专门针对mysql这个命令的配置auto-rehash #可以在命令可以使用tab键补齐prompt=\\\\u@\\\\d \\\\R:\\\\m mysql&gt; #在Mysql命令显示用户名和数据库名字、时间[mysqld_safe]log-error=/var/log/mysql/mysql.log 基本的MySQL的操作查看MySQL数据库系统里有哪些库 123456789101112[root@mysql-2 mysql]# mysql -uroot -p'Sanchuang1234#' -S /data/mysql/mysql.sockmysql&gt; show databases; #查看MySQL数据库系统里有哪些库+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 创建lizengzhi数据库 1234567891011121314mysql&gt; create database lizengzhi ; #创建lizengzhi数据库Query OK, 1 row affected (0.00 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || lizengzhi || mysql || performance_schema || sys |+--------------------+5 rows in set (0.00 sec) 切换当前使用的数据库到lizengzhi 123456789mysql&gt; use lizengzhi; #切换当前使用的数据库到lizengzhiDatabase changedmysql&gt; select database(); #查询当前在哪个数据库里+------------+| database() |+------------+| lizengzhi |+------------+1 row in set (0.00 sec) linux内核对一个进程可以打开多少个文件进行了限制，默认情况下一个进程只能打开1024个文件 文件描述符：进程对打开的文件进行编号，这个编号就是文件描述符。 12345[root@mysql-2 mysql]# ulimit -aopen files (-n) 1024 #打开的文件数量[root@mysql-2 mysql]# ulimit -n 655350 #临时修改一个进程可以打开的文件数量[root@mysql-2 mysql]# ulimit -n 1000000[root@mysql-2 mysql]# 查看mysql里默认的最大并发数是多少 1234567root@(none) 15:37 mysql&gt;show variables like 'max_connections'; #查看max_connections这个变量+-----------------+-------+| Variable_name | Value |+-----------------+-------+| max_connections | 151 |+-----------------+-------+1 row in set (0.01 sec) 看当前mysql里的所有的变量 1root@(none) 15:39 mysql&gt;show variables ; #查看当前mysql里的所有的变量 查看mysql的端口号 1234567root@(none) 15:39 mysql&gt;show variables like 'port';+---------------+-------+| Variable_name | Value |+---------------+-------+| port | 3309 |+---------------+-------+1 row in set (0.05 sec) 查看打开文件的最大数 1234567root@(none) 15:42 mysql&gt;show variables like 'open%';+------------------+-------+| Variable_name | Value |+------------------+-------+| open_files_limit | 5000 |+------------------+-------+1 row in set (0.00 sec) 查看内存的使用情况 1234[root@mysql-2 boot]# free -m #查看内存的使用情况（以M为单位显示大小） total used free shared buff/cache availableMem: 1819 369 210 9 1240 1210Swap: 2047 0 2047 查看mysql缓冲池大小 1234567root@(none) 15:42 mysql&gt;show variables like 'innodb_buffer_pool_size';+-------------------------+-----------+| Variable_name | Value |+-------------------------+-----------+| innodb_buffer_pool_size | 134217728 |+-------------------------+-----------+1 row in set (0.00 sec) 如何让linux系统开机执行 ulimit -n 655350 ？答案： 将这条命令写入/etc/rc.local文件 123[root@mysql-2 boot]# vim /etc/rc.local ulimit -n 655350 --》在文件的末尾添加[root@mysql-2 boot]# chmod +x /etc/rc.d/rc.local #需要授予可执行权限，不然不会生效 如果今后有需要开机执行某个命令的需求，建议将命令放到/etc/rc.local里 mysqld服务启动不起来？如何排除? 123[root@mysql-2 boot]# service mysqld restartShutting down MySQL.... SUCCESS! Starting MySQL... ERROR! The server quit without updating PID file (/data/mysql/mysql-2.pid). 排错主要看错误提醒和日志文件 1[root@mysql-2 boot]# cat /var/log/mysql/mysql.log 2019-03-11T08:18:43.399355Z 0 [ERROR] unknown option ‘–auto-rehash’ –》不知道的选项，只有配置文件里有选项–》配置文件里的配置有问题2019-03-11T08:18:43.399445Z 0 [ERROR] Aborting [ERROR] 错误信息 –》非常重视[Note] 普通的信息 1234567891011[mysqld]socket=/data/mysql/mysql.sockport = 3309open_files_limit = 8192innodb_buffer_pool_size = 256Mauto-rehash ##存放的位置不对prompt=\\\\u@\\\\d \\\\R:\\\\m mysql&gt; #存放的位置不对#user=mysql#skip-grant-tables#指定mysqld的socket文件所在的路径，/data/mysql目录一定要先存在。#指定mysqld进程的配置 修改配置文件 123[mysql] ---》是在mysql进程里的配置，不是mysqld进程的配置auto-rehashprompt=\\\\u@\\\\d \\\\R:\\\\m mysql&gt; 修改了配置文件，一定要刷新服务 12[root@mysql-2 boot]# service mysqld startStarting MySQL. SUCCESS! 使用SQLyog来建表建库，认识表和库是什么？库里存放表，表里存放一条一条的信息","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chenxl18.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chenxl18.github.io/tags/MySQL/"},{"name":"安装","slug":"安装","permalink":"https://chenxl18.github.io/tags/安装/"}]},{"title":"MySQL的各种安装方式","slug":"mysql/MySQL的各种安装方式","date":"2019-05-28T03:04:45.000Z","updated":"2019-06-02T05:38:36.159Z","comments":true,"path":"2019/05/28/mysql/MySQL的各种安装方式/","link":"","permalink":"https://chenxl18.github.io/2019/05/28/mysql/MySQL的各种安装方式/","excerpt":"","text":"MySQL是什么？ 123456MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL是一个软件，用来存放数据。用它来存放数据，特别方便，查找和存储数据都非常方便。MySQL 是一个中小型数据库。MySQL是开源数据库。不是免费的数据库软件。有开源版本的数据库，这个是不要钱。MySQL 的开源版本不要钱。企业版都是需要购买。 哪些地方需要使用数据库？ 12银行、股市、学校、公交车、小区、游戏、网站、快递、导航、税务等只要和钱有关的地方就有数据库 安装MySQL安装linux系统centos7 1810.iso数据库服务器是公司的核心服务器–&gt;配置必须要 下载MySQL软件官方网站https://www.mysql.com/The world’s most popular open source database。世界上最流行的开源数据库。Oracle MySQL Cloud Service (commercial) 云服务器版本MySQL Enterprise Edition (commercial) 企业版MySQL Cluster CGE (commercial) 集群版本MySQL Community Edition (GPL) 社区版 –》免费 MySQL的版本：8版本–》 8.0.155版本–》 5.7MySQL Community Server 5.7.25 安装rpm包方式安装500M–》linux系统里 1[root@localhost ~]# yum install lrzsz -y #解决传输文件的问题 windows--》linux传文件 安装步骤 解压安装包1[root@localhost ~]# tar xf mysql-5.7.25-1.el7.x86_64.rpm-bundle.tar 安装1[root@localhost ~]# yum install mysql-community-* mysql-community-server 是MySQL提供服务功能的软件包mysql-community-client 客户端管理需要的工具mysql-community-libs 库文件 librarymysql-community-devel 开发工具和接口程序 developmentmysql-community-test 测试环境软件mysql-community-embedded 嵌入式相关的软件 启动MySQL程序​ 12[root@localhost ~]# service mysqld startRedirecting to /bin/systemctl start mysqld.service mysql daemon 守护进程 –》mysqld守护进程：这个程序是一直运行的，不是运行一下，马上就关闭。因为有人会随时来访问，都可以访问这个进程。 12345[root@localhost ~]# service mysqld status #参看mysql的状态[root@localhost ~]# ps aux|grep mysqld #查看mysqld的进程是否存在mysql 27129 0.3 4.8 1119708 185728 ? Sl 15:13 0:01 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pidroot 27172 0.0 0.0 112724 984 pts/0 S+ 15:19 0:00 grep --color=auto mysqld[root@localhost ~]# mysql会开发3306端口 使用lsof命令查看端口号是否被占用 12345[root@localhost ~]# yum install lsof -y[root@localhost ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 27129 mysql 22u IPv6 76271 0t0 TCP *:mysql (LISTEN)[root@localhost ~]# 如何知道本机里开发了哪些端口？ 1234567891011121314[root@localhost ~]# netstat -anplutActive Internet connections (servers and established)Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 6085/sshd tcp 0 0 127.0.0.1:25 0.0.0.0:* LISTEN 6307/master tcp 0 0 192.168.0.37:22 192.168.0.11:57980 ESTABLISHED 14958/sshd: root@pt tcp 0 0 192.168.0.37:22 192.168.0.11:50402 ESTABLISHED 15518/sshd: root@pt tcp 0 52 192.168.0.37:22 192.168.0.11:53222 ESTABLISHED 15890/sshd: root@pt tcp6 0 0 :::3306 :::* LISTEN 15798/mysqld tcp6 0 0 :::22 :::* LISTEN 6085/sshd tcp6 0 0 ::1:25 :::* LISTEN 6307/master udp 0 0 0.0.0.0:68 0.0.0.0:* 15443/dhclient udp 0 0 127.0.0.1:323 0.0.0.0:* 5501/chronyd udp6 0 0 ::1:323 :::* 5501/chronyd ip：端口号 –》网络socket 槽0.0.0.0 本机上任意的ip地址。127.0.0.1 本地的回环测试接口，只能本机自己访问，别的机器不能访问:::3306 本机上任意的ip地址上开启3306端口 –》ipv6 查看别的机器开启了哪些端口？扫描工具nmap 1234567891011[root@localhost ~]# yum install nmap -y #安装nmap软件[root@localhost ~]# nmap 192.168.0.37Starting Nmap 6.40 ( http://nmap.org ) at 2019-05-06 16:39 CSTNmap scan report for 192.168.0.37Host is up (0.000014s latency).Not shown: 998 closed portsPORT STATE SERVICE22/tcp open ssh3306/tcp open mysqlNmap done: 1 IP address (1 host up) scanned in 0.30 seconds 登录MySQL服务器mysql命令是用来登录mysql服务器的客户端工具 1234[root@localhost ~]# mysql -u root -pEnter password:ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)[root@localhost ~]# 使用密码登录MySQL数据库 1[root@localhost log]# mysql -uroot -p'Sanchuang123xl#' 解释-uroot 指定登录mysql的用户是root user-p’Sanchuang123xl#’ 指定登录的密码 password需要去查看日志，得到临时密码 1234567[root@localhost log]# cd /var/logmysqld.log mysql的日志文件[root@localhost log]# cat mysqld.log |grep \"tem\"2019-05-06T07:51:53.607329Z 0 [Warning] InnoDB: Creating foreign key constraint system tables.2019-05-06T07:51:53.630880Z 1 [Note] A temporary password is generated for root@localhost: =%rIObuds8p&amp;2019-05-06T07:51:57.783188Z 0 [Note] InnoDB: Creating shared tablespace for temporary tables[root@localhost log]# =%rIObuds8p&amp; 是MySQL的临时密码 使用临时密码登录mysql服务器 12345678910111213141516[root@localhost lianxi]# mysql -u root -p'=%rIObuds8p&amp;'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.26Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 重新设置密码第一种方法： 12mysql&gt; set password='Root123#';Query OK, 0 rows affected (0.01 sec) 第二种方法： 1mysql&gt; alter user 'root'@'localhost' identified by 'Root123#'; 显示查看mysql里有多少个数据库 12345678910mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+4 rows in set (0.01 sec) 退出MySQL1mysql&gt; exit mysql服务安装好后，会自动设置开机启动 如何查看本机里哪些服务是开机启动的？ 123456789[root@localhost ~]# systemctl list-unit-files #查看本机开机的时候，哪些服务是启动的disabled #不启动enabled #启动[root@localhost ~]# systemctl disable firewalld #禁用firewalld服务，开机不启动[root@localhost ~]# systemctl enable firewalld #开机启动firewalld服务[root@localhost ~]# systemctl list-unit-files|grep \"mysqld\"mysqld.service enabled #表示mysql是开机启动mysqld@.service disabled[root@localhost ~]# windows的客户端远程连接linux里的mysql的软件 1.SQLyog –》第3方公司产品 2.workbench –》mysql官方自己出品关闭防火墙软件 12[root@localhost ~]# service firewalld stop Redirecting to /bin/systemctl stop firewalld.service 查看防火墙规则 12345678910[root@localhost ~]# iptables -L Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@localhost ~]# 使用SQLyog第1次远程连接的时候，会出现不允许连接，是因为mysql为了安全的考虑，不允许远程登录如果需要远程登录，就需要考虑去授权一个用户能远程登录到mysql，如何授权？ 授权root用户使用密码远程登录1234[root@localhost ~]# mysql -uroot -p'Root123#' mysql&gt; grant ALL on *.* to 'root'@'%' identified by 'Sanchuang123xl#'; 授权root用户可以从任何机器登录到mysql服务器上使用的密码是Sanchuang123xl#Query OK, 0 rows affected, 1 warning (0.05 sec) grant 是数据库里的授权命令ALL 是所有的权限（select、update、delete、insert等）On . 在所有的库所有的表上 mysql.user 表示mysql数据库里的user表‘root’@’%’ 这表示一个用户名是root可以从任何地方登录identified by ‘Sanchuang123#’ 指定密码为Sanchuang123# 源码编译安装—&gt;企业里使用最多方式1.可以开启很多功能2.可以指定安装路径 –》最大的好处因为MySQL需要存放数据，需要大量的磁盘空间，企业里会单独给MySQL一个存放数据的地方。 需要一台干净的linux系统修改主机名为MySQL2临时修改主机名 123[root@localhost ~]# hostname mysql-2 [root@localhost ~]# su - root 切换用户到root上一次登录：五 3月 8 09:56:29 CST 2019从 192.168.0.188pts/0 上 永久修改主机名 1234[root@mysql-2 ~]# vi /etc/hostname [root@mysql-2 ~]# vi /etc/hostname [root@mysql-2 ~]# cat /etc/hostname mysql-2 需要mysql的源码包上传源码包到linux系统mysql-boost-5.7.25.tar和mysql-5.7.25.tar.gz的差异percona-xtrabackup、json等软件需要使用boost库，如果你安装的MySQL需要对很多软件进行支持，建议安装ysql-boost-5.7.25.tar 12[root@changsha-tianlong-db-2 ~]# yum install lrzsz -y[root@changsha-tianlong-db-2 ~]# rz 查看官方的安装文档https://dev.mysql.com/doc/refman/5.7/en/source-installation.html也可以百度 mysql 5.7.25编译安装https://www.jianshu.com/p/90769a797b88 解压1[root@changsha-tianlong-db-2 ~]# tar xf mysql-boost-5.7.25.tar.gz cmake 是一个编译工具和 gcc一样 安装依赖关系包1[root@changsha-tianlong-db-2 mysql-5.7.25]# yum install cmake ncurses-devel gcc gcc-c++ -y #安装依赖关系包 创建用户和组1[root@changsha-tianlong-db-2 network-scripts]# useradd -r -s /sbin/nologin mysql -r 创建系统用户（不会创建家目录），一般会修改shell为/sbin/nologin-M 创建用户不建立家目录 123[root@changsha-tianlong-db-2 network-scripts]# id mysqluid=997(mysql) gid=995(mysql) 组=995(mysql)[root@changsha-tianlong-db-2 network-scripts]# 进入解压后的目录，开始编译前的配置12345678910[root@changsha-tianlong-db-2 ~]# cd mysql-5.7.25/[root@changsha-tianlong-db-2 mysql-5.7.25]#[root@changsha-tianlong-db-2 mysql-5.7.25]# mkdir /data/mysql -p[root@changsha-tianlong-db-2 mysql-5.7.25]#cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DMYSQL_DATADIR=/data/mysql \\-DSYSCONFDIR=/etc \\-DMYSQL_USER=mysql \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DWITH_BOOST=boost 对上面的命令进行说明：[root@changsha-tianlong-db-2 mysql-5.7.25]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ #mysql安装目录-DMYSQL_DATADIR=/data/mysql \\ #数据库文件目录-DSYSCONFDIR=/etc \\ #配置文件目录-DMYSQL_USER=mysql \\ #运行mysql进行的用户，如果没有需要提前添加用户和用户组-DDEFAULT_CHARSET=utf8 \\ #默认字符集-DDEFAULT_COLLATION=utf8_general_ci \\ #默认校对规则-DWITH_BOOST=boost #boost库，带boost的源码包只需要这样即可，不带boost源码包需要指明boost目录 编译和编译安装12[root@changsha-tianlong-db-2 mysql-5.7.25]# make -j 2 #启用多进程去编译 -j 2 启用2个进程同时进行，目的是为了加快速度[root@changsha-tianlong-db-2 mysql-5.7.25]#make install #安装 启动MySQL12345[root@changsha-tianlong-db-2 mysql-5.7.25]# cd /usr/local/mysql/ 进入安装目录[root@changsha-tianlong-db-2 mysql]# lsbin COPYING-test include man README shareCOPYING docs lib mysql-test README-test support-files[root@changsha-tianlong-db-2 mysql]# 对mysql的配置文件进行备份 123[root@changsha-tianlong-db-2 mysql]# cp /etc/my.cnf /root #备份[root@changsha-tianlong-db-2 mysql]# &gt;/etc/my.cnf #清空，因为这个文件是mariadb的[root@changsha-tianlong-db-2 bin]# pwd /usr/local/mysql/bin –》存放可执行文件的目录初始化MySQL 1[root@changsha-tianlong-db-2 bin]# ./mysqld --initialize --user=mysql --basedir=/usr/local/mysql/ --datadir=/data/mysql 复制mysql客户端命令到PATH变量路径里，方便后面使用 1[root@changsha-tianlong-db-2 bin]# cp mysql /usr/bin/ 配置能使用service 方式启动mysql，因为需要一个启动脚本，这个脚本mysql官方给我们提供了，直接复制过去就ok了 12345678[root@changsha-tianlong-db-2 mysql]# cp support-files/mysql.server /etc/init.d/mysqld[root@changsha-tianlong-db-2 mysql]# service mysqld startStarting MySQL.Logging to '/data/mysql/changsha-tianlong-db-2.err'.SUCCESS! [root@changsha-tianlong-db-2 mysql]# service mysqld restartShutting down MySQL.. SUCCESS! Starting MySQL. SUCCESS! [root@changsha-tianlong-db-2 mysql]# 登录mysql，使用临时密码 123456789101112131415[root@changsha-tianlong-db-2 mysql]# mysql -uroot -p'drNo5dIR?OXN'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 2Server version: 5.7.25Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; 修改密码 123456mysql&gt; set password='Sanchuang123#'; #修改密码Query OK, 0 rows affected (0.00 sec)mysql&gt; exitBye[root@changsha-tianlong-db-2 mysql]# 退出验证密码是否修改成功 1234567891011121314151617[root@changsha-tianlong-db-2 mysql]# mysql -uroot -p'Sanchuang123#'mysql: [Warning] Using a password on the command line interface can be insecure.Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 4Server version: 5.7.25 Source distributionCopyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; mysql&gt; quit 退出Bye 安装完后的工作：数据库服务器一般不启用防火墙，主要是考虑性能的问题。会在数据库服务器的前面加一个防火墙。 关闭防火墙firewalld，并且设置开机不要启动。123456789101112131415[root@changsha-tianlong-db-2 mysql]# service firewalld stop 关闭firewalld服务Redirecting to /bin/systemctl stop firewalld.service[root@changsha-tianlong-db-2 mysql]# systemctl disable firewalld 禁止开机启动Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.[root@changsha-tianlong-db-2 mysql]# iptables -L 查看防火墙规则Chain INPUT (policy ACCEPT)target prot opt source destination Chain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination [root@changsha-tianlong-db-2 mysql]# 关闭selinux1234567[root@changsha-tianlong-db-2 mysql]# getenforce Enforcing[root@changsha-tianlong-db-2 mysql]# setenforce 0 #临时关闭selinux[root@changsha-tianlong-db-2 mysql]# getenforce Permissive[root@changsha-tianlong-db-2 mysql]# vi /etc/selinux/config [root@changsha-tianlong-db-2 mysql]# cat /etc/selinux/config https://wx3.sinaimg.cn/mw690/006BsDmEgy1g3mr7h2stpj30i00cvq3m.jpg 考虑设置mysql服务开机启动123456789101112131415[root@changsha-tianlong-db-2 mysql]# systemctl enable mysqld #使用新式方式设置开机启动，提醒不能使用，建议我们使用老式的chkconfig方式mysqld.service is not a native service, redirecting to /sbin/chkconfig.Executing /sbin/chkconfig mysqld on[root@changsha-tianlong-db-2 mysql]# chkconfig mysqld on 设#置mysqld服务开机启动[root@changsha-tianlong-db-2 mysql]#[root@changsha-tianlong-db-2 mysql]#[root@changsha-tianlong-db-2 mysql]# chkconfig --list 注：该输出结果只显示 SysV 服务，并不包含原生 systemd 服务。SysV 配置数据可能被原生 systemd 配置覆盖。 要列出 systemd 服务，请执行 'systemctl list-unit-files'。查看在具体 target 启用的服务请执行'systemctl list-dependencies [target]'。mysqld 0:关 1:关 2:开 3:开 4:开 5:开 6:关netconsole 0:关 1:关 2:关 3:关 4:关 5:关 6:关network 0:关 1:关 2:开 3:开 4:开 5:开 6:关[root@changsha-tianlong-db-2 mysql]# 重新启动服务器reboot 重启—-init 6poweroff关机进入linux系统 12345678[root@mysql-2 ~]# lsof -i:3306COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEmysqld 6788 mysql 27u IPv6 37709 0t0 TCP *:mysql (LISTEN)[root@mysql-2 ~]# ps aux|grep mysqldroot 6619 0.0 0.0 115436 1732 ? S 15:43 0:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql-2.pidmysql 6788 1.7 9.4 1571372 176096 ? Sl 15:43 0:01 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=mysql-2.err --pid-file=/data/mysql/mysql-2.pidroot 7249 0.0 0.0 112724 984 pts/0 S+ 15:44 0:00 grep --color=auto mysqld[root@mysql-2 ~]# 说明mysql真得是开机启动了 使用SQLyog远程连接到MySQL授权一个用户能远程登录1234mysql&gt; grant all on *.* to 'root'@'%' identified by 'Sanchuang123#';Query OK, 0 rows affected, 1 warning (0.02 sec)mysql&gt; 使用SQLyog远程连接注：编译安装mysql的时候，建议内存给大些，给4G，cpu给2个核就可以了服务器一般都是固定IP编译安装：1.编译前的配置（如果编译器是gcc）,主要是用来生成MakeFile文件–》就是编译的时候的配置文件例如：安装到什么位置，哪些功能开，哪些不开？yum install pcre-devel zlib-devel gcc gcc-c++./configure –prefix=/usr/local/nginx2.make 编译 ，根据MakeFile文件进行编译，将源代码编译成二进制文件3.make install 编译安装，其实就是将编译好的二进制文件复制到安装目录去。 yum安装-不建议使用1yum install MySQL -y poweroff 是关机的命令reboot 重新启动init 6 重新启动 需要2台虚拟机–》克隆 centos7里默认的数据库是Mariadb不是mysql mariadb是MySQL的分支 MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可 MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。在存储引擎方面，使用XtraDB（英语：XtraDB）来代替MySQL的InnoDB。 MariaDB由MySQL的创始人Michael Widenius（英语：Michael Widenius）主导开发，他早前曾以10亿美元的价格，将自己创建的公司MySQL AB卖给了SUN，此后，随着SUN被甲骨文收购，MySQL的所有权也落入Oracle的手中。MariaDB名称来自Michael Widenius的女儿Maria的名字。 数据库排名https://db-engines.com/en/ranking 购买mysql的规矩：一台电脑只能安装一套软件。 根据电脑里的cpu的颗数，颗数越多价格越高","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://chenxl18.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://chenxl18.github.io/tags/MySQL/"},{"name":"安装","slug":"安装","permalink":"https://chenxl18.github.io/tags/安装/"}]}]}